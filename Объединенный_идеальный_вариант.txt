Часть I. Фундамент веба
Глава 1. Как работает Интернет
Глава 2. Архитектура браузера
Глава 3. Рендеринг: путь от HTML до пикселей
Глава 4. Семантика HTML и доступность

Часть II. CSS: от основ до продвинутых инструментов
Глава 5. Основы CSS
Глава 6. Современная экосистема CSS
Глава 7. Препроцессоры и инструменты CSS

Часть III. JavaScript: фундамент, механика, архитектура
Глава 8. Основы языка
Глава 9. Глубокая механика JavaScript
Глава 10. Работа с DOM
Глава 11. Асинхронность

Часть IV. Инфраструктура: сборка, тестирование, инструменты
Глава 12. NPM, package.json и зависимости проекта
Глава 13. Сборщики
Глава 14. Тестирование

Часть V. TypeScript: строгая типизация для фронтенда
Глава 15. Основы TS
Глава 16. Продвинутый TS

Часть VI. React и современная разработка SPA
Глава 17. Основы React
Глава 18. Хуки и управление состоянием
Глава 19. Архитектура больших приложений
Глава 20. SSR и современный React-стек

Часть VII. Архитектура и проектирование
Глава 21. Паттерны проектирования
Глава 22. Архитектуры фронтенда

Часть VIII. Производительность и безопасность
Глава 23. Производительность
Глава 24. Безопасность во фронтенде

Часть IX. Node.js для фронтенд-разработчика
Глава 25. Основы Node.js

Часть X. Подготовка к собеседованию
Глава 26. Алгоритмические задачи для фронтенда
Глава 27. Поведенческое собеседование
Глава 28. Итоговый чек-лист
28.1. Что должен знать Junior
28.2. Что должен знать Middle
28.3. Типичные ошибки кандидатов
28.4. Финальные советы

________________________________________

Часть I. Фундамент веба
Глава 1. Как работает Интернет

Интернет кажется магией: ты вводишь в адресной строке "google.com" — и через долю секунды видишь страницу. На самом деле внутри происходит цепочка процессов, и если их понять, весь фронтенд становится куда логичнее: рендеринг, производительность, ошибки сети, кэш, CORS, WebSockets — всё это начинает складываться в цельную картину.

Для фронтенд-разработчика важно понимать это достаточно глубоко, чтобы:
• грамотно объяснять сетевые проблемы
• понимать задержки доставки данных
• диагностировать производительность
• понимать ограничения браузера
• уверенно отвечать на собеседованиях уровня Middle+

________________________________________
1.1. Архитектура сети: краткое введение

Когда разработчик открывает браузер и вводит URL — кажется, что «страница просто загружается». На самом деле за этим стоит сложная, многоуровневая архитектура:
• физические сети (оптика, медные кабели, беспроводные сети)
• провайдеры и магистральные маршрутизаторы
• протоколы передачи данных
• система адресации (IP)
• система доменных имён (DNS)
• стек TCP/IP
• протоколы прикладного уровня (HTTP, TLS, WebSocket и др.)

Как устроен Интернет концептуально
Интернет — это не «глобальный сервер», а сеть сетей. Тысячи автономных систем (AS — Autonomous Systems) соединены между собой через протокол BGP.

Условная модель:
[Ваш компьютер] 
      ↓
[Домашний роутер] 
      ↓
[Провайдер (ISP)] 
      ↓
[Магистральные маршрутизаторы]
      ↓
[Дата-центр / Сервер / CDN]

Каждый переход — это hop. Количество hop влияет на задержку (latency).

________________________________________
1.2. DNS, IP, TCP/UDP: что происходит под капотом

Когда пользователь вводит:
https://example.com
запускается цепочка сетевых операций.

1.2.1. DNS — система доменных имён
DNS — это «телефонный справочник Интернета». Он превращает доменное имя в IP-адрес.

Процесс DNS-lookups:
1. Браузер проверяет локальный кэш
2. Система (OS) проверяет свой кэш
3. Обращение к DNS-серверу провайдера
4. Если нет записи — запрос к корневому серверу
5. Дальше — к серверу зоны (.com)
6. Потом — к авторитетному серверу домена
7. Возвращается IP-адрес

Обычно нужно 20–120 мс, и это влияет на TTFB и производительность.

1.2.2. IP — адресация в сети
IP-адрес — это «номер квартиры» в огромном доме Интернета.
Примеры:
• IPv4: 192.168.0.1
• IPv6: 2001:db8::ff00:42:8329

IPv6 решает проблему нехватки адресов и уменьшает количество hop.

1.2.3. TCP — надёжный транспорт
TCP обеспечивает:
• гарантированную доставку
• контроль последовательности
• контроль потерь
• повторную отправку пакетов

Это похоже на отправку посылки с квитанцией о получении.

Но! TCP создаёт задержку, потому что устанавливает трёхстороннее рукопожатие:
SYN → SYN-ACK → ACK

Это иногда +100 мс к первому запросу.

1.2.4. UDP — быстрый транспорт
UDP — простой и быстрый протокол без гарантий.
Используется для:
• стриминга
• WebRTC
• игр
• DNS

QUIC (HTTP/3) работает поверх UDP.

________________________________________
1.3. HTTP/1.1 vs HTTP/2 vs HTTP/3 (QUIC)

HTTP/1.1 — «6 людей в очередь к одному окну»
• последовательные запросы
• head-of-line blocking
• нужно много TCP-соединений
• нагрузки на сервер больше

Браузер открывает до 6 соединений на домен. Каждое соединение может обрабатывать только один запрос за раз. На медленных сетях это катастрофа.

HTTP/2 — «одна широкая труба вместо шести узких»
Решает ключевые проблемы:
• мультиплексирование (несколько запросов в одном TCP)
• сервер пушит данные (Server Push)
• бинарный протокол
• сжатие заголовков (HPACK)

Проблема: TCP всё ещё медленный при потерях.

HTTP/3 (QUIC) — «дрон вместо машины»
• работает поверх UDP
• каждый HTTP-поток — независимый
• потери не блокируют остальные запросы
• 0-RTT для повторных подключений (после первого handshake)
• меньше задержек в мобильных сетях

Сегодня HTTP/3 даёт лучшую стабильность и скорость, особенно на мобильных.

________________________________________
1.4. HTTPS и TLS Handshake

HTTPS = HTTP + TLS (шифрование)

Процесс установки защищённого соединения:
1. Клиент отправляет список поддерживаемых алгоритмов
2. Сервер выбирает алгоритм и отправляет сертификат
3. Клиент проверяет сертификат (trusted CA)
4. Обмениваются ключами
5. Устанавливается шифрованный канал

Проблема: это обычно добавляет 1 RTT (round-trip time)
В HTTP/3 это оптимизировано.

________________________________________
1.5. Цикл запрос–ответ

Упрощённая цепочка:
1. Ввод URL
2. DNS запрос
3. Установление TCP/TLS
4. Отправка HTTP-запроса
5. Сервер формирует ответ
6. Клиент получает данные
7. Рендер страницы

Интервьюеры любят спрашивать:
«Что происходит от момента, когда вы нажимаете Enter?»

________________________________________
1.6. Методы HTTP, идемпотентность и безопасность запросов

Методы
• GET — без побочных эффектов
• POST — создаёт данные
• PUT — заменяет
• PATCH — частично обновляет
• DELETE — удаляет

Идемпотентность
Идемпотентный запрос можно повторить без изменения результата.
• GET — да
• PUT — да
• DELETE — обычно да
• POST — нет

На собеседованиях любят задавать вопрос про PUT vs PATCH.

________________________________________
1.7. Коды состояния HTTP

Группы:
• 1xx — информационные
• 2xx — успех
• 3xx — редиректы
• 4xx — ошибка клиента
• 5xx — ошибка сервера

Важно знать:
• 200 OK
• 201 Created
• 301/302 Redirect
• 304 Not Modified (не скачивай, у тебя есть свежая копия)
• 400 Bad Request
• 401/403 Authorization
• 404 Not Found
• 429 Too Many Requests (лимиты запросов)
• 500 Internal Error
• 503 Service Unavailable

________________________________________
1.8. REST, SOAP, GraphQL, gRPC — сравнительный обзор

Технология	Особенности	Где используется
REST	простота, ресурсы, HTTP	классические API
SOAP	XML, строгая схема	банки, корпорации
GraphQL	один endpoint, декларативность	фронтенд-heavy приложения
gRPC	бинарный протокол, очень быстро	микросервисы

На фронтенд собеседованиях GraphQL спрашивают регулярно.

________________________________________
1.9. CORS и Same-Origin Policy

Same-Origin Policy:
origin = protocol + domain + port

Пример:
https://example.com:443
http://example.com:80 → другой origin
https://api.example.com → другой origin

CORS — механизм, позволяющий частично ослаблять это правило.

Важно:
CORS настраивает сервер, а не браузер. Браузер лишь исполняет политику сервера.

________________________________________
1.10. WebSockets и SSE

WebSocket — полноценный диалог
• двусторонняя связь
• постоянное соединение
• чаты, игровая логика

Пример:
const ws = new WebSocket('wss://echo.example');
ws.onmessage = e => console.log(e.data);
ws.send('Привет');

SSE (Server-Sent Events) — односторонний канал
• односторонний поток от сервера к клиенту
• легче, чем WebSocket
• автоматическое переподключение
• дешевле по ресурсам

Как радио: сервер говорит, клиент слушает.

________________________________________
Вопросы на собеседовании

1. Опишите, что происходит, когда пользователь вводит URL в браузер.
Короткий и хороший ответ:
1. Проверка кэша
2. DNS-резолв
3. TCP-handshake
4. TLS-handshake (если HTTPS)
5. HTTP-запрос → HTML
6. Парсинг HTML → DOM
7. Загрузка CSS/JS
8. Рендеринг

2. В чём отличие HTTP/1.1, HTTP/2 и HTTP/3?
• HTTP/1.1 — много соединений, блокировки
• HTTP/2 — одно соединение, мультиплексирование
• HTTP/3 — QUIC/UDP, меньше задержек, устойчивость при потере пакетов

3. Что такое DNS и зачем он нужен?
DNS — система доменных имён, превращающая доменное имя в IP-адрес. Это «телефонный справочник Интернета».

4. Чем TCP отличается от UDP?
TCP — надёжный протокол с гарантией доставки, но с задержками из-за handshake. UDP — быстрый, без гарантий, используется для стриминга и игр.

5. Что такое TLS Handshake?
Процесс установки защищённого соединения, включающий обмен сертификатами и ключами. Обычно добавляет 1 RTT к первому запросу.

6. Что такое идемпотентность?
Свойство запроса, позволяющее повторять его без изменения результата. GET, PUT, DELETE — идемпотентны, POST — нет.

7. Что такое CORS?
Cross-Origin Resource Sharing — механизм, позволяющий ослаблять Same-Origin Policy. Настраивается на сервере.

8. Чем WebSocket отличается от SSE?
• WebSocket — двустороннее общение
• SSE — только сервер → клиент
• SSE проще, WS мощнее

Key Takeaways (краткое резюме)
• Интернет — это набор уровней: DNS, TCP, TLS, HTTP.
• Самые дорогие операции — DNS и handshakes.
• HTTP/2 и HTTP/3 радикально ускоряют загрузку.
• HTTPS обязателен — это не роскошь.
• CORS — серверная политика, браузер лишь её исполняет.
• WebSocket — для диалога, SSE — для трансляций.
• Понимание сетевого стека — важный навык middle/senior разработчика.

________________________________________

Часть I. Фундамент веба
Глава 2. Архитектура браузера

Браузер — это не просто «программа для открытия сайтов». Это сложная многопроцессная система, которая одновременно:
• загружает данные из сети
• исполняет JavaScript
• рисует интерфейс
• изолирует вкладки друг от друга
• защищает пользователя от вредоносных страниц

Для фронтенд-разработчика понимание его внутренней структуры — это не академическая теория, а практический инструмент:
• для оптимизации производительности,
• для предотвращения ошибок рендеринга,
• для осмысленной работы с потоками, событиями, памятью,
• для уверенных ответов на собеседовании Senior/Middle уровня.

________________________________________
2.1. Многопроцессная модель браузеров

Раньше браузеры были однопроцессными. Один сбой на странице падал весь браузер. Современные движки (Chrome/Blink, Firefox/Gecko, Safari/WebKit) используют многопроцессную архитектуру.

Основная идея
Браузер разделяет работу на независимые процессы:
• падение вкладки не ломает всю программу,
• повышается безопасность (sandboxing),
• повышается производительность (параллелизм).

Браузер — это, по сути, маленькая операционная система.

2.1.1. Какие процессы выделяют браузеры

В Chrome обычно есть:

1. Browser Process (главный процесс) — «режиссёр», управляющий спектаклем
Отвечает за:
• управление окнами и вкладками,
• сетевой стек,
• доступ к диску,
• навигацию между страницами.

Он не рендерит сайт. Он — администратор, который распределяет задачи другим процессам.

2. Renderer Processes (процессы рендеринга) — «фабрика по превращению данных в пиксели»
В них происходит:
• парсинг HTML,
• выполнение JavaScript (V8 для Chrome, SpiderMonkey для Firefox),
• layout, paint, composite.

Каждый такой процесс изолирован в песочнице. В НЁМ ИСПОЛНЯЕТСЯ ВАШ JAVASCRIPT.

Почему рендеринг изолирован в отдельном процессе?
Чтобы вредный скрипт из одной вкладки не мог:
• прочитать память другой вкладки
• получить доступ к файлам
• получить доступ к камере или микрофону
• «уронить» весь браузер

Изоляция страниц — важнейшая часть современной безопасности.

3. GPU Process — «графический движок браузера»
Нужен для:
• аппаратного ускорения
• компоновки слоёв (compositor)
• WebGL
• рендеринга CSS-трансформаций

Это важно понимать для оптимизации:
• transform и opacity рендерятся на GPU
• top/left изменяют layout → CPU → Reflow
Разница в производительности огромная.

4. Network Service Process — «курьерская служба браузера»
Полностью отвечает за:
• DNS резолвинг
• HTTP/HTTPS
• кэширование
• сокеты
• работу с cookies

С рендерером взаимодействует через IPC.

5. Utility Processes
Отдельные процессы для специфических задач:
• аудио
• видео декодирование
• PPAPI-плагины
• шрифты
• WebAuthn

Почему так сделано?
1. Безопасность через sandboxing.
Renderer не имеет прямого доступа к файловой системе, только через IPC.
2. Изоляция вкладок.
Одна «плохая» страница не тормозит остальные.
3. Скорость.
Работа параллелится.

________________________________________
2.2. Навигация: что происходит при вводе URL

Когда вы нажимаете Enter — запускается строго определённый pipeline, похожий на работу аэропорта:

Подробная последовательность
1. Пользователь вводит URL
2. Браузер определяет, нужно ли создавать новый процесс рендеринга
3. Browser Process вызывает Network Service
4. Выполняется DNS lookup
5. Устанавливается TCP/TLS соединение
6. Отправляется HTTP-запрос
7. Получается ответ с HTML
8. Browser Process создаёт Renderer Process (если нужен)
9. HTML передаётся в Renderer
10. Renderer начинает парсинг:
   • строит DOM
   • строит CSSOM
   • создаёт render tree
   • выполняет JS
11. Renderer отправляет GPU-командам раскладку и слои
12. Страница отображается

When does navigation commit?
Начало загрузки ≠ видимая страница.
Commit происходит после получения первых байтов HTML.

________________________________________
2.3. Site Isolation

После уязвимостей Spectre/Meltdown (2018) браузеры усилили безопасность.

Сегодня:
Каждая вкладка не только в своём процессе — но и каждая вкладка разделена по «сайтам» (origin).

Если в одной вкладке есть iframe с чужим origin — этот iframe рендерится в отдельном процессе.

Это замедляет браузер? Иногда — да. Но даёт огромный скачок безопасности.

________________________________________
2.4. Предварительные оптимизации загрузки

Браузеры умеют предсказывать, какие ресурсы вам понадобятся.

DNS Prefetch
<link rel="dns-prefetch" href="//cdn.example.com">
Заранее выполняет DNS-запрос.

Preconnect — «заранее установи TCP/TLS handshake»
<link rel="preconnect" href="https://fonts.googleapis.com">
«Пока пользователь читает заголовок, сходи, пожалуйста, пожми руки с этим сервером, чтобы потом грузить быстрее».
Это мощная оптимизация для шрифтов.

Prefetch — «загрузи это на будущее»
<link rel="prefetch" href="/next-page.html">
Загружает данные, которые возможно понадобятся позже.
Prefetch не блокирует загрузку основного контента.

Preload — «загрузи этот ресурс СЕЙЧАС, он критически важен»
<link rel="preload" href="/main.css" as="style">
Говорит браузеру: «этот ресурс точно критичен».
Без preload браузер узнаёт о CSS только после парсинга HTML.

Отличие prefetch и preload — частый вопрос на собеседовании.

________________________________________
2.5. Жизненный цикл страницы

DOMContentLoaded
• HTML загружен и распарсен
• CSS и картинки могут ещё грузиться
• JS (не async/defer) уже отработал

load
• Загружено абсолютно всё, включая картинки
• Страница полностью готова

visibilitychange
• Пользователь переключил вкладку
• Важное событие для аналитики и оптимизации

________________________________________
2.6. IPC (Inter-Process Communication)

Процессы браузера общаются между собой не напрямую, а через IPC.

Это критично для понимания:
• Почему eval() запрещён в некоторых режимах
• Почему расширения работают изолированно
• Почему DOM не доступен в Web Worker

Web Worker — другой процесс, у которого нет доступа к DOM, потому что DOM — это структура, живущая в рендерер-процессе.

________________________________________
Вопросы на собеседовании

1. Опишите архитектуру современного браузера.
Браузер работает как мини-операционная система с несколькими процессами:
• Browser Process — управляет вкладками и навигацией
• Renderer Processes — парсинг, JS, layout, paint
• GPU Process — композиция слоёв
• Network Process — сетевые запросы

2. Что такое Renderer Process и что в нём происходит?
Процесс рендеринга отвечает за DOM, CSSOM, JavaScript и layout. В нём исполняется ваш JavaScript.

3. Почему Chrome использует многопроцессную модель?
• стабильность (падение вкладки не ломает браузер)
• безопасность (sandboxing, изоляция)
• производительность (параллелизм)

4. Объясните разницу между preconnect, prefetch и preload.
• preconnect — заранее устанавливает TCP/TLS соединение
• prefetch — загружает ресурсы на будущее (не блокирует)
• preload — загружает критический ресурс сейчас (блокирует)

5. Что происходит после ввода URL в адресную строку?
См. раздел 2.2 — полная последовательность от DNS до рендеринга.

6. Как работает sandbox в браузере?
Renderer не имеет прямого доступа к файлам, сети, аппаратуре — только через IPC с главным процессом.

7. Какие браузерные процессы отвечают за JS и за GPU?
• JavaScript исполняется в Renderer Process
• GPU-операции выполняются в GPU Process

8. Что делает Network Process?
Отвечает за DNS, HTTP/HTTPS, кэширование, сокеты, cookies.

Key Takeaways (краткое резюме)
• Браузер работает как мини-операционная система с кучей процессов.
• Главный процесс управляет вкладками.
• Процесс рендеринга отвечает за DOM, CSSOM, JavaScript и layout.
• GPU-процесс отвечает за отрисовку и композицию слоёв.
• Site Isolation изолирует разные origin в разных процессах ради безопасности.
• Preload/prefetch/preconnect помогают управлять приоритетами загрузки.
• Веб-страница проходит через события DOMContentLoaded → load → остальные.

________________________________________

Часть I. Фундамент веба
Глава 3. Рендеринг: путь от HTML до пикселей

Это одна из центральных глав всей книги. Она объясняет то, что на собеседованиях спрашивают постоянно — от Junior до Senior уровня.

Попробуй представить: ты открываешь сайт, и буквально за миллисекунды перед тобой появляется целый интерфейс — кнопки, картинки, тексты, анимации. Но браузер — это не художник, который рисует страницу кистью. Он — инженер, который строит страницу по плану.

Процесс превращения HTML в картинку можно сравнить с работой архитектурного бюро:
1. Получить проект (HTML).
2. Составить список материалов (CSS).
3. Построить структуру здания (DOM).
4. Применить стиль и внешний вид (CSSOM).
5. Собрать модель здания (Render Tree).
6. Разложить элементы по местам (Layout).
7. Покрасить и отделать стены (Paint).
8. Собрать слои в финальный кадр (Composite).

Это и есть Critical Rendering Path.

Понимание рендеринга даёт вам:
• способность оптимизировать интерфейсы,
• умение объяснять performance-проблемы,
• уверенность при работе с layout, стилями и JavaScript,
• знание того, почему интерфейсы «дергаются»,
• умение писать быструю анимацию,
• понимание, как реально работает браузер.

________________________________________
3.1. Парсинг HTML и построение DOM

Фронтенд-разработчики часто думают о HTML как о «тексте». Но для браузера HTML — это инструкции.

Когда сетевой процесс приносит HTML, рендерер начинает читать его посимвольно, как книгу. И по ходу чтения строит DOM-дерево:
• <html> становится корнем
• <body>, <head> — детьми
• каждый тег становится узлом
• текстовые узлы тоже входят в DOM

Этапы обработки HTML:
1. HTML поступает в Renderer Process потоково
2. Парсер считывает текст посимвольно
3. Строится токенизация (открывающий тег, атрибуты, текст)
4. На основе токенов формируются узлы
5. Узлы образуют DOM (Document Object Model)

DOM — это не HTML.
HTML — строка текста.
DOM — структура данных в памяти.

Аналогия: Когда ты читаешь книгу, у тебя в голове появляется «карта» событий и персонажей. DOM — это такая же карта, только для браузера.

Блокирующие моменты при загрузке HTML
HTML-парсинг может быть остановлен по нескольким причинам:
• встречен <script> без атрибута defer
• встречен <link rel="stylesheet">
• встречены синхронные операции, влияющие на рендеринг

Вот типичный пример блокировки:
<script src="main.js"></script>
Парсер останавливается, пока:
1. JS-файл загружается
2. выполняется

Поэтому используют:
<script src="main.js" defer></script>
или
<script src="main.js" async></script>

Частый вопрос на собеседовании:
Чем defer отличается от async?
• async — скачивается параллельно, выполняется сразу после загрузки
• defer — скачивается параллельно, выполняется после полного парсинга HTML

________________________________________
3.2. CSSOM и блокирующие ресурсы

CSS-файлы — блокирующие.

Почему?
Потому что браузер не может корректно построить render tree, пока не знает, какие стили применяются.

Поэтому:
<link rel="stylesheet" href="styles.css">
останавливает рендеринг до загрузки и парсинга CSS.

CSSOM (CSS Object Model) строится аналогично DOM, но из CSS-правил.

Пример:
body {
  font-size: 16px;
}

#title {
  color: red;
}

Станет структурой наподобие:
body:
  font-size: 16px

#title:
  color: red

CSSOM важен по двум причинам:
1. Без CSSOM браузер не может начать рендеринг. Это причина, почему CSS блокирует отображение.
2. Если использовать сложные селекторы (div ul li span:first-child), CSSOM пересчёт становится дорогим.

Почему CSS блокирует рендеринг?
Потому что изменение CSS влияет на layout и внешний вид, и браузеру нужно гарантировать корректность.

JS может зависеть от стилей:
div.offsetWidth

Поэтому порядок важен:
• сначала DOM
• затем CSSOM
• потом Render Tree

________________________________________
3.3. Render Tree и вычисление Layout

После DOM и CSSOM браузер создаёт Render Tree:
Render Tree = DOM-узлы, которые видимы, + вычисленные стили.

Важно понимать: Render Tree ≠ DOM

Пример:
<div style="display: none;">Hello</div>
Этот элемент есть в DOM. Но его нет в Render Tree, потому что он не отображается.

Не попадают в Render Tree:
• display: none
• head
• script

После Render Tree вычисляется Layout (reflow):
• width
• height
• position
• шрифты
• box-model
• размер и положение каждого элемента

Layout — дорогая операция.

Работу layout можно сравнить с расстановкой мебели в квартире:
1. Определить размеры комнаты (viewport).
2. Понять размеры мебели (элементов).
3. Расставить так, чтобы всё поместилось и не перекрылось.

Важный момент
Layout может быть:
• частичным
• полным
• рекурсивным

И он может запускаться снова и снова при:
• изменении размеров окна
• добавлении элементов
• изменении содержимого
• изменении стилей (особенно размеров)

Это называется reflow.

________________________________________
3.4. Paint, Composite и GPU-ускорение

После Layout идет:

Paint (рисование) — браузер красит элементы пиксель за пикселем
После layout у браузера есть «скелет» страницы — он знает, где и что стоит. Теперь пора всё визуально нарисовать.

Paint — это:
• цвет фона
• цвет текста
• бордеры
• тени
• изображения
• outline

Это самый «ручной» этап. Браузер превращает каждый визуальный элемент в набор команд:
• нарисовать прямоугольник
• залить цветом
• провести линию
• вставить текст
• наложить тень

Painter проходит по дереву и рисует битмапы.

Composite (компоновка слоёв)
Современные браузеры отображают страницу не как один большой холст. Они разбивают её на слои.

Например:
• элемент с position: fixed — почти всегда отдельный слой
• элемент с transform — отдельный слой
• элемент с will-change: opacity — отдельный слой
• canvas
• видео
• анимации

GPU-процесс потом берет все слои и композитит их — совмещает.

Это похоже на Photoshop:
• слой с фоном
• слой с картинками
• слой с текстом
• слой с анимациями

GPU смешивает эти слои в один кадр. GPU композитит их 60 раз в секунду (или 120 на ProMotion дисплеях).

Это позволяет анимировать элементы без reflow и repaint.

Практический принцип:
Анимируйте только opacity и transform.
Другие свойства вызывают reflow или repaint.

________________________________________
3.5. Reflow vs Repaint: что вызывает и как избегать

Это важнейшая тема для оптимизации интерфейсов.

Reflow (Layout)
Когда браузер пересчитывает расположение элементов.

Вызывают:
• изменение размера окна
• изменение стилей layout-а (width, height, margin, padding, position, font-size)
• изменение DOM
• clientWidth / offsetTop / getBoundingClientRect
• добавление/удаление узлов

Браузер должен пересчитать layout, иногда — всей страницы. Это дорого.

Repaint (Paint)
Перерисовка визуальных деталей без изменения layout.

Вызывают:
• color
• background
• border-color
• visibility

Расположение не меняется → layout не запускается. Дороже, чем просто смена opacity, но дешевле layout.

Composite-only
Если меняется только opacity, transform — браузер трогает только GPU-композицию. Это самый дешёвый тип изменения.

Как избежать?
• минимизировать DOM-операции
• использовать DocumentFragment
• применять transform вместо left/top
• группировать изменения (reflow batching)
• избегать запроса layout-свойств в цикле

________________________________________
3.6. JavaScript и рендеринг: кто блокирует кого

JavaScript блокирует рендеринг, если:
• выполняется синхронно
• меняет layout
• вставляет новые DOM-узлы
• вызывает тяжёлые операции (offsetHeight, getBoundingClientRect)

Пример:
const height = element.offsetHeight; // вызывает reflow
element.style.height = height + 10 + 'px'; // ещё один reflow

Это называется layout thrashing.

Проблемы производительности: layout thrashing
Layout thrashing — это когда код вызывает чередование reflow и repaint.

Пример плохого кода:
for (let i = 0; i < 1000; i++) {
  element.style.left = i + "px";
  console.log(element.offsetLeft); // провоцирует reflow
}

Браузер:
1. меняет стиль
2. пересчитывает layout
3. печатает
4. снова …

Используйте:
1. промежуточные переменные
2. batching через rAF
3. read → write порядок

________________________________________
3.7. requestAnimationFrame и оптимизация анимаций

Для плавных анимаций браузер использует render loop — цикл, который рисует новые кадры.

Анимации по таймеру:
setInterval(() => { ... }, 16);
работают плохо — они не синхронизированы с частотой обновления монитора.

requestAnimationFrame (rAF)
Даёт оптимальное время для рендера кадра. Браузер вызывает rAF перед следующим кадром, обычно 60 FPS.

Это означает:
• обновление в момент, когда GPU готов
• идеальная синхронизация
• лучший FPS
• отсутствует рваная анимация

Используйте rAF для:
• анимаций
• параллакса
• canvas
• плавного UI

Timers (setTimeout, setInterval) этим не обладают.

________________________________________
3.8. Почему важен Critical Rendering Path

CRP — это набор шагов, которые браузер должен пройти, прежде чем пользователь увидит хоть что-то.

Фактически: Чем короче CRP — тем быстрее сайт кажется пользователю.

Укоротить CRP можно:
• уменьшив CSS (так как он блокирует рендеринг)
• используя preload
• уменьшая количество JavaScript, блокирующего парсинг
• избегая больших layout-операций
• уменьшая количество уровней вложенности DOM

События жизненного цикла страницы
DOMContentLoaded
Срабатывает, когда DOM готов, но CSS и картинки могут ещё грузиться.

load
Срабатывает, когда всё загружено — CSS, картинки, iframe.

visibilitychange
Позволяет оптимизировать поведение, когда вкладка скрыта.

Где это спрашивают?
На собеседованиях Middle/Senior любят спросить:
• "Когда выполнить скрипт?"
• "В чём разница между DOMContentLoaded и load?"
• "Почему JS влияет на рендеринг?"

Оптимизация рендеринга: золотые правила
1. Анимируй только transform + opacity
2. Используй will-change умеренно
3. Минимизируй глубину DOM
4. Не вычитывай layout-свойства в цикле
5. Избегай больших таблиц и теней
6. Разгружай heavy JS в Web Workers

________________________________________
Вопросы на собеседовании

1. Опишите полностью pipeline рендеринга страницы.
Ответ:
• браузер парсит HTML → DOM
• парсит CSS → CSSOM
• объединяет → Render Tree
• делает layout
• делает paint
• делает composite

CRP важен, потому что он определяет скорость появления контента.

2. Что такое DOM, CSSOM и Render Tree?
• DOM — дерево объектов, представляющих HTML-структуру
• CSSOM — дерево стилей из CSS-правил
• Render Tree — объединение видимых DOM-узлов с вычисленными стилями

3. Почему <script> блокирует рендеринг?
Потому что JS может изменить DOM и CSSOM, поэтому браузер должен дождаться выполнения скрипта перед продолжением парсинга.

4. Что такое reflow и repaint?
• reflow (layout) — пересчёт расположения элементов (дорого)
• repaint — перерисовка визуальных деталей без изменения layout (дешевле)

5. Какие CSS-свойства вызывают Layout?
width, height, margin, padding, position, font-size и другие, влияющие на размеры и расположение.

6. Что делает requestAnimationFrame?
Синхронизирует обновления с частотой обновления экрана, даёт оптимальное время для рендера кадра.

7. Как работает GPU-композитинг?
Браузер разбивает страницу на слои, GPU смешивает их в один кадр 60 раз в секунду. Это позволяет анимировать без reflow/repaint.

8. Как избежать layout thrashing?
• группировать чтения layout-свойств
• использовать промежуточные переменные
• применять batching через rAF
• следовать порядку: read → write

9. В чём разница между visibilitychange и load?
• visibilitychange — когда вкладка скрыта/показана
• load — когда все ресурсы загружены

10. Какие элементы не входят в Render Tree?
display: none, head, script и другие невидимые элементы.

Key Takeaways (краткое резюме)
• Браузер превращает HTML в пиксели через цепочку DOM → CSSOM → Render Tree → Layout → Paint → Composite.
• CSS блокирует рендеринг до тех пор, пока не построен CSSOM.
• JavaScript может замедлять рендеринг, блокируя парсинг HTML.
• Reflow — самая дорогая операция; избегай её в циклах.
• Самые дешёвые анимации — те, что используют только transform и opacity.
• Оптимизация CRP — ключ к быстрой загрузке сайта.
• requestAnimationFrame синхронизирует анимации с частотой обновления экрана.

________________________________________

Часть I. Фундамент веба
Глава 4. Семантика HTML и доступность

Эта глава — фундаментальная для всех уровней фронтенда. Семантика, доступность (a11y), корректные формы и стандартная вёрстка — то, что отличает инженера от «верстальщика-кодера».

Когда мы пишем HTML, мы можем воспринимать его как банальный контейнер для контента: div, div, div… Но для браузера, для поисковиков, для экранных читалок (screen readers) и для пользователей HTML — это структура смысла.

Если разметка семантическая, то страница становится:
• понятной для машины
• удобной для пользователя
• доступной для людей с ограничениями зрения
• индексируемой для поисковых систем
• устойчивой к визуальным изменениями и CSS

Это не «приятная надстройка» — это основа веба. Подумаем о семантической разметке как о скелете, который определяет, где у страницы голова, где туловище, где разделы, где навигация.

На собеседованиях это проверяют, потому что:
• семантика влияет на SEO,
• доступность — требование законодательства в ряде стран,
• screen readers и assistive technologies — важная часть современного веба,
• корректная семантика ускоряет разработку, облегчает поддержку и улучшает UX.

________________________________________
4.1. Что такое семантика простыми словами

Семантика — это использование правильных HTML-элементов для правильных задач.

Например:
• <button> — для кнопки
• <nav> — для навигации
• <header> — для шапки
• <main> — для основного контента
• <article> — для самостоятельного блока содержания

Конечно, можно собрать интерфейс полностью из div'ов. Но это как писать книгу без заголовков, абзацев и оглавления: человек разберётся, а машина — нет.

________________________________________
4.2. Семантические теги HTML5

HTML5 привёл более чёткую структуру документа. Вот основные теги и их роль:

Структурные теги
Тег	Для чего
<header>	Заголовок страницы или секции
<nav>	Основная навигация
<main>	Основное уникальное содержимое страницы
<section>	Раздел страницы (логически связанный блок)
<article>	Самодостаточный автономный блок: пост, новость, запись
<aside>	Боковая панель, дополнительные материалы
<footer>	Подвал секции или страницы

Важно: <header> и <footer> можно использовать не только один раз. Каждый раздел (<section>) может иметь свой header.

Текстовые теги
• <h1>–<h6> — иерархия заголовков
• <p> — параграф
• <strong> — важность
• <em> — акцент (интонация)
• <blockquote> — цитаты
• <figure> + <figcaption> — иллюстрации с описанием

Медиа-теги
• <video>
• <audio>
• <canvas>
• <picture> — адаптивные изображения

Почему важна семантика?
1. SEO — Поисковые системы анализируют структуру, чтобы понять, что на странице важно.
2. A11y (доступность) — Screen readers опираются на семантику для чтения структуры документа.
3. Поддерживаемость — Семантический HTML проще читать и поддерживать.
4. Улучшение UX — Правильная структура помогает пользователям навигировать по странице.
5. Браузерные оптимизации — Правильные теги улучшают рендеринг и влияют на поведение по умолчанию.

________________________________________
4.3. Правильные теги для правильной роли

Это та область, где часто допускаются ошибки.

Кнопки
Плохо:
<div onclick="submitForm()">Send</div>

Хорошо:
<button type="button">Send</button>

Почему?
• кнопка фокусируется клавиатурой
• кнопка активна при Enter и Space
• screen reader распознаёт её как кнопку
• у кнопки нативные стили поведения

Ссылки
Используем <a> для переходов, а не <button>.
Если действие должно открыть другую страницу — это ссылка.
Если действие меняет состояние внутри страницы — это кнопка.

________________________________________
4.4. ARIA и доступность

ARIA (Accessible Rich Internet Applications) — набор атрибутов, которые помогают screen readers понять назначение взаимодействия.

Главное правило:
Не добавляй ARIA там, где хватает нативной семантики.

ARIA используется, когда:
• нативного элемента нет (например, выпадающий список на кастомном UI)
• поведение меняется динамически
• нужно сообщать screen reader-ам состояние

Правило WAI-ARIA №1:
Не используйте ARIA, если можно использовать нативный элемент.

Основные ARIA-атрибуты

Роли (role)
• button
• dialog
• navigation
• alert
• checkbox
• progressbar

Пример:
<div role="button" tabindex="0">Save</div>
Но лучше:
<button>Save</button>

Состояния и свойства (aria-*)
• aria-label="…", aria-labelledby="…", aria-describedby="…"
• aria-hidden="true"
• aria-expanded="true/false"
• aria-selected
• aria-checked

Пример для раскрывающегося меню:
<button aria-expanded="false" aria-controls="menu">Menu</button>
<ul id="menu" hidden>
  <li>Item A</li>
</ul>

aria-label — невидимое текстовое описание:
<button aria-label="Search button">
  🔍
</button>

Контраст, размеры и фокус
• контраст текста и фона должен соответствовать WCAG 2.1
• минимальный размер интерактивного элемента — 44×44 px
• все интерактивные элементы должны быть фокусируемыми
• табуляция должна идти последовательно

Типичные ошибки новичков
• добавление ролей там, где они уже есть
• использование role="button" вместо <button>
• скрытие текста без альтернативы для screen reader
• наследование aria-атрибутов (что не работает)

________________________________________
4.5. Доступность интерфейсов: UX без мыши

Важно помнить: около 20% пользователей используют клавиатуру вместо мыши.

То есть интерфейс должен работать так:
• Tab перемещает фокус
• Enter/Space активируют элементы
• Escape закрывает popup
• Фокус не должен «застревать» в модальных окнах

Проблема с кастомными компонентами:
если ты создаёшь кастомный dropdown или modal из div'ов — тебе придётся вручную описывать навигацию по клавиатуре.

Визуальные скрытия vs доступные скрытия
Иногда нужно скрыть элемент визуально, но оставить доступным читателю.

Плохо:
display: none;

Хорошо:
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

________________________________________
4.6. Формы и валидация

Нативные элементы
• <label> (обязателен)
• <input>
• <textarea>
• <select>

Без <label> многие screen readers не понимают предназначение поля.

Обязательное правило:
<label for="email">Email</label>
<input id="email" type="email">

Почему?
• фокус можно поставить по клику на текст
• читатель вслух связывает label и input
• помогает автозаполнению

Типы input
Тип	Пример использования
text	обычные поля
email	проверка email встроена
number	допускает числовой ввод
tel	удобная клавиатура на мобильных
date	календарь
range	слайдер

Валидация HTML5
Атрибуты:
• required
• pattern
• min, max
• maxlength
• type="email"

Браузер сам покажет пользователю ошибку.

Custom-валидация через Constraint API
input.setCustomValidity("Введите корректный имейл");

Почему важно использовать нативную валидацию?
• она бесплатная,
• работает из коробки,
• идеально интегрирована с доступностью,
• не ломается при выключенном JS.

Таблицы
Используем:
• <thead>
• <tbody>
• <th>

И главное:
<th scope="col">Price</th>
<th scope="row">Tomatoes</th>

Это помогает людям с экранными читалками.

________________________________________
4.7. SEO-аспекты вёрстки

SEO = структура + семантика + скорость рендеринга.

Key моменты:
Заголовок h1 должен быть один — это основной смысл страницы.

Правильная структура заголовков
Нельзя перескакивать:
h1 → h2 → h3 → h2 → h3
Это помогает поискам понять логику разделов.

alt у изображений
Используют для:
• screen readers
• SEO
• fallback-текста при ошибках загрузки

Качество HTML влияет на индексирование
Ошибка:
<div onclick="...">Click me</div>
Правильно:
<button>Click me</button>
Нативные элементы лучше распознаются роботами.

________________________________________
4.8. Семантика и CSS: почему это влияет на рендеринг

Если DOM построен семантически:
• меньше вложенности → быстрее CSS селекторы
• меньше странных обёрток → проще layout
• браузеру легче построить структуру

Даже производительность UI выигрывает.

Семантика и SPA-фреймворки
Важно: React/Vue/Svelte не освобождают от семантики.

Ошибки:
• <div onClick> вместо <button>
• <div role="link"> вместо <a>
• модалки без aria-атрибутов
• отсутствие фокус-менеджмента

Хороший фронтендер всегда думает о доступности UI.

Стандарты и спецификации
Современный HTML живёт по принципу:
"Living Standard" — постоянно обновляющийся стандарт.

Главные источники:
• WHATWG HTML
• W3C (старые стандарты, используется частично)

Понимать спецификацию важно:
• для глубокой работы с DOM, events
• для понимания browser compatibility
• при собеседованиях Middle+ уровня

________________________________________
Вопросы на собеседовании

1. Что такое семантическая вёрстка?
Использование тегов HTML согласно их смыслу, а не ради внешнего вида.

2. Почему семантика важна?
• доступность
• SEO
• структурность
• предсказуемость рендеринга
• нативное поведение элементов

3. Для чего нужны <section> и <article>?
• <section> — смысловой подраздел страницы
• <article> — самодостаточный автономный блок контента

4. Что такое ARIA и когда она нужна?
ARIA — набор атрибутов для улучшения доступности. Используется только если нет нативных тегов или поведение сильно кастомное.

5. Почему <button> лучше, чем <div role="button">?
<button>:
• работает с клавиатурой
• имеет роль
• активируется Enter/Space
• фокусируется
• сообщает состояние screen reader

<div role="button">:
• нужно вручную реализовать всё поведение
• хуже для доступности
• чаще всего ошибка

6. Чем отличается aria-label от aria-labelledby?
• aria-label — прямое текстовое описание
• aria-labelledby — ссылка на ID другого элемента, который содержит описание

7. Какие правила доступности вы знаете?
• WCAG 2.1 стандарты
• контраст текста и фона
• минимальный размер интерактивного элемента 44×44 px
• все интерактивные элементы должны быть фокусируемыми
• правильная навигация по клавиатуре

8. Как правильно структурировать заголовки h1-h6?
Один h1 на страницу, иерархия без пропусков, логическая структура разделов.

9. Почему alt важен для SEO?
Alt-текст помогает поисковикам понять содержание изображения и улучшает индексирование.

10. Что такое WCAG?
Web Content Accessibility Guidelines — международные стандарты доступности веб-контента.

Key Takeaways (краткое резюме)
• Семантика — основа правильной структуры интерфейса.
• Доступность — не дополнительная опция, а обязательная часть разработки.
• Используйте нативные элементы прежде, чем ARIA.
• <button> и <a> — самые частые, но неправильные заменяемые элементы.
• Формы и таблицы требуют строгой семантики.
• Семантика улучшает SEO, UX, доступность и производительность.
• SPA-фреймворки требуют ещё большего внимания к a11y.
• WCAG 2.1 — стандарт доступности, который нужно знать.

________________________________________

Часть II. CSS: от основ до продвинутых инструментов
Глава 5. Основы CSS

Эта глава формирует базу для профессиональной работы с вёрсткой. Даже Senior-фронтендеры регулярно попадают в ловушки из-за неправильного понимания потоков, специфичности и механики layout.

Если HTML — это скелет, то CSS — это материалы и геометрия: размеры, цвета, сетки, отступы, размещение элементов. Проблема новичков и даже мидлов в том, что CSS кажется магией: почему-то блок прыгает, почему-то не центрируется, почему-то Grid не работает так, как в примере.

На самом деле CSS — это строгая система, и если понять её фундамент, то верстка становится предсказуемой, как математика.

CSS — это язык вычисления стилей, а не просто набор свойств. Браузер постоянно вычисляет:
• где находится элемент
• сколько он занимает
• какие правила к нему применяются
• как он реагирует на изменения структуры

Чтобы писать оптимальный и предсказуемый код, нужно глубоко понимать эти механизмы.

________________________________________
5.1. Бокс-модель и поток документа

Каждый элемент в CSS — это прямоугольная коробка (box). Абсолютно каждый: div, span, button, img, даже текстовые строки.

Состав box-модели:
+---------------------+
||     margin          |
||  +---------------+  |
||  |   border       | |
||  | +-----------+ | |
||  | | padding   | | |
||  | | +-------+ | | |
||  | | |content| | | |
||  | | +-------+ | | |
||  | +-----------+ | |
||  +---------------+ |
+---------------------+

Итого размер элемента:
width + padding + border + margin

Почему это важно?
Потому что 80% «непонятных» багов верстки происходят из-за того, что разработчик не учитывает, что padding/border расширяют коробку.

5.1.1. box-sizing

По умолчанию:
box-sizing: content-box;
Т.е. width задаёт только content, padding и border прибавляются.

Современная практика:
* {
  box-sizing: border-box;
}

Это делает расчёты проще и верстку предсказуемей. Поэтому почти все проекты начинают с этого.

border-box: width включает padding и border.
width = content + padding + border

Это уменьшает количество сюрпризов.

________________________________________
5.2. Специфичность, наследование, каскад

CSS = Cascading Style Sheets.

Каскад — набор правил:
Если несколько селекторов претендуют на один элемент, применяется тот, что:
1. выигрывает по специфичности
2. если равны — тот, что ниже по порядку (позже в файле)
3. если есть !important — оно побеждает всё, но использовать его нужно осторожно

Специфичность
Тип селектора	Вес
inline-style	1000
#id	100
.class, [attr], pseudo-class	10
tag, pseudo-element	1

Пример:
#header .menu li a { ... }
Вес = 100 + 10 + 1 + 1 = 112

Наследование
Некоторые свойства наследуются автоматически:
• font-size
• color
• line-height

Другие никогда не наследуются:
• padding
• margin
• border
• background

Приоритеты
1. user-agent stylesheet (браузер)
2. ваш CSS
3. inline-стили
4. !important

________________________________________
5.3. Display: как элемент ведёт себя по умолчанию

CSS не только про внешность. Это язык для управления поведением элементов.

display: block
Характеристики:
• занимает всю строку
• начинается с новой строки
• можно задавать width/height
• можно задавать margin-top / bottom
Примеры: div, section, p.

display: inline
Характеристики:
• не начинает новую строку
• игнорирует width/height
• реагирует только на горизонтальные margin/padding
Примеры: span, a.

inline-block
Середина между inline и block:
• стоит в строке
• можно задавать размеры

display: none
Полностью исключает элемент из рендера, layout и событий. С точки зрения браузера такой элемент не существует.

________________________________________
5.4. Позиционирование

Понимание позиционирования — ключ к грамотной вёрстке. Позиционирование — не магия, а строгая иерархия контекстов.

Типы:
1. static — по умолчанию. Элемент следует нормальному потоку документа.
2. relative — смещение относительно собственных координат. Сохраняет место в потоке, но позволяет смещать элемент относительно самого себя.
3. absolute — относительно ближайшего positioned ancestor. Удаляется из потока. Контекст позиционирования ищется вверх по дереву: первый элемент с position отличным от static. Если такого нет → relative к viewport.
4. fixed — относительно viewport. Фиксируется относительно viewport. Не зависит от прокрутки. Используется для шапок, кнопок «вверх», модальных оверлеев. Недостаток: внутри скролл-контейнеров fixed игнорирует родительский scroll.
5. sticky — гибрид relative и fixed. Одна из самых полезных фишек современного CSS. Элемент ведёт себя так: пока внутри родителя → relative, когда достигает указанной позиции → fixed.

Пример:
header {
  position: sticky;
  top: 0;
}

________________________________________
5.5. Flexbox: полное руководство

Flexbox — идеальный инструмент для одномерных раскладок. Это система, ориентированная на одну ось: горизонтальную или вертикальную. Его задача — распределять пространство.

Основные свойства контейнера:
display: flex;
flex-direction: row | column | row-reverse | column-reverse;
justify-content: center | space-between | space-around | space-evenly | flex-start | flex-end;
align-items: center | flex-start | flex-end | stretch;
flex-wrap: wrap;

Основные свойства элемента:
flex-grow: 0 | 1 | … — делит свободное пространство
flex-shrink: 1 | 0 — определяет, как элемент сжимается
flex-basis: auto | ... — базовая ширина (или высота в column-направлении)
align-self: … — переопределяет align-items для конкретного элемента
order: … — порядок отображения

Как это работает?
Flexbox сначала распределяет пространство по одной оси (основной), затем по другой (вторичной).

Примеры:
Равномерное распределение:
.container {
  display: flex;
  justify-content: space-between;
}

Центрирование:
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}

Когда использовать Flexbox:
• меню и навигация
• header/footer
• горизонтальные списки
• простые карточки
• центровка

________________________________________
5.6. CSS Grid: современная раскладка

Grid — это двумерный инструмент: строки + колонки. Если Flex — линейка, то Grid — арочная система строительства.

Пример базовой сетки:
.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 20px;
}

fr — это «фракция свободного пространства».

gap — современная замена margin'ам между элементами. Работает и в Flexbox!

Выравнивание в Grid
Grid даёт больше возможностей:
• align-items
• justify-items
• place-items
• align-content
• justify-content

Grid Areas:
grid-template-areas:
  "header header"
  "sidebar main"
  "footer footer";

Авторазмещение:
grid-auto-flow: dense;

Когда Flex, когда Grid?
Случай	Инструмент
Один ряд/колонка	Flexbox
Две оси, сетка	Grid
Равномерное распределение	Flex
Макет страницы	Grid

Когда использовать Grid:
• сложные массовые сетки
• страницы каталога
• галереи
• адаптивные макеты
• формы/панели/таблицы

Grid способен заменить Bootstrap/12-column system без фреймворков.

________________________________________
5.7. Адаптивная и отзывчивая вёрстка

Адаптивность — не только media queries. Это целый набор инструментов.

Media queries
Классический метод:
@media (max-width: 768px) {
  .sidebar {
    display: none;
  }
}

Частые брейкпоинты:
• 320 (мобильный минимум)
• 480
• 768 (tablet)
• 1024
• 1280
• 1440
• 1920

Но хороший адаптив строится от контента, а не от устройств.

Mobile-first стратегия
Современная лучшая практика:
1. Пишем стили для мобильной версии
2. Добавляем более сложные стили для больших экранов через min-width

Flexbox и Grid делают адаптив проще
Flex-wrap:
flex-wrap: wrap;

Grid-автоматизация:
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
Это мощнейший приём.

Fluid typography и современные функции
Например:
font-size: clamp(1rem, 2vw, 2rem);
Это значит:
• меньше 1rem → не уменьшать
• больше 2rem → не увеличивать
• в пределах — масштабировать от ширины экрана

Responsive images
Используем srcset:
<img
  src="image-640.jpg"
  srcset="image-640.jpg 640w, image-1280.jpg 1280w"
  sizes="(max-width: 600px) 100vw, 50vw"
>
Браузер сам выбирает правильное изображение.

Единицы измерения для адаптивности
• % — от родителя
• vw, vh — доли viewport
• rem, em — относительные единицы
• fr — единицы Grid

Практические примеры
Пример 1: центрирование блока
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

Пример 2: адаптивная карточка
.card {
  padding: 20px;
  background: #fff;
}

@media (min-width: 768px) {
  .card {
    display: grid;
    grid-template-columns: 1fr 2fr;
  }
}

Пример 3: sticky header
header {
  position: sticky;
  top: 0;
  background: white;
}

________________________________________
5.8. Частые ошибки при работе с CSS

1. Перекрывающиеся margin collapsing
2. Использование float вместо flex/grid
3. Избыточные вложенности (.app .page .wrapper .content…)
4. pixel-perfect попытки (которые ломают адаптивность)
5. Тяжёлые селекторы (ul li a span {})
6. width: 100vw (вызывает горизонтальный скролл)
7. Фиксированные высоты (ломают responsive)

________________________________________
Вопросы на собеседовании

1. Объясните бокс-модель.
content + padding + border + margin. box-sizing изменяет расчёт.

2. Что делает box-sizing: border-box?
width включает padding и border, что делает расчёты проще и верстку предсказуемей.

3. В чём разница между static / relative / absolute / fixed / sticky?
• static — нормальный поток
• relative — смещение относительно себя, место в потоке сохраняется
• absolute — относительно positioned ancestor, удаляется из потока
• fixed — относительно viewport, не зависит от прокрутки
• sticky — гибрид relative и fixed, прилипает при достижении порога

4. Как работает Flexbox?
Одномерная система распределения пространства. Сначала по главной оси, затем по поперечной.

5. Как работает Grid?
Двумерная система: строки + колонки. Позволяет создавать сложные макеты.

6. В чём разница justify-content и align-items?
• justify-content — выравнивание по главной оси
• align-items — выравнивание по поперечной оси

7. Чем Grid отличается от Flexbox?
Flex — одномерная система (одна ось). Grid — двухмерная (строки + колонки).

8. Что такое media queries?
Правила CSS, применяемые в зависимости от характеристик устройства (ширина, высота и т.д.).

9. Что такое mobile-first?
Стратегия разработки, при которой сначала пишутся стили для мобильных устройств, затем добавляются стили для больших экранов.

10. Как работает специфичность?
Система весов селекторов: inline-style (1000) > #id (100) > .class (10) > tag (1).

11. Когда grid-template-columns: 1fr 1fr 1fr имеет смысл?
Когда нужно равномерно поделить пространство между тремя колонками.

12. Что такое clamp()?
Функция CSS для задания адаптивных, но ограниченных значений.

13. Как сделать карточки, которые автоматически перестраиваются в зависимости от ширины контейнера?
Grid с auto-fit/auto-fill:
grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));

Key Takeaways (краткое резюме)
• CSS — строгая система, а не хаос.
• Бокс-модель и box-sizing — основа стабильной верстки.
• Display определяет поведение, а не внешний вид элемента.
• Позиционирование — это слои логики, а не хаотичные абсолюты.
• Flexbox идеален для одномерных макетов, Grid — для двухмерных.
• Адаптивность — это комбинация: брейкпоинты + fluid + современные единицы.
• Grid и Flex делают фреймворки вроде Bootstrap практически ненужными.
• Специфичность определяет, какое правило применится при конфликте.
• Mobile-first — современная лучшая практика адаптивной вёрстки.

________________________________________

Часть II. CSS: от основ до продвинутых инструментов
Глава 6. Современная экосистема CSS

CSS прошёл огромный путь: от простого языка для раскраски HTML до полноценной системы управления стилями, динамическим поведением и архитектурой интерфейсов.

Современный CSS — это уже не только color: red, а целая экосистема инструментов:
• кастомные свойства (CSS Variables)
• каскадные слои (Cascade Layers)
• современные селекторы
• тёмные темы без JS
• CSS-модули
• CSS-in-JS
• методологии вроде БЭМ
• Shadow DOM

В этой главе мы выходим за рамки «чистого CSS» и переходим к тому, как стили пишутся в реальных проектах: с изоляцией, масштабированием, переиспользованием и защитой от конфликтов.

На собеседованиях уровня Middle+ эту главу часто используют, чтобы понять:
• работали ли вы с большими кодовыми базами;
• понимаете ли проблемы масштабирования CSS;
• умеете ли выбирать инструмент под задачу, а не наоборот.

Эта глава объяснит, как всё это работает вместе, чтобы стили были:
1. предсказуемыми
2. поддерживаемыми
3. масштабируемыми
4. удобными в разработке

________________________________________
6.1. CSS Custom Properties (переменные)

CSS-переменные — это настоящие runtime-переменные, в отличие от препроцессоров.

CSS-переменные выглядят так:
:root {
  --primary-color: #3b82f6;
  --spacing: 16px;
}

Использование:
.button {
  background: var(--primary-color);
  padding: var(--spacing);
}

Главное отличие custom properties от препроцессорных переменных

SCSS:
• подставляются во время сборки
• статичны
• не видны в DevTools как переменные

CSS custom properties:
• вычисляются во время работы
• наследуются
• динамически обновляются через JS
• участвуют в каскаде

Почему CSS-переменные — лучшее решение для темизации

Темная тема:
:root {
  --bg: white;
  --text: black;
}

[data-theme="dark"] {
  --bg: black;
  --text: white;
}

JS переключает только атрибут:
document.body.dataset.theme = 'dark';
А CSS сам всё перекрасит. Без перерендера, без миграций, без сложного JS.

Почему это важно?
• работают в runtime
• могут переопределяться в DOM
• реагируют на media queries
• удобны для темизации

________________________________________
6.2. Каскадные слои (CSS Cascade Layers)

Это один из самых больших апдейтов CSS за последние годы.

Проблема старая: когда проект растёт, порядок подключения файлов превращается в ад. Ты можешь подключать стили в нужной последовательности, но один маленький CSS от компонента ломает всю страницу.

Cascade Layers решают эту проблему.

Как это выглядит
@layer reset, base, components, utilities;

@layer reset {
  * { margin: 0; padding: 0; }
}

@layer base {
  body { font-family: sans-serif; }
}

@layer components {
  .btn { padding: 8px 12px; }
}

@layer overrides {
  .btn { padding: 16px; }
}

Приоритет зависит не от порядка объявления правил, а от порядка слоёв.

Почему это революция?
Теперь структура приоритетов стилей:
1. пользовательские стили (user styles)
2. авторские стили (author styles)
3. каскадные слои
4. важность: !important
5. специфичность
6. порядок объявления

Впервые за 25 лет CSS в середину каскада добавили ещё один уровень управления. Это делает большие проекты гораздо проще.

Используется в design-system'ах и UI-библиотеках.

________________________________________
6.3. Современные селекторы: has(), :is(), :where()

Эти селекторы — суперсила современного CSS.

:has() — «родительский» селектор, которого ждали десятилетиями
Пример: выделить карточку, если внутри есть ошибка.
.card:has(.error) {
  border-color: red;
}

CSS вдруг стал реактивным.

Другой пример: сделать кнопку активной, если выделен checkbox.
button:has(+ input:checked) {
  opacity: 1;
}

:is() — сокращает длинные селекторы
Вместо:
article p,
article span,
article a {
  color: gray;
}

Можно писать:
article :is(p, span, a) {
  color: gray;
}

:where() — тот же :is(), но со специфичностью 0
Очень полезно при сбросе стилей.
form :where(input, button, select) {
  margin: 0;
}

________________________________________
6.4. CSS Modules

CSS Modules — это расширение сборщика (Webpack, Vite, и др.), а не нативный CSS. Требует поддержки со стороны инструментов сборки.

CSS Modules решают главную проблему CSS — глобальную область видимости.

Это техника, сейчас распространённая в React/Vue/Svelte.

Пример:
/* button.module.css */
.primary {
  background: blue;
}

В JS:
import styles from './button.module.css';

<button className={styles.primary} />

Что происходит под капотом?
Класс превращается в:
primary__3Gh7s

Конфликты исчезают. Более того, стили компонентны по определению.

Плюсы:
• изоляция
• отсутствие конфликтов
• хорошая интеграция с React/Vue

Минусы:
• нельзя динамически формировать селекторы
• не нативный CSS
• требует сборки
• нет динамических runtime-возможностей (как у CSS Variables)

________________________________________
6.5. Styled-components и CSS-in-JS

CSS-in-JS — подход, при котором стили описываются прямо в JS. Появилась из мира React, но потом распространилась шире.

Идея простая: Компонент отвечает сам за свои стили. Стиль — это часть логики UI.

Самые популярные варианты:
• styled-components
• Emotion
• JSS
• stitches
• vanilla-extract

Пример (styled-components):
const Button = styled.button`
  padding: 10px;
  border-radius: 6px;
  background: ${props => props.primary ? 'blue' : 'gray'};
`;

Это сочетает:
• динамику JS
• читаемость CSS
• возможность темизации

Плюсы:
• динамические стили
• theme-поддержка
• колокация кода и стилей

Минусы:
• runtime-нагрузка
• сложнее дебажить
• зависит от библиотеки
• проблемы производительности в больших проектах

Когда CSS-in-JS оправдан?
• сложная тема
• динамические дизайн-системы
• UI-библиотеки
• стили зависят от props компонента, состояния, бизнес-логики

________________________________________
6.6. Shadow DOM и Web Components

Shadow DOM — механизм инкапсуляции DOM и CSS. Стили, которые невозможно «сломать».

const shadow = element.attachShadow({ mode: 'open' });
Стили внутри shadow root не протекают наружу и наоборот.

Shadow DOM изолирует компонент полностью:
<user-profile></user-profile>
Внутри элемента лежит «теневая» DOM-структура, недоступная из внешнего CSS.

Web Components включают:
1. Custom Elements
2. Shadow DOM
3. HTML Templates

Где используется?
• design-systems
• микрофронтенды
• библиотечные компоненты
• некоторые UI-библиотеки

Плюсы:
• гарантированная изоляция
• отсутствие конфликтов

Минус:
• сложнее переопределять стили

________________________________________
6.7. БЭМ: методология и практика

Методологии нужны только для больших проектов. Если ты работаешь над лендингом — BEM, скорее всего, лишний. Но в продуктовых командах методология даёт структуру.

БЭМ = Блок — Элемент — Модификатор

Принцип:
block
block__element
block--modifier

Пример карточки:
<div class="card card--featured">
  <h2 class="card__title">Header</h2>
  <button class="button button--primary">Buy</button>
</div>

Принципы:
• каждый блок независим
• вложенность минимальна
• селекторы простые
• стили предсказуемы

Плюсы БЭМ:
• масштабируемость
• читаемость
• легко поддерживать
• идеален для командной разработки

Минусы:
• длинные классы
• может казаться громоздким
• многословность
• строгая дисциплина

________________________________________
6.8. Когда что использовать (практические рекомендации)

Для продуктового интерфейса на React:
• style modules или CSS-in-JS
• CSS Custom Properties
• частично — Cascade Layers
• немного БЭМ для стабильных блоков

Для больших сайтов с множеством страниц:
• БЭМ
• каскадные слои
• переменные
• минимальный CSS-in-JS

Для виджетов и микрофронтендов:
• Shadow DOM
• CSS Variables
• изолированные стили

Для дизайн-систем:
• строгий БЭМ
• каскадные слои
• Grid/Flex
• переменные темизации

________________________________________
Вопросы на собеседовании

1. Чем CSS-переменные отличаются от SCSS-переменных?
CSS Variables — динамические, runtime, наследуются, участвуют в каскаде.
SCSS переменные — статические, compile-time, подставляются при сборке.

2. Что такое CSS Modules и зачем они нужны?
Техника изоляции стилей через уникальные имена классов. Решает проблему глобальной области видимости CSS.

3. В чём плюсы и минусы CSS-in-JS?
Плюсы: динамические стили, темизация, колокация. Минусы: runtime-нагрузка, сложнее дебажить, проблемы производительности.

4. Когда стоит использовать Shadow DOM?
Для виджетов, микрофронтендов, дизайн-систем, когда нужна абсолютная изоляция стилей.

5. Чем Web Components отличаются от React-компонентов?
Web Components — нативные браузерные компоненты с Shadow DOM. React-компоненты — виртуальный DOM и библиотека.

6. Что такое каскадные слои?
Механизм управления приоритетами стилей через уровни (layers), независимо от порядка подключения.

7. Как БЭМ помогает масштабировать CSS?
Структурирует именование, делает селекторы предсказуемыми, упрощает поддержку в команде.

8. Почему глобальный CSS — проблема?
Конфликты имён, сложность поддержки, непредсказуемость при масштабировании.

9. Что такое :has() и почему это важно?
Родительский селектор, позволяющий изменять стиль элемента в зависимости от содержимого. Революция для CSS.

Key Takeaways (краткое резюме)
• CSS Custom Properties — стандартный способ темизации.
• Cascade Layers дают новый уровень контроля над каскадом.
• Grid/Flex теперь поддерживаются всеми браузерами и заменяют фреймворки.
• CSS Modules дают изоляцию без runtime.
• CSS-in-JS полезен для динамических UI, но требует внимательности к производительности.
• БЭМ — надёжная методология для командных проектов.
• Shadow DOM даёт абсолютную изоляцию стилей.
• Современные селекторы (:has, :is, :where) расширяют возможности CSS.

________________________________________

Часть II. CSS: от основ до продвинутых инструментов
Глава 7. Препроцессоры и инструменты CSS

Эта глава посвящена инструментам, которые превращают CSS из «ручного ремесла» в управляемую инженерную систему.

CSS — мощный язык, но у него долгие годы не было важных возможностей: переменных, вложенности, миксинов, модульности. Разработчики решали это с помощью препроцессоров вроде SASS/SCSS и инструментов вроде PostCSS.

Сегодня эти технологии по-прежнему применяются — но их роль изменилась.

На реальных проектах «чистый CSS» почти никогда не используется в одиночку — вокруг него всегда есть экосистема.

На собеседованиях эту тему используют, чтобы проверить:
• работали ли вы с продакшн-сборками,
• понимаете ли разницу между compile-time и runtime,
• знаете ли, как оптимизировать CSS под продакшн.

Эта глава объясняет:
1. Зачем нужны препроцессоры (если есть современные CSS-фичи).
2. Что такое SCSS и чем он отличается от SASS.
3. Что делает PostCSS и почему без него не обходится продакшен.
4. Как уменьшать CSS и ускорять загрузку сайта.

________________________________________
7.1. Препроцессоры (SASS/SCSS): зачем они нужны

Препроцессор — это надстройка над CSS, которая:
• добавляет новые синтаксические возможности
• компилирует удобный код в обычный CSS
• помогает поддерживать большие проекты

В отличие от CSS-in-JS, SASS не внедряет стили во время работы приложения. Он работает до сборки: SCSS → CSS.

SASS — самый популярный CSS-препроцессор.
SCSS — его синтаксис, максимально близкий к CSS.

SCSS vs SASS: в чём разница

Есть два синтаксиса:

SASS — старый, без фигурных скобок
.card
  padding: 10px
  border: 1px solid #ccc

SCSS — современный, с фигурными скобками
.card {
  padding: 10px;
  border: 1px solid #ccc;
}

SCSS полностью совместим с CSS. Поэтому он стал де-факто стандартом.

________________________________________
7.2. Основные возможности SCSS

7.2.1. Переменные

До появления CSS Variables они выглядели так:
$primary: #3b82f6;
$spacing: 16px;

button {
  padding: $spacing;
  background: $primary;
}

Важно понимать: SCSS-переменные существуют только на этапе сборки. В runtime они исчезают.

Сегодня SCSS-переменные уступают кастомным, но используются в неподвижных константах:
• брейкпоинты
• размеры сетки
• длительности анимаций

7.2.2. Вложенность

.card {
  padding: 20px;

  &__title {
    font-size: 20px;
  }
}

Но важно помнить: лишняя вложенность → плохой CSS.

На собеседованиях это частый вопрос:
«Почему глубокая вложенность SCSS — анти-паттерн?»
Потому что она порождает длинные и тяжёлые селекторы.

7.2.3. Миксины

Миксины похожи на функции.
@mixin center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.box {
  @include center;
}

Миксины отлично подходят для:
• повторяющихся паттернов
• медиавыражений
• многострочных конструкций

⚠️ Миксины дублируют код. Использовать осторожно.

7.2.4. Наследование (@extend)

Осторожно: часто переносит лишние стили.
.button {
  padding: 10px;
}

.buy-button {
  @extend .button;
  background: green;
}

7.2.5. Функции SCSS

@function pxToRem($px) {
  @return $px / 16 * 1rem;
}

Это мощный инструмент, но помни: современный CSS уже имеет calc(), clamp(), min(), max(), и часть задач можно решать без препроцессоров.

7.2.6. @use и @forward

Современный подход вместо @import:
@use "colors";
@use "mixins";

Изолирует пространство имён и предотвращает конфликты.

⚠️ @import считается плохой практикой из-за глобальной области видимости.

________________________________________
7.3. Less

Less похож на SCSS, но:
• менее строг
• чаще используется в старых проектах
• меньше возможностей

Пример:
@primary: blue;

.button {
  color: @primary;
}

На новых проектах Less встречается реже.

________________________________________
7.4. PostCSS: сердце современного CSS-пайплайна

Если SASS — это язык, то PostCSS — платформа плагинов.

Он может:
• добавлять автопрефиксы
• минифицировать
• преобразовывать современные синтаксические возможности
• анализировать контент
• удалять неиспользуемый CSS

Сам по себе PostCSS ничего не делает — всё решают плагины.

Он не заменяет SASS. Они работают вместе в больших проектах.

Самые важные плагины PostCSS

Autoprefixer — стандарт де-факто
Он добавляет вендорные префиксы:
display: flex;
превращается в:
display: -webkit-box;
display: -ms-flexbox;
display: flex;

Вопрос на собеседовании:
Почему нельзя писать префиксы вручную?
Ответ:
• спецификация меняется
• браузеры обновляются
• огромное количество нюансов

postcss-preset-env
Позволяет использовать современный CSS прямо сейчас. Конвертирует в более старый синтаксис, если нужно.

PostCSS Import
Позволяет использовать @import без блокировки выполнения.

cssnano
Минификация CSS для продакшна. Удаляет пробелы, комментарии, сокращает объявления.

PurgeCSS / LightningCSS / UnCSS — удаление неиспользуемых стилей
Именно они позволяют уменьшить стили на 70–90%.

Работает так:
• анализирует HTML/JSX
• ищет, какие классы реально используются
• удаляет всё остальное

⚠️ Динамические классы нужно явно указывать.

________________________________________
7.5. Оптимизация CSS в реальных проектах

Оптимизация — это не «прикол», а обязательный этап производительности.

7.5.1. Critical CSS

Это CSS, который нужен для рендера первого экрана. Встраивается прямо в HTML:
<style>
  header { display: flex; }
</style>
Остальной CSS загружается асинхронно.

Идея:
• стили для первого экрана — inline
• остальное — загружается позже

Пример:
<style>
  /* critical css */
</style>
<link rel="preload" href="styles.css" as="style">

7.5.2. Минификация + объединение файлов

Современные бандлеры делают это автоматически, но понимать принцип важно:
• меньше веса
• меньше HTTP-запросов
• быстрее загрузка

Минификация и сжатие:
• удаление пробелов
• сокращение имён
• gzip / brotli

7.5.3. Splitting (разделение CSS по страницам)

Особенно важно для SPA:
• компонент открывается — подгружается его CSS
• не нужно грузить 300 KB стилей сразу

7.5.4. Avoid large DOM & heavy selectors

Современные браузеры быстрые, но тяжелые селекторы всё ещё вредят:

Плохо:
.app .container ul li a span {}

Хорошо:
.nav-link {}

7.5.5. Используйте современные единицы

Вместо:
• px → rem, em
• фиксированные размеры → auto/minmax
• жесткие брейкпоинты → clamp

________________________________________
7.6. Где препроцессоры всё ещё нужны

Несмотря на развитие CSS, SASS остаётся полезным:
• дизайн-системы
• большие UI-библиотеки
• проекты со старым кодом
• крупные корпоративные решения

SCSS остаётся удобным из-за:
• миксинов
• функций
• вложенности
• структурирования

Но тренд рынка идёт в сторону:
• CSS Modules
• CSS Variables
• PostCSS
• design tokens

Compile-time vs Runtime — важный вопрос

Инструмент	Когда работает
SCSS	compile-time
PostCSS	compile-time
CSS variables	runtime
CSS-in-JS	runtime

На собеседованиях часто спрашивают разницу.

________________________________________
Вопросы на собеседовании

1. Чем SCSS отличается от CSS-переменных?
CSS Variables — динамические, runtime, участвуют в каскаде.
SCSS переменные — статические, compile-time, подставляются при сборке.
Они решают разные задачи: SASS — архитектура на уровне сборки, CSS Variables — темизация и runtime управление.

2. Почему @import считается плохой практикой?
Глобальная область видимости, конфликты имён, проблемы с порядком загрузки.

3. В чём разница между @use и @import?
@use изолирует пространство имён и предотвращает конфликты. @import — устаревший подход.

4. Что делает PostCSS?
Платформа для трансформации CSS через плагины: автопрефиксы, минификация, удаление неиспользуемого кода.

5. Зачем нужен Autoprefixer?
Добавляет вендорные префиксы автоматически. Нельзя писать вручную из-за постоянных изменений спецификации.

6. Как работает PurgeCSS?
Анализирует HTML/JSX, находит используемые классы, удаляет неиспользуемые стили. Уменьшает CSS на 70–90%.

7. Что такое Critical CSS?
Минимальный CSS, который нужен для рендера above-the-fold контента. Встраивается inline в HTML.

8. Почему нельзя злоупотреблять миксинами?
Миксины дублируют код, увеличивают размер финального CSS.

9. Compile-time vs runtime — в чём разница?
Compile-time — обработка на этапе сборки (SCSS, PostCSS). Runtime — обработка во время выполнения (CSS Variables, CSS-in-JS).

Key Takeaways (краткое резюме)
• SCSS остаётся полезным инструментом для архитектуры стилей.
• PostCSS — универсальный процессор, обязательный в продакшене.
• Autoprefixer и минификация — минимум для любого проекта.
• PurgeCSS сильно уменьшает размер CSS.
• Critical CSS ускоряет загрузку первого экрана.
• Современная экосистема делает стили предсказуемыми и модульными.
• Compile-time инструменты работают до сборки, runtime — во время выполнения.
• Тренд идёт в сторону CSS Modules и CSS Variables вместо препроцессоров.

________________________________________

Часть III. JavaScript: фундамент, механика, архитектура
Глава 8. Основы языка

JavaScript — это не «язык для кнопок», а полноценный многопарадигменный язык со своей моделью выполнения, типизацией и правилами, которые напрямую влияют на надёжность фронтенд-приложений.

Несмотря на всю кажущуюся простоту, JavaScript — один из самых неправильно понятых языков. Именно здесь происходит большинство ошибок, из-за которых код ведёт себя «не так».

На собеседованиях по JS чаще всего проверяют понимание механики, а не синтаксиса. Эта глава — фундамент, без которого невозможно уверенно двигаться дальше.

Эта глава раскладывает фундаментальные концепции в строгой, ясной и прикладной форме:
1. Типы данных
2. Приведение типов
3. Область видимости
4. Контекст выполнения
5. Lexical Environment
6. Hoisting
7. Стек вызовов и память

После этой главы все последующие темы — замыкания, прототипы, асинхронность — станут намного легче.

________________________________________
8.1. Типы данных и работа с ними

В JavaScript 8 типов данных:

Примитивы (хранятся по значению, а не по ссылке):
1. number
2. string
3. boolean
4. null
5. undefined
6. symbol
7. bigint

Ссылочный тип:
8. object (включая array, function, Map/Set, Date и т.д.)

Почему это важно
JS — динамически типизированный язык, но типы влияют на:
• поведение операторов
• сравнение
• передачу аргументов
• работу с памятью

Примитивы vs объекты

Примитивы копируются по значению:
let a = 10;
let b = a;
b = 20;
console.log(a); // 10

Объекты хранятся по ссылке:
let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 2;
console.log(obj1.x); // 2

b и a — это одна и та же область в памяти.

Примитивы иммутабельны. Если изменить строку — создаётся новая.

Пример вопроса на собеседовании:
Почему нельзя изменить символ в строке напрямую?
Ответ: Строки — примитивы, они неизменяемы. Любое «изменение» создаёт новое значение.

________________________________________
8.2. Приведение типов (Type Coercion)

JavaScript активно приводит типы неявно. JS пытается быть «умным» и конвертирует типы сам, что приводит к странным результатам.

Явное приведение
Number("42")     // 42
String(42)       // "42"
Boolean(1)       // true

Неявное приведение
"5" + 2   // "52"
"5" - 2   // 3
[] + []   // ""
{} + []   // "[object Object]"

Почему так происходит?
• + — оператор конкатенации и сложения (предпочитает конкатенацию, если есть строка)
• остальные арифметические операторы приводят к number

Truthy / Falsy значения

В JS всего 8 falsy значений:
• false
• 0
• -0
• 0n (BigInt)
• ""
• null
• undefined
• NaN

Всё остальное — truthy.

Сравнение == и ===

=== (строгое сравнение)
Сравнивает тип + значение.

== (нестрогое сравнение)
Перед сравнением приводит типы, часто нелогично:
0 == false       // true
"" == 0          // true
null == undefined // true
[] == 0          // true

На собеседовании правильный ответ:
В корпоративном коде всегда используй ===, кроме конкретных случаев сравнения с null.

________________________________________
8.3. Области видимости, hoisting и TDZ

Область видимости — это зона, где доступна переменная.

Три основных типа:
1. Global Scope
2. Function Scope
3. Block Scope (ES6)

var — function scope
if (true) {
  var x = 10;
}
console.log(x); // 10
var игнорирует блоки — переменная всплывает (hoisting).

let & const — block scope
if (true) {
  let y = 20;
}
console.log(y); // ReferenceError
let и const ограничены блоком { ... }.

Temporal Dead Zone (TDZ)
Даже если переменная объявлена ниже, она недоступна пока не выполнено объявление:
console.log(a); // ReferenceError
let a = 10;

TDZ — частый вопрос на собеседованиях. Если объяснить — плюс в вашу пользу.

Hoisting — поднятие переменных и функций

var hoisting
console.log(a); // undefined
var a = 5;

let/const hoisting
Они тоже поднимаются, но остаются в TDZ:
console.log(b); // ReferenceError
let b = 10;

Hoisting функций
Функции поднимаются полностью:
say(); // работает

function say() {
  console.log("Hello");
}

Но function expression не поднимается:
say(); // TypeError
const say = function() {};

________________________________________
8.4. var / let / const

Характеристика	var	let	const
Scope	function	block	block
Hoisting	да	да (TDZ)	да (TDZ)
Повторное объявление	да	нет	нет
Изменение значения	да	да	нет

Важно
const запрещает переназначение, но не изменение объекта:
const obj = {};
obj.x = 1; // OK

Почему var считается устаревшим?
• отсутствие block scope
• hoisting может приводить к ошибкам
• не поддерживает TDZ

________________________________________
8.5. Функции

Function Declaration
function sum(a, b) {
  return a + b;
}
Hoisted полностью. Можно вызвать до объявления.

Function Expression
const sum = function(a, b) {
  return a + b;
};
Поднимается только переменная, но не значение.

Arrow Function
const sum = (a, b) => a + b;
Отличия стрелок:
• нет собственного this
• нет arguments
• нельзя использовать как конструктор

Named function expression
const factorial = function fact(n) {
  if (n === 0) return 1;
  return n * fact(n - 1);
};
Полезно для рекурсии, но почти не используется новичками.

________________________________________
8.6. Контекст выполнения (Execution Context)

Когда JS запускает код, он создаёт execution context, который состоит из:
• Lexical Environment
• Variable Environment
• This binding

На собеседовании стоит объяснять просто:
Контекст выполнения — это внутренняя структура, которую движок создаёт для исполнения кода. Он определяет, какие переменные доступны, как работают замыкания и чему равен this.

Lexical Environment: где хранятся переменные
Фундамент JS.

Lexical Environment состоит из:
• Environment Record (хранилище переменных)
• ссылка на внешний Lexical Environment

Это и есть причина существования замыканий.

Почему JS называется «лексически скоупированным»?
Потому что область видимости определяется не во время выполнения, а во время написания (lexing).

function outer() {
  const x = 10;

  function inner() {
    console.log(x);
  }

  inner();
}
inner всегда увидит x, потому что был создан внутри outer.

________________________________________
8.7. Стек вызовов и управление памятью

JS — однопоточный язык. Это значит, что есть один call stack.

Пример стека
function a() {
  b();
}

function b() {
  c();
}

function c() {
  console.log("Hi");
}

a();

Порядок стека:
global
a
b
c

После выполнения c выталкивается, и так далее.

Heap — область для хранения объектов
Примитивы → stack
Объекты → heap

Это объясняет, почему объекты передаются по ссылке.

Garbage Collector (GC)
JS использует алгоритм mark-and-sweep:
1. Ищет все объекты, до которых можно «дойти» из root.
2. Остальные удаляет автоматически.

Это важно понимать при работе с замыканиями: замыкание может удерживать память дольше, чем вы ожидаете.

________________________________________
Вопросы на собеседовании

1. Какие типы данных есть в JS?
7 примитивов (number, string, boolean, null, undefined, symbol, bigint) + object.

2. В чём разница между примитивами и объектами?
Примитивы копируются по значению, объекты — по ссылке. Примитивы иммутабельны.

3. Что такое неявное приведение типов?
Автоматическое преобразование типов JavaScript при операциях, часто нелогичное (например, "5" + 2 = "52").

4. Что такое hoisting?
Механизм, при котором объявления переменных и функций поднимаются вверх области видимости.

5. Что такое TDZ?
Temporal Dead Zone — период между «поднятием» переменной и её фактической инициализацией. let/const находятся в TDZ до объявления.

6. Чем var отличается от let и const?
var — function scope, hoisting без TDZ, можно переобъявлять. let/const — block scope, TDZ, нельзя переобъявлять.

7. Когда использовать стрелочные функции?
Для коллбэков, коротких функций, функционального программирования. Не использовать как методы объектов.

8. В чём разница между call, apply и bind?
• call — вызывает функцию сразу, аргументы через запятую
• apply — вызывает функцию сразу, аргументы массивом
• bind — создаёт новую функцию с привязанным контекстом

9. Объясните разницу между == и ===.
== приводит типы перед сравнением, === сравнивает тип и значение без приведения.

10. Что такое область видимости?
Зона, где доступна переменная. Бывает global, function, block.

Key Takeaways (краткое резюме)
• JavaScript имеет 7 примитивов + объекты по ссылке.
• Неявное приведение типов — причина многих багов.
• === предпочтительнее почти всегда.
• let/const имеют блочную область видимости и TDZ.
• Lexical Environment — основа скоупа и замыканий.
• Hoisting поднимает объявления, но не значения.
• JS — однопоточный, со стеком вызовов и кучей памяти.
• var устарел из-за отсутствия block scope и проблем с hoisting.
• Function Declaration поднимается полностью, Expression — нет.

________________________________________

Часть III. JavaScript: фундамент, механика, архитектура
Глава 9. Глубокая механика JavaScript

Эта глава — ключевая для уровня Middle и Strong Middle. Именно здесь чаще всего «отваливаются» кандидаты: this, замыкания, прототипы и модули проверяют не знание синтаксиса, а понимание того, как язык работает под капотом.

Функции — центральная сущность JavaScript. Это не просто способ повторного использования кода, а фундамент механизма:
• области видимости
• замыканий
• контекста исполнения
• прототипов
• классов

Но главная причина путаницы в JS — это контекст (this). Часто говорят: «this в JS ведёт себя странно». На самом деле он ведёт себя строго и логично, если понимать правила.

Эта глава объясняет:
1. Виды функций
2. Как создаются функции
3. Как работает this
4. Отличие call / apply / bind
5. Отличие стрелочных функций
6. Замыкания
7. Прототипы
8. Модули
9. Важные edge-cases из реальных собеседований

________________________________________
9.1. this: правила вычисления контекста

this — не свойство функции, а значение, определяемое в момент вызова.

Главное правило JS:
this определяется в момент вызова, а не в момент объявления.

Но важно понимать: стрелочные функции — исключение (they capture lexical this).

5 основных правил определения this

1. Global context
console.log(this); // window (в браузере)
В strict mode:
"use strict";
console.log(this); // undefined

2. Method call: obj.method()
const user = {
  name: "Alex",
  say() {
    console.log(this.name);
  }
};
user.say(); // Alex
this = объект слева от точки.

3. Function call: func()
function say() {
  console.log(this);
}
say(); // window / undefined
В строгом режиме this = undefined.
В нестрогом — глобальный объект (window в браузере).

4. Explicit binding: call / apply / bind
function show() {
  console.log(this.name);
}
const obj = { name: "Bob" };
show.call(obj); // "Bob"
show.apply(obj); // "Bob"
show.bind(obj)(); // "Bob"

5. new: вызов конструктора
function User(name) {
  this.name = name;
}
const u = new User("Alice");
console.log(u.name); // Alice

При вызове через new:
• создаётся новый объект
• this указывает на новый объект
• функция возвращает this, если явно не вернуть другой объект

Arrow functions
Стрелки не имеют собственного this:
const obj = {
  name: "Alex",
  say: () => {
    console.log(this.name);
  }
};
this берётся из внешнего контекста.

Важный принцип: Стрелочная функция не имеет собственного this. Она берёт this из внешнего lexical environment.

Пример:
const user = {
  name: "Alice",
  say: () => console.log(this.name)
};
user.say(); // undefined

Почему?
• стрелка смотрит наружу
• наружу — это глобальная область
• name там нет

________________________________________
9.2. call, apply, bind — отличия

call
fn.call(context, arg1, arg2, arg3...)
Передача аргументов через запятую. Вызывает функцию сразу.

apply
fn.apply(context, [args])
Передача аргументов массивом. Вызывает функцию сразу.
Чаще используется при работе с Math:
Math.max.apply(null, [1,2,3]); // 3

bind
bind создаёт новую функцию, навсегда привязанную к контексту.
const f = fn.bind(obj);
f(); // всегда this = obj

Это особенно важно в UI:
button.addEventListener("click", this.handleClick.bind(this));

Практический пример
function greet() {
  console.log(this.name);
}
const user = { name: "Alex" };
greet.call(user); // Alex

________________________________________
9.3. Стрелочные функции: полное объяснение

У стрелки нет:
• своего this
• arguments
• super
• new.target
• возможности вызываться через new
• прототипа

Это делает стрелку идеальной для:
• коллбэков
• коротких функций
• функционального программирования

Но плохой для методов объектов.

Правильное использование стрелок
Хорошо:
arr.map(x => x * 2);

Плохо:
const obj = {
  name: "Kate",
  say: () => console.log(this.name)
};
Стрелка не создаст свой this, и код станет некорректным.

this в стрелочных функциях внутри методов
Паттерн:
const obj = {
  value: 42,
  printLater() {
    setTimeout(() => {
      console.log(this.value); // 42
    }, 100);
  }
};

Почему работает?
Потому что стрелка берёт this из printLater — а он был вызван как метод.

________________________________________
9.4. Частые ловушки и edge cases

Потеря контекста
const user = {
  name: "Alice",
  say() { console.log(this.name); }
};

setTimeout(user.say, 1000); 
Результат: undefined

Почему?
Функция передаётся как callback. При выполнении она вызывается как обычная функция, без объекта слева.

Решение:
setTimeout(user.say.bind(user), 1000);

this внутри обработчиков
button.addEventListener('click', function() {
  console.log(this); // button
});

А вот стрелка:
button.addEventListener('click', () => {
  console.log(this); // берёт контекст выше (скорее всего window)
});

this в классах
class User {
  name = "Alice";

  say() {
    console.log(this.name);
  }
}

const u = new User();
u.say(); // работает

Но:
const say = u.say;
say(); // undefined
Метод потерял контекст. Это одна из самых частых ошибок Джунов.

Решение:
Привязка в конструкторе:
this.say = this.say.bind(this);

Стрелочные поля класса:
say = () => {
  console.log(this.name);
}

this и прототипное наследование
МЕТОД, НАХОДЯЩИЙСЯ В ПРОТОТИПЕ, ПРИ ВЫЗОВЕ КАК obj.method() ИМЕЕТ this = obj.

function User(name) {
  this.name = name;
}

User.prototype.say = function() {
  console.log(this.name);
};

const u = new User("Alex");
u.say(); // Alex

________________________________________
9.5. Замыкания (Closures)

Замыкание — это функция + её лексическое окружение.

Большинство разработчиков думают, что замыкания — это «функция, запоминающая переменные». Это верно, но это только поверхность.

Чтобы понимать замыкания по-настоящему, нужно понимать:
• как работает Lexical Environment
• как движок хранит ссылки на память
• как формируется цепочка окружений
• что происходит при возврате функции из функции

Что такое замыкание: простое определение
Замыкание — это функция, которая запоминает своё лексическое окружение даже после того, как внешняя функция завершила выполнение.

Пример:
function outer() {
  let x = 10;

  return function inner() {
    console.log(x);
  };
}

const fn = outer();
fn(); // 10

Вопрос на собеседовании:
Почему inner всё ещё знает о x, несмотря на то что outer уже закончил работу?

Правильный ответ:
Потому что inner хранит ссылку на Lexical Environment outer. Это и есть замыкание.

Lexical Environment: детальное объяснение
Каждая функция при создании запоминает:
• свои локальные переменные
• внешнее окружение

Lexical Environment выглядит примерно так:
Inner.LexicalEnvironment = {
  EnvironmentRecord: { ... },
  outer: Outer.LexicalEnvironment
}

То есть функции образуют цепочку окружений, а не «снимок переменных».

Замыкание — это ссылка, а не копия
Новички часто думают, что замыкание «копирует» значение переменной. Это неправда. Запоминается ссылка, а не значение.

Пример:
function counter() {
  let count = 0;

  return function() {
    count++;
    console.log(count);
  }
}

const c = counter();
c(); // 1
c(); // 2

Переменная count живёт в памяти, пока существует хотя бы одно замыкание, ссылающееся на неё.

Частая ошибка: замыкание внутри циклов
Одна из классических задач:
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10);
}
Вывод: 3 3 3

Почему?
Потому что var имеет функцию scope, и внутри всех стрелок i была одна и та же переменная.

Правильный способ:
Способ 1: заменить var на let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10);
}

Способ 2: IIFE
for (var i = 0; i < 3; i++) {
  ((j) => {
    setTimeout(() => console.log(j), 10);
  })(i);
}

Практическое применение замыканий
• инкапсуляция состояния
• фабрики функций
• мемоизация
• обработчики событий

Замыкания и приватность данных
До появления #private полей в классах, приватность делали через замыкания.

function createUser(name) {
  let secret = "hidden";

  return {
    getName() { return name; },
    getSecret() { return secret; }
  }
}

const u = createUser("Bob");
console.log(u.getSecret()); // hidden
Переменная secret — полностью недоступна извне.

Garbage Collector и замыкания
Замыкание удерживает переменные в памяти. Это может привести к утечкам.

Плохой пример:
function createBigClosure() {
  const hugeArray = new Array(1000000).fill("data");

  return function() {
    console.log("Using closure");
  };
}

const fn = createBigClosure();
// hugeArray никогда не освободится → утечка

Вывод: Используй замыкания осознанно.

________________________________________
9.6. Функции высшего порядка (HOF)

Функция высшего порядка — это функция, которая:
• принимает другую функцию
• возвращает другую функцию

Примеры встроенных HOF:
• map
• filter
• reduce
• forEach
• sort

Пример:
function withLogging(fn) {
  return function(...args) {
    console.log("Calling with", args);
    return fn(...args);
  };
}

const sum = (a, b) => a + b;
const logged = withLogging(sum);
logged(4, 5); // Calling with [4,5] → 9

Это и есть замыкание в работе.

Каррирование (currying)
Каррирование — это превращение функции из:
f(a, b, c)
в:
f(a)(b)(c)

Пример:
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }

    return function(...next) {
      return curried(...args, ...next);
    };
  };
}

Использование:
const sum = (a, b, c) => a + b + c;
const curried = curry(sum);
curried(1)(2)(3); // 6
curried(1, 2)(3); // 6

Где каррирование реально используется?
• валидация данных
• middleware
• логирование
• декораторы
• частичное применение

Частичное применение (partial application)
В отличие от каррирования, частичное применение фиксирует часть аргументов.

function partial(fn, ...fixed) {
  return function(...rest) {
    return fn(...fixed, ...rest);
  };
}

const multiply = (a, b, c) => a * b * c;
const double = partial(multiply, 2);
double(3, 4); // 24

________________________________________
9.7. Прототипы и наследование

JavaScript — прототипно-ориентированный язык. В основе JS — прототипная модель, а не классическая.

Что такое прототип — простое объяснение
Прототип — это объект, на который ссылается другой объект, чтобы наследовать свойства.

Каждый объект в JS имеет скрытую ссылку на свой прототип. Эта ссылка называется:
• [[Prototype]] (официально в спецификации)
• __proto__ (неофициально, но доступно в браузерах)

Примечание: __proto__ — устаревший способ доступа к прототипу.
Рекомендуется использовать:
• Object.getPrototypeOf(obj) — для получения прототипа
• Object.setPrototypeOf(obj, proto) — для установки прототипа
• Object.create(proto) — для создания объекта с прототипом

Пример:
const obj = {};
console.log(obj.__proto__); // устаревший способ
console.log(Object.getPrototypeOf(obj)); // рекомендуемый способ
Результат — объект Object.prototype.

Как работает поиск свойств: prototype chain
Когда вы обращаетесь к свойству:
user.name

JS выполняет поиск в несколько шагов:
1. Ищет name внутри объекта user
2. Если не найдено → смотрит в user.__proto__
3. Если не найдено → смотрит дальше по цепочке
4. Конечная точка — Object.prototype
5. Если нигде нет → результат undefined

Это называется цепочка прототипов.

Иллюстрация:
user → user.__proto__ → Object.prototype → null

Прототипная цепочка
obj → obj.__proto__ → Object.prototype → null

Пример
const animal = {
  eats: true
};

const dog = Object.create(animal);
dog.barks = true;

console.log(dog.eats); // true

Поиск свойства
1. объект
2. его prototype
3. prototype prototype
4. null

Функции и свойство prototype
Каждая функция в JS имеет свойство prototype.

Пример:
function User() {}
console.log(User.prototype); 

В prototype хранятся методы и свойства, которые будут доступны экземплярам, созданным через:
new User()

Важно: prototype есть только у функций
Не путай:
• у функции есть prototype
• у объекта есть __proto__
• и это не одно и то же

А связь такая:
instance.__proto__ === Constructor.prototype

Пример:
function User() {}
const u = new User();
console.log(u.__proto__ === User.prototype); // true

Создание объектов через new
При вызове функции-конструктора:
new User()

JS делает четыре шага:
1. создаёт пустой объект {}
2. связывает объект с прототипом: obj.__proto__ = User.prototype
3. вызывает функцию: User.call(obj)
4. возвращает новый объект

Это ключевое правило, которое любят спрашивать на собеседованиях.

Прототипное наследование: пример в чистом виде
Создаём прототип:
const animal = {
  eat() { console.log("eating"); }
};

Создаём объект, наследующий от animal:
const dog = {
  bark() { console.log("woof"); }
};
dog.__proto__ = animal;
dog.eat(); // "eating" — унаследовано

Наследование конструкторов (до ES6)
До появления классов писали так:
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name, "eats");
};

function Dog(name) {
  Animal.call(this, name); // наследование свойств
}

Dog.prototype = Object.create(Animal.prototype); // наследование методов
Dog.prototype.constructor = Dog;

Это важная конструкция — её всё ещё спрашивают, чтобы проверить понимание JS «под капотом».

________________________________________
9.8. Классы в JS: что под капотом

ES6 классы: синтаксический сахар, а не новая модель
Классы — это синтаксический сахар над прототипами.

Современный способ:
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(this.name, "eats");
  }
}

class Dog extends Animal {
  bark() {
    console.log(this.name, "barks");
  }
}

Под капотом:
• функции-конструкторы
• prototype-методы

Что такое super
В классах super используется в двух случаях:

super() в конструкторе наследника
Должен быть вызван до использования this.
class Dog extends Animal {
  constructor(name) {
    super(name);
  }
}

super.method()
Обращение к методу родителя.
class A {
  say() { console.log("A"); }
}

class B extends A {
  say() {
    super.say();
    console.log("B");
  }
}

Отличия классов от функций-конструкторов
1. классы не поднимаются (не hoisted)
2. методы в классе автоматически попадают в prototype
3. классы работают в strict mode
4. класс нельзя вызвать без new

Статические методы
class User {
  static createGuest() {
    return new User("Guest");
  }
}
Используются для фабрик и утилитарных методов.

Приватные поля (#)
Современный способ скрывать данные:
class User {
  #password = "secret";
  
  getPassword() {
    return this.#password;
  }
}

________________________________________
9.9. Модули: ES Modules vs CommonJS

ES Modules
export const sum = (a, b) => a + b;
import { sum } from "./sum.js";

Особенности:
• static imports
• tree-shaking
• работает в браузере
• анализ на этапе компиляции

CommonJS
module.exports = sum;
const sum = require("./sum");

Особенности:
• dynamic
• используется в Node.js
• выполнение во время выполнения

Когда что
• старые проекты — CJS
• новые — ESM

________________________________________
9.10. Destructuring, Spread, Rest и современные операторы

Destructuring
const { name, age } = user;
const [a, b] = arr;

С дефолтами
const { role = "user" } = data;

Spread / Rest
const arr2 = [...arr1];
function sum(...nums) {
  return nums.reduce((a, b) => a + b);
}

Операторы и паттерны
• Optional chaining ?.
• Nullish coalescing ??
• Logical assignment ||= &&= ??=

user?.profile?.email ?? "no email";

________________________________________
Вопросы на собеседовании

1. Как определяется this?
this определяется в момент вызова по 5 правилам: метод, обычный вызов, явная привязка, конструктор, стрелка.

2. Чем стрелочная функция отличается от обычной?
У стрелок нет собственного this, arguments, super, new.target, нельзя использовать как конструктор.

3. Чем отличаются call, apply и bind?
• call — вызывает функцию сразу, аргументы через запятую
• apply — вызывает функцию сразу, аргументы массивом
• bind — создаёт новую функцию с привязанным контекстом

4. Можно ли использовать стрелочную функцию как конструктор?
Нет. У стрелки нет прототипа и new.target.

5. Как избежать потери контекста в callback'ах?
• bind
• стрелочные поля класса
• wrapper-функция

6. Почему this в методе объекта может стать undefined?
Потому что метод был вызван без объекта слева (потеря контекста).

7. Что такое замыкание?
Функция запоминает внешние переменные, даже если внешняя функция завершена. Это ссылка на Lexical Environment, а не копия значения.

8. Где применяются замыкания?
Инкапсуляция состояния, фабрики функций, мемоизация, обработчики событий, приватность данных.

9. Разница между переменной в замыкании и копией значения?
Замыкание хранит ссылку, не копирует значение.

10. Почему var в цикле вызывает проблему при замыканиях?
Потому что var имеет function scope, и для всех итераций существует одна переменная.

11. Что такое каррирование?
Преобразование функции с множеством аргументов в цепочку функций по одному аргументу.

12. Как работает прототипная цепочка?
Поиск свойства идёт от объекта → его prototype → prototype prototype → null.

13. Классы в JS — это настоящий OOP?
Нет, это синтаксический сахар над прототипами. Под капотом — функции-конструкторы и prototype.

14. В чём разница ES Modules и CommonJS?
ES Modules — static imports, tree-shaking, работает в браузере. CommonJS — dynamic, используется в Node.js.

15. Что такое destructuring?
Извлечение значений из объектов и массивов в отдельные переменные.

16. Что делают spread и rest?
Spread — разворачивает массив/объект. Rest — собирает аргументы в массив.

Key Takeaways (краткое резюме)
• this определяется в момент вызова.
• Способы вызова: метод, обычный вызов, явная привязка, конструктор, стрелка.
• call/apply — вызов; bind — создание новой функции.
• Стрелочные функции не имеют своего this и arguments.
• Потеря контекста — самая частая ошибка начинающих.
• Методы класса нужно биндить или делать стрелочными.
• Замыкания — это ссылки на лексическое окружение, а не копии значений.
• var ломает замыкания в циклах — let исправляет это.
• Функции высшего порядка — сердце функционального подхода.
• Каррирование делает код более гибким и модульным.
• Прототипная модель — основа объектной модели JavaScript.
• Классы — синтаксический сахар над прототипами.
• ES Modules предпочтительнее CommonJS для новых проектов.

________________________________________

Часть III. JavaScript: фундамент, механика, архитектура
Глава 10. Работа с DOM

DOM — это мост между JavaScript и визуальным представлением страницы. Ошибки в работе с DOM напрямую приводят к проблемам с производительностью, багам и «тормозам» интерфейса — поэтому на собеседованиях эту тему проверяют особенно тщательно.

________________________________________
10.1. Навигация и поиск элементов

DOM — это дерево узлов.

Основные методы поиска

По id
document.getElementById("app");

По селекторам (рекомендуется)
document.querySelector(".card");
document.querySelectorAll(".card");

querySelectorAll возвращает NodeList, а не массив.

HTMLCollection vs NodeList

Коллекция	Живая	Тип
HTMLCollection	да	элементы
NodeList	нет	узлы

HTMLCollection — живая коллекция, обновляется при изменении DOM.
NodeList — статичная коллекция (обычно), содержит узлы.

________________________________________
10.2. Манипуляции DOM

Создание элементов
const div = document.createElement("div");
div.textContent = "Hello";

Вставка
parent.append(div);    // в конец
parent.prepend(div);   // в начало
parent.before(div);    // перед элементом
parent.after(div);     // после элемента

Удаление
div.remove();

Изменение классов
el.classList.add("active");
el.classList.remove("active");
el.classList.toggle("open");
el.classList.contains("active"); // проверка

innerHTML vs textContent

Свойство	Особенность
innerHTML	парсит HTML (опасно при XSS)
textContent	безопасный текст (не парсит HTML)

Важно: innerHTML может быть уязвим к XSS-атакам, если вставляются пользовательские данные.

________________________________________
10.3. События и делегирование

Добавление обработчика
button.addEventListener("click", handler);

Удаление обработчика
button.removeEventListener("click", handler);

Фазы событий
1. Capturing (погружение) — от корня к целевому элементу
2. Target — на целевом элементе
3. Bubbling (всплытие) — от целевого элемента к корню

По умолчанию используется bubbling.

Обработка на стадии capturing:
element.addEventListener("click", handler, true);

Делегирование
Один обработчик на родителе вместо множества на детях.

list.addEventListener("click", (e) => {
  if (e.target.matches("li")) {
    console.log(e.target.textContent);
  }
});

Почему это важно?
• меньше обработчиков
• динамические элементы (добавленные позже тоже работают)
• лучшая производительность
• меньше потребление памяти

Остановка всплытия
e.stopPropagation(); // останавливает всплытие
e.preventDefault();  // предотвращает стандартное поведение

________________________________________
10.4. Производительность DOM

DOM — медленный по сравнению с JS.

Частые ошибки
• частые чтения layout (offsetHeight, getBoundingClientRect)
• вставка элементов по одному
• синхронные изменения стилей
• layout thrashing (чередование чтения и записи layout-свойств)

Оптимизация

DocumentFragment
const fragment = document.createDocumentFragment();

items.forEach(item => {
  fragment.append(createNode(item));
});

container.append(fragment);
Одна операция вместо множества — значительно быстрее.

Batch updates
el.style.display = "none";
// все изменения
el.style.display = "";

Изменения группируются, браузер делает один reflow вместо множества.

Избегание layout thrashing
Плохо:
for (let i = 0; i < 1000; i++) {
  element.style.left = i + "px";
  console.log(element.offsetLeft); // провоцирует reflow
}

Хорошо:
let left = 0;
for (let i = 0; i < 1000; i++) {
  left += 1;
}
element.style.left = left + "px";

Порядок: сначала все чтения, потом все записи.

________________________________________
10.5. Observer API

IntersectionObserver
Используется для:
• lazy-loading изображений
• бесконечной прокрутки
• отслеживания видимости элементов

const observer = new IntersectionObserver(entries => {
  if (entries[0].isIntersecting) {
    loadMore();
  }
});

observer.observe(element);

Lazy-loading изображений
const images = document.querySelectorAll("img[data-src]");

const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src;
      observer.unobserve(entry.target);
    }
  });
});

images.forEach(img => observer.observe(img));

MutationObserver
Отслеживает изменения DOM.

const observer = new MutationObserver(callback);
observer.observe(target, { 
  childList: true,
  attributes: true,
  subtree: true
});

Используется для:
• отслеживания изменений структуры
• отладки
• реактивных систем

ResizeObserver
Отслеживает изменения размеров элементов.

const observer = new ResizeObserver(entries => {
  entries.forEach(entry => {
    console.log(entry.contentRect.width);
  });
});

observer.observe(element);

________________________________________
Вопросы на собеседовании

1. Что такое DOM?
Document Object Model — объектное представление HTML-документа в виде дерева узлов.

2. Разница между NodeList и HTMLCollection?
HTMLCollection — живая коллекция элементов, обновляется при изменении DOM.
NodeList — обычно статичная коллекция узлов.

3. innerHTML vs textContent?
innerHTML парсит HTML (опасно при XSS), textContent — безопасный текст.

4. Что такое всплытие событий?
Механизм, при котором событие распространяется от целевого элемента вверх по дереву DOM.

5. Зачем нужно делегирование?
Один обработчик на родителе вместо множества на детях. Работает с динамическими элементами, лучше производительность.

6. Почему DOM-операции дорогие?
DOM находится в отдельном процессе, каждое обращение требует IPC. Операции с DOM вызывают reflow/repaint.

7. Что такое layout thrashing?
Чередование чтения и записи layout-свойств, вызывающее множественные reflow. Решение: группировать чтения и записи.

8. Для чего нужен IntersectionObserver?
Отслеживание видимости элементов: lazy-loading, бесконечная прокрутка, аналитика.

9. MutationObserver vs IntersectionObserver?
MutationObserver отслеживает изменения DOM. IntersectionObserver отслеживает видимость элементов.

10. Как оптимизировать работу с DOM?
• использовать DocumentFragment
• группировать изменения (batch updates)
• избегать layout thrashing
• использовать делегирование событий
• минимизировать количество DOM-операций

Key Takeaways (краткое резюме)
• DOM — медленный, минимизируй обращения к нему.
• Делегирование событий — лучшая практика для динамических элементов.
• DocumentFragment ускоряет массовую вставку элементов.
• Layout thrashing — частая причина проблем производительности.
• IntersectionObserver — современный способ lazy-loading.
• MutationObserver отслеживает изменения DOM.
• Порядок операций: сначала все чтения, потом все записи.
• innerHTML опасен при работе с пользовательскими данными.

________________________________________

Часть III. JavaScript: фундамент, механика, архитектура
Глава 11. Асинхронность

Асинхронность — одна из самых критичных тем для фронтенд-разработчика. Большинство реальных багов связано не с синтаксисом, а с непониманием порядка выполнения кода.

На собеседованиях почти всегда:
• просят объяснить Event Loop,
• дают код «угадай вывод»,
• спрашивают про промисы и async/await.

Эта глава объясняет:
1. Event Loop и модель выполнения
2. Промисы
3. async/await
4. Web APIs
5. Обработка ошибок
6. Частые ошибки и паттерны

________________________________________
11.1. Event Loop: как выполняется JavaScript

JavaScript — однопоточный, но не блокирующий. Это возможно благодаря Event Loop.

Основные сущности
1. Call Stack — стек вызовов функций
2. Web APIs — браузерные API (setTimeout, fetch, DOM и т.д.)
3. Task Queue (macrotasks) — очередь макрозадач
4. Microtask Queue — очередь микрозадач
5. Event Loop — механизм, переносящий задачи из очередей в стек

Схема выполнения
1. Выполняется синхронный код (попадает в Call Stack)
2. Асинхронные операции уходят в Web APIs
3. Callback попадает в очередь (macrotask или microtask)
4. Event Loop переносит задачи в Call Stack (когда стек пуст)

Macrotasks
• setTimeout
• setInterval
• setImmediate
• UI events (клики, скролл)
• I/O операции

Microtasks
• Promise.then
• Promise.catch
• Promise.finally
• queueMicrotask
• MutationObserver

⚠️ Важно: Microtasks выполняются до следующей macrotask.

Пример
console.log(1);

setTimeout(() => console.log(2), 0);

Promise.resolve().then(() => console.log(3));

console.log(4);

Вывод: 1 4 3 2

Почему?
1. Синхронный код: 1, 4
2. Promise.then — microtask, выполняется сразу после синхронного кода
3. setTimeout — macrotask, выполняется после всех microtasks

Порядок выполнения:
1. Синхронный код
2. Все microtasks
3. Одна macrotask
4. Снова все microtasks
5. Следующая macrotask
6. И так далее

Различия Event Loop в браузере и Node.js

Браузер:
• Microtasks выполняются после каждой macrotask
• Promise.then и queueMicrotask имеют одинаковый приоритет
• Web APIs обрабатываются браузером

Node.js:
• process.nextTick имеет приоритет над Promise.then
• Microtasks выполняются между фазами Event Loop
• Фазы: timers → pending callbacks → idle/prepare → poll → check → close callbacks
• libuv обрабатывает I/O операции

Важно: В Node.js process.nextTick выполняется раньше Promise.then, что может влиять на порядок выполнения асинхронного кода.

________________________________________
11.2. Промисы

Promise — объект, представляющий результат асинхронной операции.

Состояния
• pending — ожидание
• fulfilled — успешно выполнено
• rejected — отклонено

Создание
const p = new Promise((resolve, reject) => {
  // асинхронная операция
  if (success) {
    resolve(data);
  } else {
    reject(error);
  }
});

Цепочки
fetch(url)
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err))
  .finally(() => console.log("done"));

Почему then возвращает Promise?
Это позволяет строить цепочки. Каждый then возвращает новый Promise.

Promise.all
Ожидает выполнения всех промисов:
Promise.all([promise1, promise2, promise3])
  .then(results => {
    // все промисы выполнены
  })
  .catch(err => {
    // хотя бы один отклонён
  });

Promise.allSettled
Ждёт завершения всех, независимо от результата:
Promise.allSettled([promise1, promise2])
  .then(results => {
    // все завершены, есть статус каждого
  });

Promise.race
Возвращает результат первого завершившегося:
Promise.race([fastPromise, slowPromise])
  .then(result => {
    // результат первого
  });

________________________________________
11.3. async / await

Синтаксический сахар над промисами. Делает асинхронный код похожим на синхронный.

async function load() {
  try {
    const res = await fetch(url);
    const data = await res.json();
    return data;
  } catch (e) {
    console.error(e);
  }
}

Что происходит под капотом?
• функция всегда возвращает Promise
• await ставит выполнение «на паузу»
• фактически создаётся цепочка then
• ошибки обрабатываются через try/catch

Ошибка новичков
await fetch(url);
await fetch(url2);

Если запросы независимы — лучше:
await Promise.all([fetch(url), fetch(url2)]);

Параллельное выполнение независимых операций ускоряет код.

________________________________________
11.4. Web APIs

Timers
setTimeout(fn, 0);
Не означает «выполнится сразу». Минимальная задержка — 4ms (в браузере).

setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise"));
// promise выполнится раньше

setInterval
Повторяет выполнение функции:
const interval = setInterval(() => {
  console.log("tick");
}, 1000);

clearInterval(interval); // остановка

fetch
Современный API для HTTP-запросов:
fetch("/api")
  .then(r => r.json());

⚠️ Важно: Fetch не отклоняет промис при 4xx/5xx. Нужно проверять r.ok:
fetch("/api")
  .then(r => {
    if (!r.ok) throw new Error("HTTP error");
    return r.json();
  });

Web Workers
Запускают код в отдельном потоке. Используются для тяжёлых вычислений.

const worker = new Worker("worker.js");
worker.postMessage(data);
worker.onmessage = (e) => {
  console.log(e.data);
};

Ограничения:
• нет доступа к DOM
• нет доступа к window
• общение только через postMessage

Streams API
Используется для работы с потоками данных.

const reader = response.body.getReader();
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  // обработка value
}

Позволяет:
• обрабатывать большие файлы
• стримить видео
• экономить память

________________________________________
11.5. Обработка ошибок

В промисах
fetch(url)
  .then(data => {
    // обработка
  })
  .catch(err => {
    // обработка ошибки
  });

В async/await
async function load() {
  try {
    const data = await fetch(url);
    return data;
  } catch (err) {
    console.error(err);
    throw err; // пробрасываем дальше
  }
}

Глобальная обработка
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled promise rejection:', event.reason);
});

Частые ошибки в асинхронности
• забыли return в then
• не обработали ошибку
• смешали await и then
• гонки состояний (race conditions)
• параллельное выполнение независимых операций через await

Пример гонки состояний:
let counter = 0;

async function increment() {
  const current = counter;
  await delay(100);
  counter = current + 1;
}

increment();
increment();
// counter может быть 1 вместо 2

Решение: использовать атомарные операции или блокировки.

________________________________________
Вопросы на собеседовании

1. Как работает Event Loop?
Однопоточный механизм выполнения: синхронный код → microtasks → одна macrotask → снова microtasks → следующая macrotask.

2. Разница между macrotask и microtask?
Macrotasks — setTimeout, UI events. Microtasks — Promise.then, queueMicrotask. Microtasks выполняются до следующей macrotask.

3. Почему Promise.then выполняется раньше setTimeout?
Promise.then — microtask, setTimeout — macrotask. Microtasks имеют приоритет.

4. Что возвращает async-функция?
Всегда Promise. Даже если функция возвращает обычное значение, оно оборачивается в Promise.

5. Как правильно обрабатывать ошибки в async/await?
Через try/catch блок или .catch() на возвращаемом Promise.

6. Когда использовать Promise.all?
Когда нужно дождаться выполнения всех промисов. Все должны быть успешными.

7. Почему fetch не падает на 404?
Fetch отклоняет промис только при сетевых ошибках. HTTP-ошибки (4xx, 5xx) нужно проверять через r.ok.

8. Зачем нужны Web Workers?
Для тяжёлых вычислений в отдельном потоке, чтобы не блокировать основной поток и UI.

9. Что такое race condition?
Ситуация, когда результат зависит от порядка выполнения асинхронных операций.

10. Как избежать race conditions?
Использовать атомарные операции, блокировки, или правильную последовательность await.

Key Takeaways (краткое резюме)
• Event Loop управляет порядком выполнения асинхронного кода.
• Microtasks выполняются до следующей macrotask.
• Промисы — основа современной асинхронности в JS.
• async/await делает код читаемее, но под капотом — промисы.
• Promise.all для параллельного выполнения независимых операций.
• Fetch не отклоняет промис при HTTP-ошибках — нужно проверять r.ok.
• Web Workers для тяжёлых вычислений в отдельном потоке.
• Обработка ошибок обязательна в асинхронном коде.
• Race conditions — частая проблема в асинхронном коде.

________________________________________

Часть IV. Инфраструктура: сборка, тестирование, инструменты
Глава 12. NPM, package.json и зависимости проекта

Инфраструктура — это то, что отличает «код на ноутбуке» от продакшн-приложения. На уровне Middle от разработчика ожидают понимание того, как живёт проект, а не только как пишутся компоненты.

________________________________________
12.1. npm, yarn, pnpm

Все три инструмента решают одну задачу: управление зависимостями и скриптами проекта.

npm (Node Package Manager)
• стандарт де-факто
• идёт вместе с Node.js
• самый распространённый

npm install react
npm run build

yarn
Появился как альтернатива npm:
• быстрее (исторически)
• deterministic installs
• удобный CLI

yarn add react
yarn build

pnpm
Современный инструмент с фокусом на производительность и дисковое пространство.

Как работает pnpm?
• использует content-addressable storage
• зависимости хранятся один раз
• проекты используют ссылки (symlinks)

Плюсы:
• быстрее
• меньше места на диске
• меньше «phantom dependencies»

Когда что выбирать?
Сценарий	Инструмент
Стандартный проект	npm
Большие монорепозитории	pnpm
Legacy проекты	yarn

________________________________________
12.2. package.json: сердце проекта

package.json — это контракт проекта.

Основные поля
{
  "name": "app",
  "version": "1.0.0",
  "scripts": {},
  "dependencies": {},
  "devDependencies": {}
}

dependencies vs devDependencies

Тип	Для чего
dependencies	нужны в runtime
devDependencies	нужны только для разработки

Пример:
• react → dependencies
• webpack, jest → devDependencies

peerDependencies
Используются библиотеками:
"peerDependencies": {
  "react": ">=17"
}

Означает: «приложение должно предоставить эту зависимость». Это позволяет избежать дублирования зависимостей.

________________________________________
12.3. SemVer (Semantic Versioning)

Формат: MAJOR.MINOR.PATCH
Пример: 2.4.1
• MAJOR — breaking changes
• MINOR — backward compatible features
• PATCH — bugfix

Символы версий
"react": "^18.2.0"
• ^ — разрешает обновление MINOR и PATCH
• ~ — только PATCH
• без символа — строго указанная версия

Почему это важно
Неправильная версия = сломанная сборка. SemVer помогает управлять совместимостью.

________________________________________
12.4. Lock-файлы

• package-lock.json (npm)
• yarn.lock (yarn)
• pnpm-lock.yaml (pnpm)

Зачем они нужны?
• фиксируют дерево зависимостей
• гарантируют одинаковую сборку на всех машинах
• обязательны в репозитории

⚠️ Удаление lock-файла — частая причина багов. Всегда коммитьте lock-файлы.

________________________________________
12.5. Скрипты и lifecycle hooks

Скрипты
"scripts": {
  "dev": "vite",
  "build": "vite build",
  "test": "jest"
}

Запуск:
npm run build

Lifecycle hooks
npm автоматически запускает:
• preinstall — перед установкой
• postinstall — после установки
• prebuild — перед сборкой
• postbuild — после сборки

Используется для:
• генерации файлов
• подготовки окружения
• запуска тестов

Частые проблемы с зависимостями
• конфликт версий
• дублирование библиотек
• phantom dependencies (зависимости, доступные без явного объявления)
• разные версии Node

________________________________________
Вопросы на собеседовании

1. Чем npm отличается от yarn и pnpm?
npm — стандарт, yarn — быстрее исторически, pnpm — использует symlinks, экономит место.

2. Что такое package.json?
Контракт проекта: зависимости, скрипты, метаданные.

3. Разница между dependencies и devDependencies?
dependencies нужны в runtime, devDependencies — только для разработки.

4. Зачем нужны peerDependencies?
Библиотеки указывают, какие зависимости должно предоставить приложение. Избегает дублирования.

5. Что такое SemVer?
Semantic Versioning — система версионирования: MAJOR.MINOR.PATCH.

6. Что означает ^ в версии пакета?
Разрешает обновление MINOR и PATCH версий, но не MAJOR.

7. Зачем нужен lock-файл?
Фиксирует точные версии зависимостей, гарантирует одинаковую сборку.

8. Почему нельзя коммитить без lock-файла?
Разные разработчики могут получить разные версии зависимостей, что приведёт к багам.

Key Takeaways (краткое резюме)
• npm/yarn/pnpm решают одну задачу, но по-разному.
• package.json — контракт проекта.
• dependencies vs devDependencies — важное разделение.
• SemVer управляет совместимостью версий.
• Lock-файлы обязательны для стабильности сборки.
• Lifecycle hooks автоматизируют процессы.
• peerDependencies предотвращают дублирование зависимостей.

________________________________________

Часть IV. Инфраструктура: сборка, тестирование, инструменты
Глава 13. Сборщики

Сборщик — это инструмент, который превращает исходный код разработчика в оптимизированные файлы для браузера.

На уровне Middle от разработчика ожидают:
• понимание архитектуры сборки;
• умение читать конфигурацию;
• осознанный выбор инструментов.

________________________________________
13.1. Webpack: архитектура и принципы

Webpack — модульный бандлер. Он строит граф зависимостей, начиная с entry point.

Базовая концепция
1. Entry — точка входа
2. Graph — граф модулей
3. Loaders — обработка файлов
4. Plugins — расширение логики
5. Output — результат сборки

Минимальная конфигурация
module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "bundle.js",
    path: __dirname + "/dist"
  }
};

Loaders
Loaders обрабатывают не-JS файлы.

module: {
  rules: [
    {
      test: /\.css$/,
      use: ["style-loader", "css-loader"]
    }
  ]
}

Работают справа налево: сначала css-loader, потом style-loader.

Plugins
Плагины влияют на процесс сборки целиком.

new HtmlWebpackPlugin({
  template: "./src/index.html"
});

Разница между loader и plugin:
• Loader — трансформирует отдельные файлы
• Plugin — работает на уровне всего процесса сборки

________________________________________
13.2. Vite и современная разработка

Vite — инструмент нового поколения.

Почему Vite быстрее?

Dev mode:
• использует native ES Modules
• без бандлинга
• сервер отдаёт файлы напрямую
• HMR (Hot Module Replacement) на уровне модулей

Build:
• использует Rollup для продакшн-сборки
• оптимизированная конфигурация из коробки

Сравнение Webpack vs Vite

Критерий	Webpack	Vite
Dev server	медленный (бандлинг)	быстрый (ESM)
Конфигурация	сложная	минимальная
Legacy поддержка	отлично	ограниченно
Современные проекты	избыточен	предпочтителен
HMR	медленный	мгновенный

Когда использовать Vite:
• новые проекты
• современные браузеры
• быстрая разработка

Когда использовать Webpack:
• legacy проекты
• сложные требования к сборке
• специфичные плагины

________________________________________
13.3. Babel: транспиляция

Babel — транспилятор JS. Превращает современный JavaScript в код, работающий в старых браузерах.

Зачем он нужен?
Позволяет писать:
const sum = (a, b) => a + b;

И получать код, работающий в старых браузерах.

Presets
"presets": ["@babel/preset-env"]

@babel/preset-env автоматически определяет, какие трансформации нужны на основе целевых браузеров.

Polyfills
Babel не добавляет API, только синтаксис. Для API используется core-js.

import "core-js/stable";

Добавляет недостающие методы:
• Promise
• Array.prototype.includes
• Object.assign

Зачем нужны polyfills?
Без них код может упасть в старом браузере из-за отсутствующих API.

________________________________________
13.4. Tree Shaking

Удаление неиспользуемого кода.

Работает только с:
• ES Modules
• static imports

Почему CommonJS мешает tree-shaking?
CommonJS — динамический, импорты определяются во время выполнения. Tree-shaking требует статического анализа.

Пример:
// Используется только sum
import { sum, multiply } from './math';
// multiply будет удалён из бандла

________________________________________
13.5. Code Splitting

Разделение кода на чанки для оптимизации загрузки.

Динамический импорт:
const Page = lazy(() => import("./Page"));

Route-based splitting:
Каждый роут — отдельный чанк.

Component-based splitting:
Тяжёлые компоненты загружаются по требованию.

Преимущества:
• меньше начальный бандл
• быстрее загрузка
• лучший Core Web Vitals

________________________________________
Вопросы на собеседовании

1. Что делает Webpack?
Модульный бандлер, строит граф зависимостей и объединяет модули в бандлы.

2. Разница между loader и plugin?
Loader трансформирует отдельные файлы, plugin работает на уровне всего процесса сборки.

3. Как работает Vite?
В dev использует native ES Modules без бандлинга, в build — Rollup.

4. Почему Vite быстрее Webpack в dev?
Не делает бандлинг, отдаёт файлы напрямую через ES Modules.

5. Зачем нужен Babel?
Транспиляция современного JS в код, работающий в старых браузерах.

6. Чем транспиляция отличается от полифиллинга?
Транспиляция — синтаксис (стрелки → функции). Полифиллинг — API (Promise, Array.includes).

7. Что такое tree-shaking?
Удаление неиспользуемого кода из бандла.

8. Почему CommonJS мешает tree-shaking?
CommonJS динамический, tree-shaking требует статического анализа (ES Modules).

9. Что такое code splitting?
Разделение кода на чанки для оптимизации загрузки.

Key Takeaways (краткое резюме)
• Webpack — мощный, но сложный бандлер.
• Vite — современная альтернатива с быстрым dev-сервером.
• Babel транспилирует синтаксис, polyfills добавляют API.
• Tree-shaking работает только с ES Modules.
• Code splitting улучшает производительность загрузки.
• Loaders обрабатывают файлы, plugins расширяют процесс сборки.
• Выбор инструмента зависит от требований проекта.

________________________________________

Часть IV. Инфраструктура: сборка, тестирование, инструменты
Глава 14. Тестирование

Тестирование — это не «дополнительная опция», а часть инженерной культуры. На уровне Middle и выше от фронтенд-разработчика ожидают понимание зачем, что и как тестировать, а не только умение написать тест.

На собеседованиях по тестированию проверяют:
• архитектурное мышление;
• умение выбирать уровень теста;
• понимание trade-off'ов.

________________________________________
14.1. Виды тестов: Unit, Integration, E2E

Unit-тесты
Тестируют одну функцию или модуль в изоляции.

function sum(a, b) {
  return a + b;
}

expect(sum(2, 3)).toBe(5);

Характеристики:
• быстрые
• дешёвые
• легко писать
• изолированы от внешних зависимостей

⚠️ Не ловят ошибки интеграции. Тестируют только логику в изоляции.

Integration-тесты
Тестируют взаимодействие модулей.

Пример:
• компонент + API
• форма + валидация
• несколько компонентов вместе

Характеристики:
• медленнее unit-тестов
• проверяют взаимодействие
• требуют моков/стабов

E2E (End-to-End)
Тестируют пользовательский сценарий целиком.

Пример:
• открыть страницу
• ввести данные
• нажать кнопку
• получить результат

Самые дорогие, но самые надёжные. Проверяют реальное поведение приложения.

Пирамида тестирования
        E2E (мало)
    Integration (средне)
Unit Unit Unit (много)

Принцип: много быстрых unit-тестов, меньше integration, минимум E2E.

________________________________________
14.2. Jest: тестирование логики

Jest — стандарт де-факто для unit-тестов во фронтенде.

Базовый тест
test("sum works", () => {
  expect(sum(1, 2)).toBe(3);
});

describe("Math utils", () => {
  test("sum adds numbers", () => {
    expect(sum(2, 3)).toBe(5);
  });
  
  test("sum handles negatives", () => {
    expect(sum(-1, 1)).toBe(0);
  });
});

Matchers
• toBe — строгое сравнение (===)
• toEqual — глубокое сравнение объектов
• toContain — проверка наличия в массиве
• toThrow — проверка выброса ошибки
• toHaveBeenCalled — проверка вызова функции
• toMatch — сравнение с регулярным выражением

Mock-функции
const fn = jest.fn();
fn(1);
expect(fn).toHaveBeenCalledWith(1);
expect(fn).toHaveBeenCalledTimes(1);

Mock модулей
jest.mock("./api");

const api = require("./api");
api.fetchData = jest.fn().mockResolvedValue({ data: "test" });

Используется для изоляции тестов от внешних зависимостей.

________________________________________
14.3. Testing Library: тестирование компонентов

Testing Library тестирует не реализацию, а поведение.

Принцип: «Тестируй так, как пользуется пользователь»

Пример (React)
import { render, screen } from '@testing-library/react';
import Button from './Button';

test('renders button with text', () => {
  render(<Button>Save</Button>);
  const button = screen.getByRole('button', { name: /save/i });
  expect(button).toBeInTheDocument();
});

Основные селекторы (в порядке предпочтения)
1. getByRole — по роли элемента (предпочтительно)
2. getByLabelText — по label
3. getByText — по тексту
4. getByPlaceholderText — по placeholder
5. getByTestId — крайний случай (когда нет других способов)

⚠️ getByTestId — крайний случай. Используйте только если нет семантических способов.

Почему не shallow?
Shallow-тесты (Enzyme):
• знают о внутренней структуре
• ломаются при рефакторинге
• тестируют реализацию, а не поведение

Testing Library поощряет тестирование через доступность и семантику.

Тестирование событий
import { fireEvent } from '@testing-library/react';

test('calls onClick when clicked', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);
  
  fireEvent.click(screen.getByRole('button'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});

Асинхронные тесты
test('loads data', async () => {
  render(<DataComponent />);
  
  await waitFor(() => {
    expect(screen.getByText('Loaded')).toBeInTheDocument();
  });
});

________________________________________
14.4. Cypress и Playwright

Инструменты для E2E-тестирования.

Cypress
• работает внутри браузера
• удобен для дебага
• проще старт
• хорошая документация

cy.visit("/");
cy.get("button").click();
cy.contains("Success").should("be.visible");

Особенности:
• работает в реальном браузере
• может тестировать сетевые запросы
• удобный UI для отладки

Playwright
• multi-browser (Chromium, Firefox, WebKit)
• быстрее
• лучше для CI
• поддерживает мобильные устройства

await page.goto("/");
await page.click("button");
await expect(page.locator("text=Success")).toBeVisible();

Cypress vs Playwright

Критерий	Cypress	Playwright
Простота	выше	ниже
CI/CD	средне	отлично
Multi-browser	нет	да
Mobile	ограничено	хорошо
Скорость	медленнее	быстрее
Отладка	отлично	хорошо

Когда использовать Cypress:
• быстрый старт
• отладка важнее скорости
• один браузер достаточен

Когда использовать Playwright:
• нужна поддержка нескольких браузеров
• важна скорость в CI
• нужна поддержка мобильных устройств

________________________________________
14.5. Mocks, Stubs, Spies

Mock
Полностью заменяет зависимость фиктивной реализацией.

jest.mock('./api', () => ({
  fetchData: jest.fn()
}));

Stub
Возвращает заранее определённые данные.

const api = {
  fetchData: jest.fn().mockResolvedValue({ data: 'test' })
};

Spy
Следит за вызовами реальной функции, не заменяя её.

jest.spyOn(api, "fetchData");
api.fetchData();
expect(api.fetchData).toHaveBeenCalled();

Когда что использовать:
• Mock — когда нужно полностью изолировать тест
• Stub — когда нужны предсказуемые данные
• Spy — когда нужно проверить вызов, но сохранить реальное поведение

________________________________________
14.6. Частые ошибки в тестировании

• Тестируют реализацию вместо поведения
• Слишком много E2E-тестов (должно быть мало)
• Отсутствие тестовых данных (fixtures)
• Flaky-тесты (нестабильные, падают случайно)
• Тестирование внутренних деталей компонента
• Игнорирование edge cases
• Отсутствие cleanup после тестов

Flaky-тесты
Тесты, которые иногда проходят, иногда падают. Причины:
• таймеры без моков
• асинхронные операции без ожидания
• глобальное состояние
• зависимости от времени/даты

Решение: использовать моки, правильные ожидания, изоляцию тестов.

________________________________________
Вопросы на собеседовании

1. Разница между unit, integration и E2E?
• Unit — одна функция/модуль в изоляции (быстро, дешево)
• Integration — взаимодействие модулей (медленнее)
• E2E — полный пользовательский сценарий (медленно, дорого, но надёжно)

2. Что такое пирамида тестирования?
Много unit-тестов (основание), меньше integration, минимум E2E (вершина).

3. Зачем нужны mock'и?
Изоляция тестов от внешних зависимостей, предсказуемость, скорость.

4. Чем Testing Library отличается от Enzyme?
Testing Library тестирует поведение через доступность. Enzyme тестирует реализацию через shallow rendering.

5. Когда не стоит писать unit-тесты?
Для тривиального кода без логики, для UI без поведения, когда тест дороже поддержки.

6. Cypress vs Playwright?
Cypress проще, лучше для отладки. Playwright быстрее, поддерживает несколько браузеров, лучше для CI.

7. Что такое flaky-тесты?
Нестабильные тесты, которые падают случайно. Проблема для CI/CD.

8. Почему E2E-тесты дорогие?
Требуют полного окружения, медленные, сложнее поддерживать, могут быть нестабильными.

9. Что такое test coverage?
Процент кода, покрытого тестами. Важная метрика, но не самоцель.

10. Как организовать тесты в проекте?
Рядом с кодом (__tests__) или в отдельной папке (tests/), группировать по фичам.

Key Takeaways (краткое резюме)
• Пирамида тестирования: много unit, меньше integration, минимум E2E.
• Jest — стандарт для unit-тестов.
• Testing Library тестирует поведение, а не реализацию.
• Cypress и Playwright — инструменты для E2E.
• Mocks изолируют тесты от зависимостей.
• Flaky-тесты — проблема, которую нужно решать.
• Тестирование — часть инженерной культуры, не опция.
• Выбор уровня теста зависит от того, что нужно проверить.

________________________________________

Часть V. TypeScript: строгая типизация для фронтенда
Глава 15. Основы TypeScript

TypeScript — это не просто «JavaScript с типами». Это инструмент проектирования API, компонентов и архитектуры, который позволяет ловить ошибки до запуска кода.

На собеседованиях TypeScript — маркер зрелости разработчика. Понимание типизации показывает способность проектировать надёжные системы.

________________________________________
15.1. Типы данных, union и intersection

Базовые типы
let count: number = 10;
let title: string = "Hello";
let isOpen: boolean = true;
let data: null = null;
let value: undefined = undefined;

Массивы
let ids: number[] = [1, 2, 3];
let names: Array<string> = ["Alice", "Bob"];

Объекты
let user: { name: string; age: number } = {
  name: "Alice",
  age: 30
};

Union types
Позволяет ограничить набор допустимых значений.

type Status = "loading" | "success" | "error";
type ID = string | number;

function processStatus(status: Status) {
  // TypeScript знает все возможные значения
}

Intersection types
Объединяет несколько типов.

type User = { name: string };
type Admin = { role: string };

type AdminUser = User & Admin;
// { name: string; role: string }

________________________________________
15.2. Интерфейсы и типы

Interface
interface User {
  id: number;
  name: string;
  email?: string; // опциональное поле
}

Расширение интерфейса:
interface Admin extends User {
  role: string;
}

Type
type User = {
  id: number;
  name: string;
};

Различия

Критерий	interface	type
Расширяемость	да (extends)	нет
Union	нет	да
Intersection	да	да
Декларации	можно расширять	нельзя

Практическое правило
• interface — для публичных API, объектов, классов
• type — для сложных композиций, union, утилитарных типов

Примеры:
interface ButtonProps {
  title: string;
  onClick: () => void;
}

type Theme = "light" | "dark";
type ButtonVariant = "primary" | "secondary";

________________________________________
15.3. Кортежи, enum и literal types

Кортежи
type Point = [number, number];
type UserData = [string, number, boolean];

const point: Point = [10, 20];

Enum
enum Role {
  User,
  Admin
}

⚠️ Enum увеличивает размер бандла.

Часто лучше использовать union types:
type Role = "user" | "admin";

Literal types
let direction: "left" | "right" = "left";
let size: 1 | 2 | 3 = 2;

Позволяют создавать строго типизированные значения.

________________________________________
15.4. unknown vs any vs never

any
Отключает типизацию полностью. Использовать крайне редко.

let x: any = 5;
x = "string"; // OK, но теряем безопасность типов

unknown
Безопасная альтернатива any. Требует проверки перед использованием.

let x: unknown = getData();

if (typeof x === "string") {
  console.log(x.toUpperCase()); // теперь безопасно
}

never
Функция никогда не возвращает значение.

function fail(): never {
  throw new Error();
}

function infiniteLoop(): never {
  while (true) {}
}

Используется для:
• функций, которые всегда выбрасывают ошибку
• exhaustive checks в switch

________________________________________
15.5. Type inference

TypeScript умеет выводить типы автоматически:

const count = 10; // number
const name = "Alice"; // string
const arr = [1, 2, 3]; // number[]

Явная типизация нужна когда:
• тип не может быть выведен
• нужно ограничить тип
• публичное API

function sum(a: number, b: number): number {
  return a + b;
}

________________________________________
15.6. Strict mode

"strict": true

Флаг 'strict': true включает следующие проверки:
• strictNullChecks — null и undefined не присваиваются автоматически
• noImplicitAny — ошибка при неявном any
• strictFunctionTypes — строгая проверка типов функций
• strictPropertyInitialization — поля класса должны быть инициализированы
• strictBindCallApply — строгая проверка bind/call/apply
• noImplicitThis — ошибка при неявном this
• alwaysStrict — всегда в strict mode

Можно включать флаги по отдельности для постепенной миграции существующих проектов.

Рекомендуется всегда включать strict mode для новых проектов.

________________________________________
Вопросы на собеседовании

1. Зачем нужен TypeScript?
Ловит ошибки до запуска, улучшает автодополнение, документирует код, упрощает рефакторинг.

2. Разница между interface и type?
interface можно расширять, лучше для объектов. type поддерживает union, лучше для композиций.

3. Что такое union и intersection?
Union (|) — одно из значений. Intersection (&) — объединение всех свойств.

4. Почему any — плохо?
Отключает проверку типов, теряется безопасность и автодополнение.

5. Когда использовать unknown?
Когда тип неизвестен, но нужно проверить перед использованием. Безопасная альтернатива any.

6. Что такое never?
Тип для значений, которые никогда не появятся. Функции, которые всегда выбрасывают ошибку.

7. Что такое strict mode?
Набор строгих проверок TypeScript для максимальной типобезопасности.

8. Что такое type inference?
Автоматическое определение типов TypeScript на основе значений.

Key Takeaways (краткое резюме)
• TypeScript — инструмент проектирования, а не просто аннотации.
• interface для объектов, type для композиций.
• Union types ограничивают набор значений.
• unknown безопаснее any.
• never для функций, которые никогда не возвращают значение.
• Strict mode обязателен для новых проектов.
• Type inference упрощает код, но явная типизация важна для API.

________________________________________

Часть V. TypeScript: строгая типизация для фронтенда
Глава 16. Продвинутый TypeScript

Эта глава — граница между «я умею писать на TS» и «я проектирую на TS». На уровне Middle+ TypeScript используется как язык описания контрактов и бизнес-логики, а не просто аннотаций.

________________________________________
16.1. Дженерики (Generics)

Дженерики позволяют писать переиспользуемый и типобезопасный код.

Простейший пример
function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(42);
const str = identity<string>("hello");

TypeScript может вывести тип:
const num = identity(42); // автоматически number

Ограничения (extends)
function logLength<T extends { length: number }>(value: T) {
  console.log(value.length);
}

logLength("string"); // OK
logLength([1, 2, 3]); // OK
logLength(42); // Error

Дженерики в интерфейсах
interface ApiResponse<T> {
  data: T;
  error?: string;
  status: number;
}

const userResponse: ApiResponse<User> = {
  data: { id: 1, name: "Alice" },
  status: 200
};

Дженерики в классах
class Repository<T> {
  private items: T[] = [];

  add(item: T) {
    this.items.push(item);
  }

  find(id: number): T | undefined {
    return this.items.find(item => (item as any).id === id);
  }
}

const userRepo = new Repository<User>();

Множественные дженерики
function map<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3];
const strings = map(numbers, n => n.toString()); // string[]

________________________________________
16.2. Утилитарные типы

TypeScript предоставляет готовые утилиты для работы с типами.

Pick
Выбирает указанные свойства из типа.

type User = { id: number; name: string; email: string; role: string };
type UserPreview = Pick<User, "id" | "name">;
// { id: number; name: string }

Omit
Исключает указанные свойства.

type UserWithoutId = Omit<User, "id">;
// { name: string; email: string; role: string }

Partial
Делает все свойства опциональными.

type UserUpdate = Partial<User>;
// { id?: number; name?: string; ... }

Required
Делает все свойства обязательными.

type RequiredUser = Required<Partial<User>>;
// все поля обязательны

Readonly
Делает все свойства только для чтения.

type ReadonlyUser = Readonly<User>;
// все поля readonly

Record
Создаёт тип объекта с заданными ключами и значениями.

type UserRoles = Record<string, "admin" | "user">;
// { [key: string]: "admin" | "user" }

Exclude / Extract
Exclude — исключает типы из union.
Extract — извлекает типы из union.

type T = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type U = Extract<"a" | "b" | "c", "a" | "b">; // "a" | "b"

NonNullable
Удаляет null и undefined из типа.

type T = NonNullable<string | null | undefined>; // string

ReturnType / Parameters
Получает тип возвращаемого значения и параметров функции.

type Fn = (a: number, b: string) => boolean;
type R = ReturnType<Fn>; // boolean
type P = Parameters<Fn>; // [number, string]

________________________________________
16.3. Классы и модификаторы доступа

Модификаторы
• public (по умолчанию) — доступ везде
• private — доступ только внутри класса
• protected — доступ в классе и наследниках

class User {
  public name: string;
  private id: number;
  protected role: string;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
    this.role = "user";
  }
}

Readonly-поля
class Config {
  readonly env = "prod";
  readonly apiUrl = "https://api.example.com";
}

Приватные поля (#)
Современный способ (ES2022):

class User {
  #password: string;

  setPassword(pwd: string) {
    this.#password = pwd;
  }
}

________________________________________
16.4. Discriminated Unions

Один из самых мощных паттернов TS. Позволяет TypeScript точно определять тип на основе дискриминанта.

Пример
type Action =
  | { type: "ADD"; payload: number }
  | { type: "REMOVE"; payload: number }
  | { type: "RESET" };

Использование
function reducer(action: Action) {
  switch (action.type) {
    case "ADD":
      return action.payload; // TypeScript знает, что payload есть
    case "REMOVE":
      return -action.payload;
    case "RESET":
      return 0;
    default:
      const _exhaustive: never = action; // проверка полноты
      return _exhaustive;
  }
}

TypeScript гарантирует, что все кейсы обработаны.

________________________________________
16.5. Type Guards

Позволяют сузить тип в условных блоках.

typeof
if (typeof x === "string") {
  // здесь x — string
}

instanceof
if (obj instanceof User) {
  // здесь obj — User
}

in
if ("role" in user) {
  // user имеет свойство role
}

Пользовательский guard
function isAdmin(user: User | Admin): user is Admin {
  return "role" in user && user.role === "admin";
}

if (isAdmin(user)) {
  // здесь user — Admin
}

________________________________________
16.6. Декораторы

Декораторы — экспериментальная возможность TypeScript.

function Log(target: any) {
  console.log(target);
}

@Log
class User {}

Используются в:
• Angular
• NestJS

Требуют включения в tsconfig:
"experimentalDecorators": true

________________________________________
16.7. tsconfig: продвинутые настройки

Важные флаги
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "exactOptionalPropertyTypes": true,
    "target": "ES2020",
    "lib": ["ES2020", "DOM"],
    "module": "ESNext",
    "moduleResolution": "bundler"
  }
}

target и lib
Определяют:
• версию JavaScript на выходе
• доступные API (DOM, ES2020 и т.д.)

moduleResolution
• "node" — для Node.js
• "bundler" — для современных бандлеров
• "classic" — устаревший

Частые ошибки
• overengineering типов
• any в продакшне
• игнорирование strict
• сложные conditional-типы без необходимости

________________________________________
Вопросы на собеседовании

1. Что такое дженерики?
Механизм создания переиспользуемых типобезопасных функций/классов с параметризованными типами.

2. Когда использовать Pick и Omit?
Pick — когда нужно выбрать несколько полей. Omit — когда нужно исключить несколько полей.

3. Что такое discriminated union?
Union type с общим полем-дискриминантом, позволяющим TypeScript точно определять тип.

4. Как работают type guards?
Функции, которые проверяют тип и сужают его в условных блоках. Позволяют TypeScript понимать тип.

5. private vs protected?
private — доступ только в классе. protected — доступ в классе и наследниках.

6. Зачем нужны декораторы?
Метапрограммирование, добавление функциональности к классам/методам без изменения их кода.

7. Какие флаги tsconfig самые важные?
strict, noImplicitAny, strictNullChecks, target, module, moduleResolution.

8. Когда TypeScript мешает, а не помогает?
При overengineering, излишней сложности типов, когда типы становятся препятствием для разработки.

Key Takeaways (краткое резюме)
• Дженерики делают код переиспользуемым и типобезопасным.
• Утилитарные типы упрощают работу с типами.
• Discriminated unions — мощный паттерн для типобезопасности.
• Type guards сужают типы в условных блоках.
• Модификаторы доступа обеспечивают инкапсуляцию.
• tsconfig настраивает поведение компилятора.
• TypeScript должен помогать, а не мешать разработке.

________________________________________

Часть VI. React и современная разработка SPA
Глава 17. Основы React

React — это не фреймворк «для UI», а библиотека для декларативного описания интерфейсов, основанная на идее, что UI — это функция от состояния.

На собеседованиях по React в первую очередь проверяют:
• понимание модели рендеринга;
• отличие Virtual DOM от реального DOM;
• осознание того, почему React устроен именно так.

________________________________________
17.1. Virtual DOM и Fiber

Что такое Virtual DOM
Virtual DOM — это объектное представление реального DOM в памяти.

const element = <h1>Hello</h1>;
Под капотом это обычный JS-объект:
{
  type: "h1",
  props: { children: "Hello" }
}

Зачем он нужен
Прямые операции с DOM дорогие. React:
1. строит Virtual DOM
2. сравнивает его с предыдущей версией (diffing)
3. минимально обновляет реальный DOM

Это позволяет React эффективно обновлять только изменённые части интерфейса.

Fiber Architecture
Fiber — это внутренняя архитектура React.

Что она даёт:
• приоритеты обновлений
• прерываемый рендеринг
• concurrent features

Проще говоря: React может ставить рендер «на паузу», чтобы интерфейс оставался отзывчивым. Это основа для Suspense, startTransition и других concurrent features.

________________________________________
17.2. JSX и элементы

JSX — это синтаксический сахар над React.createElement.

JSX ≠ HTML
<div className="box" />
• className, а не class
• htmlFor, а не for
• самозакрывающиеся теги обязательны

Выражения в JSX
<h1>{title.toUpperCase()}</h1>
{count > 0 && <span>{count}</span>}

Условия
{isOpen && <Modal />}
{isLoading ? <Spinner /> : <Content />}

Списки и ключи
items.map(item => (
  <li key={item.id}>{item.name}</li>
));

⚠️ key нужен React, а не вам. Помогает React отслеживать элементы при изменениях списка.

Правила для key:
• должен быть уникальным среди siblings
• должен быть стабильным (не меняться между рендерами)
• лучше использовать ID, а не индекс

________________________________________
17.3. Компоненты и пропсы

Функциональный компонент
function Button({ title, onClick }) {
  return <button onClick={onClick}>{title}</button>;
}

Props — только для чтения
props.title = "New"; // ошибка концептуально

Props должны быть иммутабельными. Изменение props из компонента — антипаттерн.

Композиция
<Card>
  <Button />
</Card>

React поощряет композицию, а не наследование. Компоненты можно комбинировать для создания сложных интерфейсов.

Children
function Card({ children }) {
  return <div className="card">{children}</div>;
}

Использование:
<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>

________________________________________
17.4. Отрисовка и reconciliation

Процесс рендера
1. Изменилось состояние
2. Компонент перерендерился (вызвалась функция)
3. React сравнил деревья (diffing)
4. Применил минимальные изменения в DOM

Важно понимать
• рендер ≠ обновление DOM
• рендер — это вызов функции компонента
• React может вызывать компонент много раз
• DOM обновляется только при необходимости

Частая ошибка
function App() {
  fetch("/api"); // ❌
  return <div />;
}

Побочные эффекты нельзя выполнять в теле компонента. Используйте useEffect.

Контролируемые и неконтролируемые компоненты

Контролируемые
React контролирует значение через state:
<input value={value} onChange={e => setValue(e.target.value)} />

Неконтролируемые
DOM хранит состояние:
<input ref={inputRef} defaultValue="initial" />

Когда что использовать:
• Контролируемые — когда нужен контроль и валидация
• Неконтролируемые — для простых форм, когда производительность важна

________________________________________
Вопросы на собеседовании

1. Что такое Virtual DOM?
Объектное представление DOM в памяти. React сравнивает версии и обновляет только изменения.

2. Зачем нужен Fiber?
Позволяет прерывать рендеринг, устанавливать приоритеты, реализовывать concurrent features.

3. JSX — это HTML?
Нет, это синтаксический сахар над React.createElement. Компилируется в JavaScript.

4. Почему key важен?
Помогает React отслеживать элементы в списках, оптимизирует обновления, предотвращает баги.

5. Что происходит при изменении state?
Компонент перерендеривается, React сравнивает Virtual DOM, обновляет реальный DOM при необходимости.

6. Чем рендер отличается от обновления DOM?
Рендер — вызов функции компонента. Обновление DOM — физическое изменение в браузере. Рендер не всегда приводит к обновлению DOM.

7. Почему нельзя делать side effects в теле компонента?
Компонент может рендериться много раз, эффекты будут выполняться каждый раз, что приводит к багам и проблемам производительности.

8. Композиция vs наследование?
React поощряет композицию. Компоненты комбинируются для создания сложных интерфейсов.

Key Takeaways (краткое резюме)
• Virtual DOM оптимизирует обновления DOM.
• Fiber позволяет прерывать рендеринг и устанавливать приоритеты.
• JSX компилируется в React.createElement.
• Props иммутабельны, компоненты композируемы.
• Рендер ≠ обновление DOM.
• Побочные эффекты в useEffect, не в теле компонента.
• Key важен для списков.
• React поощряет композицию, а не наследование.

________________________________________

Часть VI. React и современная разработка SPA
Глава 18. Хуки и управление состоянием

Хуки — это механизм, который позволил React отказаться от классов и сделать логику компонентов компонуемой и переиспользуемой.

На собеседованиях хуки — одна из самых частых тем: ошибки в useEffect, неправильные зависимости и лишние ререндеры быстро показывают реальный уровень кандидата.

________________________________________
18.1. useState и useEffect

useState
const [count, setCount] = useState(0);

Особенности:
• асинхронное обновление
• вызывает повторный рендер
• обновления могут быть батчены (группироваться)

Функциональное обновление
setCount(prev => prev + 1);

Обязательно, если новое значение зависит от предыдущего. Гарантирует актуальное состояние.

useEffect
Используется для побочных эффектов:
• запросы к API
• подписки
• таймеры
• работа с DOM

Синтаксис
useEffect(() => {
  // effect
  return () => {
    // cleanup
  };
}, [deps]);

Массив зависимостей

deps	Поведение
отсутствует	каждый рендер (антипаттерн)
[]	только при маунте
[a, b]	при изменении a или b

Cleanup функция
Выполняется перед следующим эффектом или при размонтировании компонента.

useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer); // cleanup
}, []);

Частые ошибки
• забыли зависимости → stale closures
• добавили лишние зависимости → лишние эффекты
• эффекты с состоянием без cleanup → утечки памяти
• бесконечные циклы из-за зависимостей

________________________________________
18.2. useMemo и useCallback

useMemo
Мемоизирует значение. Пересчитывается только при изменении зависимостей.

const total = useMemo(() => {
  return expensiveCalculation(items);
}, [items]);

Используйте когда:
• вычисление дорогое
• значение передаётся в дочерние компоненты
• нужно предотвратить лишние вычисления

useCallback
Мемоизирует функцию. Создаёт новую функцию только при изменении зависимостей.

const onClick = useCallback(() => {
  setCount(c => c + 1);
}, []);

Используйте когда:
• функция передаётся в дочерние компоненты
• функция в зависимостях других хуков

⚠️ Важно: Не использовать без причины — это оптимизация, а не базовый инструмент. Преждевременная оптимизация может ухудшить код.

________________________________________
18.3. useRef и forwardRef

useRef
const inputRef = useRef(null);

Особенности:
• хранит мутабельное значение
• не вызывает ререндер при изменении
• сохраняется между рендерами

Использование:
• доступ к DOM-элементам
• хранение предыдущих значений
• таймеры и интервалы

forwardRef
Позволяет передавать ref в дочерний компонент.

const Input = forwardRef((props, ref) => (
  <input ref={ref} {...props} />
));

Используется для:
• библиотечных компонентов
• интеграции с DOM
• передачи ref через несколько уровней

________________________________________
18.4. useReducer

Альтернатива useState для сложного состояния.

Пример
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });

dispatch({ type: "increment" });

Когда использовать
• много переходов состояния
• сложная логика обновления
• похож на Redux (подготовка к миграции)

Преимущества:
• централизованная логика
• предсказуемые обновления
• легче тестировать

________________________________________
18.5. Context API

Позволяет передавать данные без проп-дриллинга.

Пример
const ThemeContext = createContext("light");

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

function Child() {
  const theme = useContext(ThemeContext);
  return <div className={theme}>Content</div>;
}

Проблемы Context
• вызывает ререндер всех потребителей при изменении
• не замена Redux для сложного состояния
• может привести к проблемам производительности

Оптимизация:
• разделение контекстов (не один большой Context)
• мемоизация значений
• использование селекторов

Rules of Hooks
1. Вызывать только на верхнем уровне (не в условиях, циклах, вложенных функциях)
2. Только в React-функциях (компоненты или кастомные хуки)

Нарушение = баги и нестабильное поведение.

Кастомные хуки
Функции, начинающиеся с "use", использующие другие хуки.

function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  
  return { count, increment, decrement };
}

Позволяют переиспользовать логику между компонентами.

________________________________________
Вопросы на собеседовании

1. Чем useState отличается от useReducer?
useState для простого состояния, useReducer для сложной логики с множеством переходов.

2. Как работает useEffect?
Выполняет побочные эффекты после рендера. Cleanup выполняется перед следующим эффектом или размонтированием.

3. Почему важен массив зависимостей?
Определяет, когда эффект должен выполняться. Неправильные зависимости → баги и проблемы производительности.

4. useMemo vs useCallback?
useMemo мемоизирует значение, useCallback мемоизирует функцию.

5. Когда нужен useRef?
Для доступа к DOM, хранения мутабельных значений без ререндеров, предыдущих значений.

6. Что такое forwardRef?
Позволяет передавать ref в дочерний компонент через props.

7. Проблемы Context API?
Ререндер всех потребителей, проблемы производительности при частых обновлениях, не замена Redux.

8. Что будет, если нарушить правила хуков?
Непредсказуемое поведение, баги, возможные ошибки React.

Key Takeaways (краткое резюме)
• useState для простого состояния, useReducer для сложного.
• useEffect для побочных эффектов, всегда указывайте зависимости.
• useMemo/useCallback — оптимизации, не злоупотребляйте.
• useRef для мутабельных значений без ререндеров.
• Context API решает проп-дриллинг, но имеет ограничения.
• Правила хуков обязательны для стабильности.
• Кастомные хуки переиспользуют логику.
• Cleanup в useEffect предотвращает утечки памяти.

________________________________________

Часть VI. React и современная разработка SPA
Глава 19. Архитектура больших приложений

На этом этапе React перестаёт быть «набором компонентов» и становится платформой для построения сложных систем. Главный вызов больших SPA — управление состоянием, зависимостями и потоками данных.

На собеседованиях эту главу используют, чтобы понять:
• мыслишь ли ты архитектурно;
• умеешь ли масштабировать приложение;
• понимаешь ли trade-off'ы разных подходов.

________________________________________
19.1. Redux Toolkit

Redux Toolkit (RTK) — современный и рекомендуемый способ использования Redux. Redux без RTK сегодня считается устаревшей практикой.

Ключевые идеи Redux
• единое хранилище (single source of truth)
• иммутабельные обновления
• однонаправленный поток данных

Проблемы «старого» Redux
• слишком много boilerplate
• ручная иммутабельность
• сложные async-сценарии

RTK решает эти проблемы.

createSlice
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value++;
    }
  }
});

export const { increment } = counterSlice.actions;
export default counterSlice.reducer;

Под капотом используется Immer, поэтому мутации выглядят «мутабельными», но остаются иммутабельными.

Async logic: createAsyncThunk
export const fetchUsers = createAsyncThunk(
  "users/fetch",
  async () => {
    const res = await fetch("/api/users");
    return res.json();
  }
);

// В компоненте
const { data, isLoading } = useSelector(state => state.users);
dispatch(fetchUsers());

Когда Redux оправдан
• сложные бизнес-процессы
• много источников данных
• глобальное состояние, важное для всего приложения
• нужен time-travel debugging
• большая команда, нужна предсказуемость

Когда Redux НЕ нужен:
• простое локальное состояние
• небольшие приложения
• только server state (используйте TanStack Query)

________________________________________
19.2. Альтернативные state-менеджеры

MobX
• реактивность
• минимум boilerplate
• магия под капотом

Плюс: быстро начать
Минус: сложнее отлаживать, менее предсказуемо

Zustand
const useStore = create(set => ({
  count: 0,
  inc: () => set(state => ({ count: state.count + 1 }))
}));

• минималистичный
• отлично подходит для средних проектов
• простота использования

Recoil
• атомарное состояние
• экспериментальный
• плотная интеграция с React

Сравнение

Инструмент	Когда использовать
Redux Toolkit	сложная логика, большие команды
MobX	высокая динамика, быстрое прототипирование
Zustand	компактные приложения, средние проекты
Recoil	эксперименты, атомарное состояние

________________________________________
19.3. TanStack Query

TanStack Query (ранее React Query) — это не state manager, а инструмент для server state.

Server state vs Client state

Server state:
• кэшируется
• может устаревать
• синхронизируется с сервером
• нужна обработка loading/error

Client state:
• локальное состояние UI
• не синхронизируется с сервером
• управляется через useState/useReducer

Пример
const { data, isLoading, error } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  staleTime: 5000
});

Что решает TanStack Query
• кэширование запросов
• автоматический refetch
• loading / error states
• дедупликацию запросов
• оптимистичные обновления
• инвалидацию кэша

Мутации
const mutation = useMutation({
  mutationFn: createUser,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["users"] });
  }
});

Когда использовать
Почти всегда, если есть API. TanStack Query идеален для работы с server state.

Паттерны TanStack Query (из правил пользователя):
1. Фабрика ключей: Централизуй создание ключей через queryKeys.ts
2. Кастомные хуки: Инкапсулируй каждый запрос в хук useEntityOperation
3. Оптимистичные обновления: onMutate + setQueryData
4. Предзагрузка: prefetchQuery при наведении
5. Селекторы: select в useQuery для подписки только на нужные данные
6. Точечная инвалидация: через predicate, а не всю группу
7. Глобальная обработка ошибок: на уровне QueryClient
8. Бесконечные списки: useInfiniteQuery для пагинации

________________________________________
19.4. Архитектурные паттерны React

Render Props
<DataProvider>
  {data => <List data={data} />}
</DataProvider>

Редко используется сегодня, но важно знать для понимания паттернов.

HOC (Higher-Order Components)
const withAuth = Component => props =>
  isAuth ? <Component {...props} /> : <Login />;

Минусы:
• сложная вложенность
• проблемы с типами
• сложнее отлаживать

Сегодня заменяется хуками.

Compound Components
<Tabs>
  <Tabs.List />
  <Tabs.Panel />
</Tabs>

Используется в UI-библиотеках. Позволяет создавать гибкие API компонентов.

Практические рекомендации
• разделяй server и client state
• не храни всё в Redux
• начинай с простого (useState → Context → Redux)
• архитектура — это эволюция, а не догма
• используй TanStack Query для server state
• локальное состояние — в компонентах
• глобальное состояние — только когда действительно нужно

________________________________________
Вопросы на собеседовании

1. Когда нужен Redux, а когда нет?
Нужен: сложная логика, много источников данных, большая команда. Не нужен: простое состояние, небольшие приложения.

2. Почему Redux Toolkit лучше классического Redux?
Меньше boilerplate, автоматическая иммутабельность через Immer, встроенная поддержка async через createAsyncThunk.

3. MobX vs Redux — различия?
MobX — реактивность, меньше кода. Redux — предсказуемость, явные обновления, лучше для больших команд.

4. Что такое server state?
Данные, приходящие с сервера: кэшируются, могут устаревать, требуют синхронизации.

5. Зачем нужен TanStack Query?
Управление server state: кэширование, refetch, обработка loading/error, дедупликация запросов.

6. HOC vs hooks?
Hooks проще, лучше типизация, меньше вложенности. HOC устарели, но важно знать паттерн.

7. Что такое compound components?
Паттерн, где компоненты работают вместе через контекст, создавая гибкий API.

8. Как избежать глобального состояния?
Локальное состояние в компонентах, Context для темы/языка, TanStack Query для server state, Redux только когда действительно нужно.

Key Takeaways (краткое резюме)
• Redux Toolkit — современный способ работы с Redux.
• Разделяй server state и client state.
• TanStack Query идеален для server state.
• Zustand — хорошая альтернатива для средних проектов.
• Начинай с простого, усложняй по необходимости.
• Архитектура — эволюция, а не догма.
• Compound Components — гибкий паттерн для UI-библиотек.
• HOC устарели, но важно понимать паттерн.

________________________________________

Часть VI. React и современная разработка SPA
Глава 20. SSR и современный React-стек

Современный фронтенд — это уже не просто SPA, загружаемая одним JS-файлом. Сегодня важно понимать где выполняется код, когда происходит рендер и какой код доезжает до браузера.

На собеседованиях SSR — частый фильтр на уровень Middle+.

________________________________________
20.1. Проблемы классического SPA

Классическое SPA имеет ряд ограничений:
• долгий Time To First Contentful Paint (TTFB)
• пустой HTML при первой загрузке
• проблемы SEO (поисковики видят пустую страницу)
• плохой UX на медленных сетях
• долгая интерактивность (TTI)

________________________________________
20.2. SSR (Server-Side Rendering)

SSR — рендеринг React-приложения на сервере.

Как это работает
1. Клиент запрашивает страницу
2. Сервер рендерит React в HTML
3. Клиент получает готовую разметку
4. JS «гидратирует» приложение (hydration)

Hydration
Hydration — процесс, при котором React:
• привязывает обработчики событий
• делает HTML интерактивным
• восстанавливает состояние

⚠️ HTML должен совпадать с клиентским рендером. Несоответствие → hydration errors.

Преимущества SSR:
• быстрый First Contentful Paint
• лучше SEO
• работает без JavaScript
• лучший UX на медленных сетях

Недостатки:
• нагрузка на сервер
• сложнее архитектура
• проблемы с гидратацией

________________________________________
20.3. Next.js

Next.js — стандарт де-факто для SSR/SSG в React.

Версии и эволюция
• Next.js 9-12: Pages Router с getServerSideProps/getStaticProps
• Next.js 13+: App Router с Server Components (по умолчанию)
• Next.js 15+: Улучшенная производительность, новые оптимизации
• Next.js 16: Стабильные Server Components, улучшенный кэшинг, новые API

Next.js 16 — ключевые улучшения:
• Стабильные React Server Components (RSC)
• Улучшенная система кэширования
• Оптимизированная работа с изображениями
• Улучшенная поддержка TypeScript
• Новые API для работы с данными
• Улучшенная производительность сборки

Типы рендеринга

Тип	Когда	Особенности
SSR	на каждый запрос	динамический контент
SSG	на этапе билда	статический контент, быстрее
ISR	SSG + обновление	гибридный подход
CSR	на клиенте	классическое SPA

Пример SSR
export async function getServerSideProps(context) {
  const data = await fetchData(context.params.id);
  return { props: { data } };
}

Пример SSG
export async function getStaticProps() {
  const data = await fetchData();
  return { props: { data }, revalidate: 60 };
}

Примечание: Эти примеры относятся к Pages Router (Next.js 9-12).
В App Router (Next.js 13+) используется другой подход:
• Server Components выполняются асинхронно по умолчанию
• Данные загружаются напрямую в Server Components
• getServerSideProps/getStaticProps не используются

ISR (Incremental Static Regeneration)
Обновление статических страниц по расписанию или по требованию.

________________________________________
20.4. Server Components

React Server Components — новый этап эволюции React.

React Server Components доступны в Next.js 13+ (App Router). В App Router компоненты по умолчанию являются Server Components. Client Components помечаются директивой 'use client'.

Идея
• код выполняется на сервере
• не попадает в JS-бандл
• уменьшает размер клиента
• прямой доступ к БД и файловой системе

Отличия от SSR

SSR	Server Components
HTML + JS	только HTML
гидратация	нет гидратации
большой бандл	меньший бандл
полный JS на клиенте	только клиентские компоненты

Server Components:
• не могут использовать хуки
• не могут использовать браузерные API
• выполняются только на сервере

Client Components (помечаются "use client"):
• могут использовать хуки
• интерактивность
• браузерные API

________________________________________
20.5. Код-сплиттинг и оптимизация

Dynamic import
const Heavy = lazy(() => import("./Heavy"));

Suspense
<Suspense fallback={<Loader />}>
  <Heavy />
</Suspense>

Route-based splitting
Каждый роут — отдельный чанк. Автоматически в Next.js, вручную в React Router.

Почему это важно
• меньше начальный JS-бандл
• быстрее загрузка
• лучший Core Web Vitals
• пользователь загружает только нужный код

________________________________________
20.6. Concurrent Features

React 18+ concurrent features:

Automatic batching
Группирует обновления состояния для оптимизации.

startTransition
Помечает обновления как не срочные.

startTransition(() => {
  setValue(v);
});

useTransition
const [isPending, startTransition] = useTransition();

Позволяет React отдавать приоритет более важным обновлениям.

Suspense для данных
Асинхронная загрузка данных с fallback UI.

________________________________________
Вопросы на собеседовании

1. Проблемы классического SPA?
Долгий TTFB, пустой HTML, проблемы SEO, плохой UX на медленных сетях.

2. Что такое SSR?
Рендеринг React на сервере, отправка готового HTML клиенту, затем гидратация.

3. Что такое hydration?
Процесс привязки обработчиков событий к серверному HTML, делающий его интерактивным.

4. SSR vs SSG?
SSR — на каждый запрос (динамический). SSG — на этапе билда (статический, быстрее).

5. Когда использовать Next.js?
Когда нужен SSR/SSG, SEO, быстрая загрузка, современный React-стек.

6. Что такое Server Components?
Компоненты, выполняющиеся только на сервере, не попадающие в JS-бандл.

7. Что даёт код-сплиттинг?
Меньший начальный бандл, загрузка кода по требованию, лучшая производительность.

8. Что такое Concurrent Mode?
Механизм React для приоритизации обновлений, прерывания рендеринга, улучшения отзывчивости.

9. Что нового в Next.js 16?
• Стабильные React Server Components (RSC)
• Улучшенная система кэширования
• Оптимизированная работа с изображениями
• Улучшенная поддержка TypeScript
• Новые API для работы с данными
• Улучшенная производительность сборки

10. Pages Router vs App Router в Next.js?
• Pages Router (Next.js 9-12): getServerSideProps, getStaticProps, файловая маршрутизация
• App Router (Next.js 13+): Server Components по умолчанию, async компоненты, улучшенная производительность
• Next.js 16: дальнейшие оптимизации App Router, стабильные RSC

Key Takeaways (краткое резюме)
• SSR решает проблемы SEO и производительности SPA.
• Next.js — стандарт для SSR/SSG в React.
• Next.js 16 улучшает производительность и стабильность Server Components.
• App Router (Next.js 13+) — современный подход с Server Components по умолчанию.
• Server Components уменьшают размер клиентского бандла.
• Код-сплиттинг критичен для производительности.
• Concurrent Features улучшают отзывчивость интерфейса.
• Hydration требует совпадения серверного и клиентского HTML.
• ISR — гибридный подход между SSG и SSR.

________________________________________

Часть VII. Архитектура и проектирование
Глава 21. Паттерны проектирования

Паттерны проектирования — это не «классика ради классики», а язык общения между разработчиками. На собеседованиях важно не заученное определение, а понимание:
• какую проблему решает паттерн;
• какие есть альтернативы;
• какие у него ограничения.

________________________________________
21.1. SOLID-принципы

SOLID — набор принципов объектно-ориентированного проектирования, применимых и во фронтенде.

S — Single Responsibility
Модуль должен иметь одну причину для изменения.

Плохо:
class UserService {
  fetchUser() {}
  renderUser() {}
}

Хорошо:
• сервис для данных
• компонент для UI

O — Open / Closed
Сущности должны быть открыты для расширения, но закрыты для изменения.

L — Liskov Substitution
Подтипы должны корректно заменять базовый тип.

I — Interface Segregation
Много маленьких интерфейсов лучше одного большого.

D — Dependency Inversion
Зависеть от абстракций, а не от реализаций.

________________________________________
21.2. Классические паттерны

Singleton
Гарантирует один экземпляр.

class Store {
  private static instance: Store;
  static getInstance() {
    if (!Store.instance) {
      Store.instance = new Store();
    }
    return Store.instance;
  }
}

⚠️ Во фронтенде часто заменяется контекстом React.

Factory
Создаёт объекты без знания конкретного класса.

function createUser(type: "admin" | "user") {
  return type === "admin" ? new Admin() : new User();
}

Observer
Реакция на изменения состояния.

Пример:
• EventEmitter
• RxJS
• Redux (через подписки)

Strategy
Выбор алгоритма во время выполнения.

const strategies = {
  asc: (a, b) => a - b,
  desc: (a, b) => b - a
};

Facade
Простой интерфейс над сложной системой.

Proxy
Контролирует доступ к объекту.

const proxy = new Proxy(target, {
  get(target, prop) {
    return target[prop];
  }
});

________________________________________
21.3. Фронтенд-архитектура модулей

Feature-based структура
/features
  /auth
  /profile
  /cart

Каждая фича содержит всё необходимое: компоненты, логику, стили, тесты.

Layered архитектура
• UI — компоненты
• domain — бизнес-логика
• data — работа с API

Anti-patterns
• god-components (огромные компоненты)
• бизнес-логика в UI
• тесная связность модулей

________________________________________
Вопросы на собеседовании

1. Что такое SOLID?
Набор принципов проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

2. Применимы ли паттерны GoF во фронтенде?
Да, но адаптированы под функциональный подход и компонентную модель.

3. Singleton — зло?
Во фронтенде часто заменяется Context API. Может быть полезен для глобальных сервисов.

4. Observer в React — где?
Redux (подписки), EventEmitter, RxJS, сам React (подписка на изменения).

5. Strategy — пример из UI?
Сортировка списков, валидация форм, алгоритмы отображения данных.

6. Что такое Facade?
Упрощённый интерфейс над сложной системой. Скрывает сложность.

7. Какие архитектурные анти-паттерны знаете?
God components, бизнес-логика в UI, тесная связность, дублирование кода.

Key Takeaways (краткое резюме)
• SOLID применим во фронтенде, но адаптирован под компонентную модель.
• Паттерны решают конкретные проблемы, не использовать везде.
• Singleton во фронтенде часто заменяется Context.
• Observer — основа реактивности в React/Redux.
• Feature-based структура — современный подход к организации кода.
• Anti-patterns важнее знать, чем паттерны.

________________________________________

Часть VII. Архитектура и проектирование
Глава 22. Архитектуры фронтенда

Если паттерны — это локальные решения, то архитектура — это каркас всего приложения. На уровне Middle+ от разработчика ожидают понимание не только как писать код, но и как организовать систему в целом.

На собеседованиях эту главу используют, чтобы проверить:
• системное мышление;
• опыт работы с большими кодовыми базами;
• способность принимать архитектурные решения.

________________________________________
22.1. MVC, MVP, MVVM

Эти архитектуры пришли во фронтенд из классического UI-разработки.

MVC (Model – View – Controller)
Роли:
• Model — данные и бизнес-логика
• View — отображение
• Controller — обработка действий пользователя

Проблемы во фронтенде:
• сильная связность
• сложно масштабировать
• плохо ложится на React

MVP (Model – View – Presenter)
Presenter:
• получает данные из Model
• подготавливает их для View

View становится максимально «тупой».

MVVM (Model – View – ViewModel)
ViewModel:
• состояние
• логика отображения
• биндинги

Часто ассоциируется с:
• Angular
• Vue

Вывод
React формально не относится ни к одной из этих архитектур, но заимствует идеи MVVM.

________________________________________
22.2. Flux, Redux, CQRS

Flux
Архитектура от Facebook.

Принципы:
• однонаправленный поток данных
• actions → dispatcher → store → view

Redux
Упрощённый Flux:
UI → Action → Reducer → Store → UI

Преимущества:
• предсказуемость
• логируемость
• time-travel debugging

CQRS (Command Query Responsibility Segregation)
Разделение:
• команд (изменяют состояние)
• запросов (читают состояние)

Во фронтенде проявляется через:
• action creators (команды)
• selectors (запросы)

________________________________________
22.3. Microfrontend и модульная архитектура

Microfrontend — разбиение фронтенда на независимые части.

Когда это нужно
• большие команды
• независимые релизы
• разные технологические стеки

Подходы
• Module Federation (Webpack)
• iframe
• Web Components

Проблемы
• сложность интеграции
• дублирование зависимостей
• рост сложности DevOps

________________________________________
22.4. Clean Architecture во фронтенде

Идея: бизнес-логика не зависит от UI.

Слои
1. Domain — бизнес-логика
2. Use Cases — сценарии использования
3. Adapters — адаптеры к внешним системам
4. UI — интерфейс

Преимущества
• тестируемость
• переиспользуемость
• независимость от фреймворка

Минусы
• оверхед для небольших проектов
• сложность для простых задач

Кейс-стади
Задача: Большое SPA с сложной логикой, большим количеством API, несколькими командами.

Решение:
• feature-based структура
• TanStack Query для server state
• Redux Toolkit для глобального состояния
• модульные слои (domain / ui / api)

________________________________________
Вопросы на собеседовании

1. Чем MVC отличается от MVVM?
MVC — Controller управляет. MVVM — ViewModel связывает через биндинги.

2. Можно ли считать React MVC-фреймворком?
Нет, React ближе к MVVM, но не является строгой реализацией.

3. Что такое Flux?
Архитектура с однонаправленным потоком данных от Facebook.

4. Почему Redux однонаправленный?
Предсказуемость, логируемость, простота отладки.

5. Когда оправданы микрофронтенды?
Большие команды, независимые релизы, разные технологические стеки.

6. Какие проблемы у microfrontend?
Сложность интеграции, дублирование зависимостей, рост сложности DevOps.

7. Что такое Clean Architecture?
Разделение на слои: Domain, Use Cases, Adapters, UI. Бизнес-логика не зависит от UI.

8. Когда архитектура — это оверхед?
Для небольших проектов, простых задач, когда сложность не оправдана.

Key Takeaways (краткое резюме)
• MVC/MVP/MVVM — классические паттерны, адаптированные под фронтенд.
• Flux/Redux — однонаправленный поток данных.
• Microfrontend — для больших команд и независимых релизов.
• Clean Architecture — для сложных проектов с бизнес-логикой.
• Архитектура должна соответствовать масштабу проекта.
• Feature-based структура — современный подход.

________________________________________

Часть VIII. Производительность и безопасность
Глава 23. Производительность

Производительность — это не «оптимизация ради оптимизации», а пользовательский опыт и деньги бизнеса. Медленный интерфейс снижает конверсию, увеличивает отток и напрямую влияет на метрики продукта.

На собеседованиях производительность — индикатор инженерной зрелости.

________________________________________
23.1. Оптимизация загрузки

Критические метрики (Core Web Vitals)
• LCP (Largest Contentful Paint) — скорость загрузки основного контента (< 2.5s)
• FID / INP — отзывчивость интерфейса (< 100ms)
• CLS — визуальная стабильность (< 0.1)

Что замедляет загрузку
• большой JS-бандл
• блокирующие ресурсы
• отсутствие кеширования
• неоптимизированные изображения
• блокирующий JavaScript

Code Splitting
const Page = lazy(() => import("./Page"));
Позволяет грузить код по требованию.

Preload / Prefetch
<link rel="preload" href="font.woff2" as="font">
<link rel="prefetch" href="next-page.js">

• preload — критично сейчас
• prefetch — возможно пригодится потом

________________________________________
23.2. Оптимизация рендеринга

Избегание лишних ререндеров

Причины ререндеров:
• изменение props
• изменение state
• изменение context

React.memo
export default memo(Component);
Предотвращает ререндер при тех же props.

useCallback / useMemo
Использовать только при необходимости. Антипаттерн — мемоизировать всё подряд.

Virtualization
Для длинных списков:
• react-window
• react-virtual

Рендерятся только видимые элементы.

________________________________________
23.3. Lighthouse и WebPageTest

Lighthouse
• доступен в DevTools
• показывает проблемы
• даёт рекомендации
• проверяет Core Web Vitals

WebPageTest
• реальные устройства
• реальные сети
• waterfall-загрузка
• используется для глубокой диагностики

________________________________________
23.4. Lazy-loading и prefetching

Изображения
<img src="img.jpg" loading="lazy">

Компоненты
lazy(() => import("./Chart"));

Route-based splitting
Каждый роут — отдельный чанк.

________________________________________
23.5. Работа с изображениями

Форматы
Формат	Когда
JPEG	фото
PNG	прозрачность
WebP	универсальный, лучшее сжатие
AVIF	лучшее сжатие (новый формат)

Responsive images
<img
  srcset="img-320.jpg 320w, img-640.jpg 640w"
  sizes="(max-width: 600px) 100vw, 50vw"
>

Браузер сам выбирает правильное изображение.

Типичные ошибки
• ранняя оптимизация без профилирования
• отсутствие метрик
• оптимизация без понимания узких мест

________________________________________
Вопросы на собеседовании

1. Что такое Core Web Vitals?
LCP, FID/INP, CLS — ключевые метрики производительности.

2. Что больше всего влияет на LCP?
Размер изображений, блокирующие ресурсы, время ответа сервера.

3. Как уменьшить размер JS-бандла?
Code splitting, tree-shaking, удаление неиспользуемого кода, минификация.

4. Когда нужен React.memo?
Когда компонент рендерится часто с теми же props, и рендер дорогой.

5. Что такое virtualization?
Рендеринг только видимых элементов в длинных списках.

6. Lighthouse vs WebPageTest?
Lighthouse — быстрая проверка в DevTools. WebPageTest — глубокий анализ на реальных устройствах.

7. Lazy-loading vs prefetch?
Lazy-loading — загрузка по требованию. Prefetch — предзагрузка на будущее.

8. Почему ранняя оптимизация вредна?
Оптимизация без профилирования может ухудшить код, не решив реальные проблемы.

Key Takeaways (краткое резюме)
• Core Web Vitals — ключевые метрики производительности.
• Code splitting критичен для больших приложений.
• React.memo/useMemo/useCallback — оптимизации, не злоупотребляйте.
• Virtualization для длинных списков.
• Lighthouse и WebPageTest для диагностики.
• Оптимизация изображений критична для LCP.
• Профилирование перед оптимизацией.

________________________________________

Часть VIII. Производительность и безопасность
Глава 24. Безопасность во фронтенде

Безопасность во фронтенде — это не про «сервер всё проверит», а про минимизацию поверхности атаки. На уровне Middle+ ожидается понимание моделей угроз, а не просто список терминов.

________________________________________
24.1. XSS (Cross-Site Scripting)

XSS — внедрение вредоносного JS-кода в доверенный контекст.

Виды XSS

Отражённая (Reflected)
Код возвращается в ответе сервера. Пользователь видит вредоносный URL.

Хранимая (Stored)
Код сохраняется в БД и исполняется у всех пользователей.

DOM-based
Манипуляции DOM без участия сервера. Вредоносный код в клиентском JS.

Пример
element.innerHTML = userInput; // ❌

Защита
• экранирование (sanitization)
• Content Security Policy (CSP)
• отказ от innerHTML
• использование фреймворков (React экранирует по умолчанию)
• textContent вместо innerHTML

________________________________________
24.2. CSRF (Cross-Site Request Forgery)

CSRF — выполнение запроса от имени пользователя без его ведома.

Как работает
• браузер автоматически отправляет cookies
• злоумышленник подсовывает запрос с другого сайта

Защита
• CSRF-токены
• SameSite cookies
• проверка Origin / Referer
• двойная отправка cookies

________________________________________
24.3. CORS

CORS — механизм контроля доступа между origin'ами.

Preflight-запрос
OPTIONS /api
Проверка разрешений перед основным запросом.

Типичная ошибка
Открытый CORS:
Access-Control-Allow-Origin: *

Должно быть ограничено конкретными доменами.

________________________________________
24.4. Cookie-флаги

HttpOnly
JS не имеет доступа. Защита от XSS.

Secure
Только по HTTPS. Защита от перехвата.

SameSite
• Strict — только same-site запросы
• Lax — GET-запросы с других сайтов разрешены
• None — требует Secure

________________________________________
24.5. Токены и аутентификация

JWT
Плюсы:
• stateless
• масштабируемость

Минусы:
• нельзя отозвать
• риск утечки
• размер токена

Access + Refresh tokens
• access — короткоживущий (15 мин)
• refresh — обновление (7 дней)

Где хранить
• HttpOnly cookies (предпочтительно)
• не в localStorage (уязвимо к XSS)

________________________________________
24.6. OWASP Top-10

Ключевые пункты для фронтенда:
• XSS
• CSRF
• insecure storage
• misconfiguration

Типичные ошибки
• хранение токенов в localStorage
• отключение CORS без понимания
• доверие данным от клиента

________________________________________
Вопросы на собеседовании

1. Разница между видами XSS?
Reflected — в URL, Stored — в БД, DOM-based — в клиентском JS.

2. Как защититься от XSS?
Экранирование, CSP, textContent вместо innerHTML, фреймворки.

3. Что такое CSRF?
Выполнение запроса от имени пользователя без его ведома через автоматическую отправку cookies.

4. CORS — это защита сервера или браузера?
Браузера. Сервер настраивает политику, браузер её исполняет.

5. Чем cookies лучше localStorage для токенов?
HttpOnly cookies недоступны из JS, защита от XSS.

6. Что делает SameSite?
Ограничивает отправку cookies только для same-site запросов, защита от CSRF.

7. JWT — плюсы и минусы?
Плюсы: stateless, масштабируемость. Минусы: нельзя отозвать, размер, риск утечки.

8. Какие пункты OWASP важны для фронта?
XSS, CSRF, insecure storage, misconfiguration.

Key Takeaways (краткое резюме)
• XSS — самая частая угроза фронтенда.
• CSRF защищается токенами и SameSite cookies.
• CORS настраивается на сервере.
• HttpOnly cookies безопаснее localStorage.
• JWT имеет ограничения, нужна стратегия обновления.
• OWASP Top-10 — базовый чек-лист безопасности.

________________________________________

Часть IX. Node.js для фронтенд-разработчика
Глава 25. Основы Node.js

Фронтенд-разработчик сегодня — это не только браузер. Node.js нужен для:
• сборки;
• SSR;
• BFF (Backend For Frontend);
• простых API.

На собеседованиях проверяют не умение писать бэкенд, а понимание модели выполнения.

________________________________________
25.1. Event Loop в Node.js

Node.js однопоточен, но неблокирующий. Это возможно благодаря Event Loop.

Фазы Event Loop
1. timers — setTimeout, setInterval
2. pending callbacks — отложенные колбэки
3. idle, prepare — внутренние операции
4. poll — получение новых I/O событий
5. check — setImmediate
6. close callbacks — закрытие соединений

Microtasks
• process.nextTick — самый приоритетный
• Promise.then

Выполняются между фазами.

Сравнение с браузером

Браузер	Node
Web APIs	libuv
macrotasks	phases
microtasks	nextTick / Promise

________________________________________
25.2. CommonJS vs ES Modules

CommonJS
const fs = require("fs");
• синхронная загрузка
• runtime
• используется в старых проектах Node.js

ES Modules
import fs from "fs";
• статический анализ
• tree-shaking
• современный стандарт

Когда что
• старые проекты — CJS
• новые — ESM

________________________________________
25.3. npm-скрипты

package.json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  }
}

Lifecycle hooks
• prebuild — перед сборкой
• postinstall — после установки

Используется для:
• генерации файлов
• подготовки окружения

________________________________________
25.4. Лёгкое API: Express / Fastify

Express
app.get("/api", (req, res) => {
  res.json({ ok: true });
});

Fastify
• быстрее
• schema-based валидация
• лучше для production

Когда фронту нужен Node
• SSR (Next.js, Remix)
• proxy API
• mock сервер
• server actions

________________________________________
Вопросы на собеседовании

1. Почему Node однопоточен?
Одна нить выполнения, но неблокирующий I/O через Event Loop.

2. Event Loop в Node и браузере — различия?
Разные фазы, process.nextTick в Node, разные приоритеты.

3. process.nextTick vs Promise?
nextTick выполняется раньше Promise в Node.js.

4. CommonJS vs ES Modules?
CJS — динамический, runtime. ESM — статический, compile-time.

5. Зачем фронту Node?
Сборка, SSR, инструменты разработки, BFF.

6. Express vs Fastify?
Fastify быстрее, имеет schema-based валидацию. Express проще, больше экосистема.

Key Takeaways (краткое резюме)
• Node.js однопоточен, но неблокирующий через Event Loop.
• Event Loop в Node отличается от браузера.
• CommonJS vs ESM — важное различие.
• Node нужен фронтендеру для инструментов и SSR.
• Express/Fastify для простых API и BFF.

________________________________________

Часть X. Подготовка к собеседованию
Глава 26. Алгоритмические задачи для фронтенда

Фронтенд-разработчики редко пишут сложные алгоритмы, но базовые структуры данных и алгоритмы проверяют на собеседованиях.

Ключевые темы:
• Массивы и методы массивов
• Объекты и Map/Set
• Рекурсия
• Замыкания в задачах
• Асинхронность в задачах
• Работа с DOM в задачах

Типичные задачи:
• Поиск и фильтрация
• Трансформация данных
• Работа со строками
• Оптимизация производительности

Подход к решению:
1. Понять задачу
2. Выбрать структуру данных
3. Написать решение
4. Оптимизировать при необходимости

Key Takeaways
• Базовые алгоритмы важны для собеседований.
• Понимание структур данных помогает в работе.
• Оптимизация — часть решения задач.

________________________________________

Часть X. Подготовка к собеседованию
Глава 27. Поведенческое собеседование

Поведенческие вопросы проверяют опыт и подход к решению проблем.

Типичные вопросы:
• Расскажите о сложном проекте
• Как решали конфликты в команде
• Опишите ситуацию с дедлайном
• Как обучаетесь новым технологиям

Подход к ответам:
• STAR метод (Situation, Task, Action, Result)
• Конкретные примеры
• Фокус на действиях и результатах

Key Takeaways
• Подготовьте примеры из опыта.
• Используйте структурированный подход.
• Фокус на решении проблем.

________________________________________

Часть X. Подготовка к собеседованию
Глава 28. Итоговый чек-лист

28.1. Что должен знать Junior
• HTML, CSS, JavaScript основы
• React основы (компоненты, props, state)
• Работа с DOM
• Базовое понимание асинхронности
• Git основы
• Понимание браузерных инструментов

28.2. Что должен знать Middle
• Глубокая механика JavaScript (this, замыкания, прототипы)
• React хуки и паттерны
• Управление состоянием (Context, Redux)
• Производительность и оптимизация
• TypeScript
• Тестирование
• Архитектура приложений
• SSR/SSG понимание

28.3. Типичные ошибки кандидатов
• Непонимание Event Loop
• Ошибки в useEffect (зависимости)
• Незнание основ браузера (рендеринг)
• Игнорирование производительности
• Отсутствие понимания типизации
• Незнание современных практик

28.4. Финальные советы
• Практикуйтесь на реальных проектах
• Изучайте исходный код библиотек
• Следите за обновлениями экосистемы
• Понимайте, а не заучивайте
• Готовьтесь к вопросам о trade-off'ах

Key Takeaways (краткое резюме)
• Junior — основы и умение учиться.
• Middle — глубокое понимание механики и архитектуры.
• Senior — системное мышление и принятие решений.
• Понимание важнее заучивания.
• Практика на реальных проектах критична.
