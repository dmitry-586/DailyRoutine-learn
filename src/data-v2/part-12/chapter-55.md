# Глава 55. Рендер-стратегии: SPA, SSR, SSG, ISR

Понимание различных стратегий рендеринга критично для выбора правильного подхода в зависимости от требований проекта. Каждая стратегия имеет свои преимущества и trade-offs.

---

## 55.1. Проблемы классического SPA

Классическое SPA (Single Page Application) имеет ряд ограничений, которые становятся критичными на медленных сетях и для SEO.

### Долгий Time To First Contentful Paint (TTFB)

Пользователь видит пустой экран, пока:

- загружается HTML (обычно минимальный)
- загружается и парсится JavaScript
- выполняется JavaScript
- выполняются запросы к API
- рендерится контент

На медленных сетях это может занимать несколько секунд.

**Пример временной шкалы:**

```
0ms    → Запрос страницы
200ms  → HTML загружен (пустой <div id="root"></div>)
500ms  → JavaScript начал загружаться
1500ms → JavaScript загружен и парсится
2000ms → JavaScript выполняется
2500ms → Запрос к API
3000ms → Данные получены
3500ms → Контент отрендерен
```

Пользователь **3.5 секунды** видит пустой экран!

### Пустой HTML при первой загрузке

Поисковые системы и социальные сети видят пустую страницу:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>My App</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="/app.js"></script>
  </body>
</html>
```

Контент появляется только после выполнения JavaScript.

**Проблема для SEO:**

- поисковые роботы могут не дождаться выполнения JS
- социальные сети (Open Graph) видят пустую страницу
- требуется дополнительная настройка (pre-rendering, sitemap)

### Плохой UX на медленных сетях

На медленных соединениях:

- пользователь долго видит пустой экран
- интерактивность появляется только после загрузки всего JS
- плохой First Input Delay (FID) — задержка до первого взаимодействия

**Метрики Core Web Vitals страдают:**

- **LCP (Largest Contentful Paint)** — долго до появления контента
- **FID (First Input Delay)** — долго до интерактивности
- **CLS (Cumulative Layout Shift)** — возможны сдвиги при загрузке

---

## 55.2. SSR (Server-Side Rendering)

SSR — это рендеринг React-приложения **на сервере** перед отправкой клиенту.

### Как это работает

1. **Клиент запрашивает страницу** — браузер отправляет HTTP-запрос на сервер
2. **Сервер рендерит React в HTML** — сервер выполняет React-код и генерирует HTML
3. **Клиент получает готовую разметку** — браузер получает HTML с контентом
4. **JS «гидратирует» приложение** — JavaScript загружается и «оживляет» HTML

### Простой пример SSR (концептуально)

```javascript
// server.js (упрощённо)
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import App from './App'

app.get('/', (req, res) => {
  const html = ReactDOMServer.renderToString(<App />)
  res.send(`
    <!DOCTYPE html>
    <html>
      <head><title>My App</title></head>
      <body>
        <div id="root">${html}</div>
        <script src="/app.js"></script>
      </body>
    </html>
  `)
})
```

Клиент получает HTML с контентом сразу, а не пустую страницу.

**Временная шкала SSR:**

```
0ms    → Запрос страницы
200ms  → HTML загружен (с контентом!)
500ms  → JavaScript начал загружаться
1500ms → JavaScript загружен
2000ms → Hydration завершена, страница интерактивна
```

Пользователь видит контент уже через **200ms** вместо 3500ms!

### Hydration: оживление HTML

**Hydration** — процесс, при котором React:

- привязывает обработчики событий к существующим DOM-элементам
- делает HTML интерактивным
- восстанавливает состояние компонентов
- подключает клиентскую логику

**Критически важно:** HTML, сгенерированный на сервере, должен **совпадать** с тем, что рендерится на клиенте. Несоответствие приводит к hydration errors.

### Пример hydration error

```jsx
// Проблема: разный HTML на сервере и клиенте
function Component() {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  // На сервере: <div>Server</div>
  // На клиенте после hydration: <div>Client</div>
  // → hydration error!
  return <div>{mounted ? 'Client' : 'Server'}</div>
}
```

**Решение:**

```jsx
// Правильно: используй useEffect для клиент-специфичного контента
function Component() {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  return (
    <div>
      <p>Always visible</p>
      {mounted && <p>Client only</p>}
    </div>
  )
}
```

### Преимущества SSR

- **быстрый First Contentful Paint** — пользователь сразу видит контент
- **лучше SEO** — поисковые системы видят полный HTML
- **работает без JavaScript** — базовый контент доступен даже при отключённом JS
- **лучший UX на медленных сетях** — контент появляется быстрее

### Недостатки SSR

- **нагрузка на сервер** — каждый запрос требует рендеринга на сервере
- **сложнее архитектура** — нужен сервер, который может выполнять Node.js
- **проблемы с гидратацией** — нужно следить за совпадением серверного и клиентского HTML
- **медленнее Time To Interactive** — нужно дождаться загрузки JS для интерактивности

**Trade-off:**

SSR улучшает First Contentful Paint, но может ухудшить Time To Interactive, если JavaScript большой.

---

## 55.3. SSG (Static Site Generation)

SSG — генерация статических HTML-страниц на этапе сборки.

### Как это работает

1. **На этапе билда** — все страницы рендерятся в статический HTML
2. **Деплой** — статические файлы загружаются на CDN
3. **Запрос** — CDN отдаёт готовый HTML мгновенно

**Пример (Next.js App Router):**

```tsx
// app/blog/[slug]/page.tsx
async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug)

  return <article>{post.content}</article>
}

// Генерируется на этапе билда
export async function generateStaticParams() {
  const posts = await getAllPosts()
  return posts.map((post) => ({ slug: post.slug }))
}
```

### Преимущества SSG

- **максимальная производительность** — нет нагрузки на сервер при запросе
- **отличный SEO** — полный HTML доступен сразу
- **масштабируемость** — CDN может обслуживать миллионы запросов
- **низкая стоимость** — статический хостинг дешевле серверов

### Недостатки SSG

- **данные могут устареть** — нужно пересобирать для обновления
- **долгая сборка** — при большом количестве страниц
- **нет персонализации** — все пользователи видят одинаковый контент

**Когда использовать:**

- статический контент (блог, документация, лендинги)
- контент, который не меняется часто
- когда важна максимальная производительность

---

## 55.4. ISR (Incremental Static Regeneration)

ISR — гибридный подход: SSG + периодическое обновление.

### Как это работает

1. **На этапе билда** — страницы генерируются статически
2. **При запросе** — если страница устарела, она пересобирается в фоне
3. **Следующий запрос** — получает обновлённую версию

**Пример:**

```tsx
// app/products/[id]/page.tsx
async function ProductPage({ params }: { params: { id: string } }) {
  const product = await fetch(`/api/products/${params.id}`, {
    next: { revalidate: 3600 }, // пересобирать раз в час
  })
  const data = await product.json()

  return <div>{data.name}</div>
}
```

**Аналогия:** как газета — она статична для читателя, но выпускается регулярно с новыми данными.

### Преимущества ISR

- **производительность SSG** — статические страницы отдаются мгновенно
- **актуальность данных** — автоматическое обновление по расписанию
- **масштабируемость** — CDN + фоновое обновление
- **гибкость** — можно настроить интервал обновления

### Недостатки ISR

- **задержка обновления** — данные могут быть не самыми свежими
- **сложнее настройка** — нужно правильно выбрать интервал revalidate

**Когда использовать:**

- контент, который меняется, но не критично часто
- баланс между производительностью и актуальностью
- каталоги товаров, статьи блога

---

## 55.5. CSR (Client-Side Rendering)

CSR — классическое SPA, рендеринг происходит в браузере.

### Как это работает

1. **Запрос** — браузер получает минимальный HTML
2. **Загрузка JS** — загружается весь JavaScript
3. **Рендеринг** — React рендерит приложение в браузере
4. **Запросы к API** — данные загружаются по требованию

**Пример:**

```tsx
'use client' // Client Component

function InteractiveComponent() {
  const [count, setCount] = useState(0)

  return <button onClick={() => setCount(count + 1)}>{count}</button>
}
```

### Преимущества CSR

- **интерактивность** — полный контроль над UI
- **быстрая навигация** — после первой загрузки переходы мгновенные
- **простая архитектура** — не нужен сервер для рендеринга

### Недостатки CSR

- **долгая первая загрузка** — нужно загрузить весь JS
- **плохой SEO** — поисковики видят пустую страницу
- **плохой UX на медленных сетях** — долго до появления контента

**Когда использовать:**

- интерактивные части приложения
- данные, которые загружаются по требованию
- части страницы, которые не критичны для SEO

---

## 55.6. Сравнение стратегий

**SSR (Server-Side Rendering):**

- Когда рендерится: на каждый запрос
- Производительность: медленнее
- Актуальность данных: всегда актуальные
- SEO: хорошо
- Нагрузка на сервер: высокая

**SSG (Static Site Generation):**

- Когда рендерится: на этапе билда
- Производительность: быстрее всего
- Актуальность данных: могут устареть
- SEO: хорошо
- Нагрузка на сервер: нет

**ISR (Incremental Static Regeneration):**

- Когда рендерится: на билде + периодически
- Производительность: быстро
- Актуальность данных: обновляются периодически
- SEO: хорошо
- Нагрузка на сервер: низкая

**CSR (Client-Side Rendering):**

- Когда рендерится: на клиенте
- Производительность: зависит от сети
- Актуальность данных: зависит от запросов
- SEO: плохо
- Нагрузка на сервер: нет

---

## 55.7. Выбор стратегии

### Когда использовать SSR

- динамический контент, который меняется часто
- данные, которые должны быть актуальными при каждом запросе
- персонализированный контент
- когда важна актуальность больше, чем производительность

### Когда использовать SSG

- статический контент (блог, документация, лендинги)
- контент, который не меняется часто
- когда важна максимальная производительность
- когда нет персонализации

### Когда использовать ISR

- контент, который меняется, но не критично часто
- баланс между производительностью и актуальностью
- каталоги товаров, статьи блога
- когда нужна производительность SSG с возможностью обновления

### Когда использовать CSR

- интерактивные части приложения
- данные, которые загружаются по требованию
- части страницы, которые не критичны для SEO
- когда важна интерактивность больше, чем SEO

---

## Вопросы на собеседовании

### 1. В чём разница между SSR и SSG?

SSR рендерится на каждый запрос, SSG — на этапе билда. SSR всегда актуальный, SSG быстрее.

### 2. Что такое ISR?

Гибридный подход: статические страницы с периодическим обновлением.

### 3. Что такое hydration?

Процесс «оживления» серверного HTML на клиенте через JavaScript.

### 4. Когда использовать SSR, а когда SSG?

SSR для динамического контента, SSG для статического.

### 5. В чём проблема CSR для SEO?

Поисковики видят пустую страницу, контент появляется только после JS.

