# Глава 52. Server state и client state

Разделение Server State и Client State — фундаментальный принцип современной архитектуры React-приложений. Понимание различий критично для выбора правильных инструментов и паттернов.

---

## 52.1. Client State

**Client State** — это состояние, которое контролируется приложением и существует только в браузере.

### Характеристики

- **Синхронный** — доступен сразу, не требует асинхронных операций
- **Контролируется приложением** — полностью под нашим контролем
- **Не устаревает** — данные актуальны, пока мы их не изменим
- **Не требует кеширования** — данные всегда в памяти

### Примеры Client State

**Типичные случаи использования:**

- UI состояние (модальные окна, сайдбары, табы)
- Тема приложения
- Локальные фильтры и сортировка
- Временное состояние форм (до отправки)
- Состояние анимаций

### Инструменты для Client State

- **useState** — локальное состояние компонента
- **useReducer** — сложное локальное состояние
- **Context API** — простое глобальное состояние (тема, язык)
- **Zustand** — глобальное состояние с лучшей производительностью
- **Jotai/Recoil** — атомарное состояние

---

## 52.2. Server State

**Server State** — это данные, которые приходят с сервера и могут устареть.

### Характеристики

- **Асинхронный** — требует запросов к API
- **Может устареть** — данные на сервере могут измениться
- **Требует кеширования** — чтобы не делать лишние запросы
- **Требует синхронизации** — нужно обновлять при изменениях
- **Требует фоновых обновлений** — для актуальности данных

### Почему useState не подходит для Server State

Когда разработчики используют `useState` для серверных данных, они сталкиваются с множеством проблем:

- **Нет кеширования** — каждый компонент делает свой запрос
- **Нет синхронизации** — изменения в одном месте не видны в другом
- **Много бойлерплейта** — нужно писать loading, error, retry логику вручную
- **Нет фоновых обновлений** — данные устаревают
- **Нет optimistic updates** — UI тормозит при ожидании сервера

Эти проблемы решаются специализированными библиотеками вроде TanStack Query.

### Примеры Server State

- Список пользователей
- Данные профиля
- Посты и комментарии
- Товары в каталоге
- Любые данные с API

---

## 52.3. Разделение типов состояния

### Правильное разделение

```tsx
function Dashboard() {
  // Server state (TanStack Query)
  const { data: users } = useUsers()
  const { data: posts } = usePosts()

  // Client state (Zustand)
  const sidebarOpen = useUIStore((state) => state.sidebarOpen)
  const toggleSidebar = useUIStore((state) => state.toggleSidebar)

  // Local state (useState)
  const [selectedTab, setSelectedTab] = useState('overview')

  return (
    <div>
      {sidebarOpen && <Sidebar />}
      {/* ... */}
    </div>
  )
}
```

### Когда что использовать

**Server State → TanStack Query:**

- Данные с API
- Требуют кеширования
- Могут устареть
- Нужны фоновые обновления

**Client State → Zustand/Context:**

- UI состояние (тема, сайдбар)
- Временное состояние
- Не требует синхронизации с сервером

**Local State → useState:**

- Состояние внутри компонента
- Не требует глобального доступа
- Простая логика

---

## 52.4. Почему важно разделять типы состояния

Смешивание Server State и Client State — частая ошибка, которая приводит к:

- **Дублированию запросов** — каждый компонент загружает данные отдельно
- **Рассинхронизации** — обновление в одном компоненте не отражается в другом
- **Сложному коду** — приходится писать много бойлерплейта для loading/error/retry
- **Плохому UX** — нет фоновых обновлений и optimistic updates

**Правильный подход:** используйте TanStack Query для Server State, а useState/Zustand для Client State. Это обеспечивает автоматическое кеширование, синхронизацию между компонентами и минимум кода.

---

## 52.5. Гибридные случаи

Иногда данные могут быть и Server, и Client State:

### Пример: фильтры (производное состояние)

В современных приложениях клиентское состояние часто является **производным от серверного**. Например, локальный поиск по кешированным данным:

```typescript
// Server State: список пользователей (кешируется TanStack Query)
const { data: users } = useUsers()

// Client State: фильтры (применяются локально к кешированным данным)
const [filter, setFilter] = useState('active')

const filteredUsers = useMemo(() => {
  return users?.filter((user) => user.status === filter) ?? []
}, [users, filter])
```

**Важно:** фильтры применяются к уже загруженным данным из кеша, без дополнительных запросов к серверу.

### Пример: редактирование

```typescript
// Server State: исходные данные
const { data: user } = useUser(id)

// Client State: локальные изменения (до сохранения)
const [editedUser, setEditedUser] = useState(user)

useEffect(() => {
  setEditedUser(user)
}, [user])
```

---

## 52.6. Критическое предостережение: не синхронизируйте вручную

**Никогда не пытайтесь синхронизировать Server State и Client State вручную** (например, копировать данные из Query в Zustand через `useEffect`). Это нарушает принцип **«единственного источника правды»**.

### ❌ Плохо: ручная синхронизация

```typescript
// ОПАСНО: дублирование данных
const { data: users } = useUsers()

useEffect(() => {
  // Копируем данные из Query в Zustand
  useUsersStore.setState({ users })
}, [users])
```

**Проблемы:**
- Дублирование данных в памяти
- Риск рассинхронизации
- Лишние ререндеры
- Сложность поддержки

### ✅ Правильно: разделение ответственности

```typescript
// Server State: данные с API (TanStack Query)
const { data: users } = useUsers()

// Client State: только UI-логика (Zustand)
const sidebarOpen = useUIStore((state) => state.sidebarOpen)
const toggleSidebar = useUIStore((state) => state.toggleSidebar)

// Используем данные напрямую из Query
return (
  <div>
    {sidebarOpen && <Sidebar />}
    {users?.map((user) => <UserCard key={user.id} user={user} />)}
  </div>
)
```

**Правило:** Zustand — для UI-логики (тема, модалки, сайдбар). TanStack Query — для кеширования API. Не смешивайте их.

---

## Вопросы на собеседовании

### 1. В чём разница между Server State и Client State?

Server State — асинхронные данные с сервера, могут устареть, требуют кеширования. Client State — синхронное состояние приложения, контролируется нами, не устаревает.

### 2. Почему не стоит использовать useState для Server State?

Нет кеширования, синхронизации, фоновых обновлений, много бойлерплейта.

### 3. Какие инструменты использовать для Server State?

TanStack Query — стандарт для управления серверным состоянием.

### 4. Какие инструменты использовать для Client State?

useState для локального, Zustand/Context для глобального.

### 5. Когда использовать Context API, а когда Zustand?

Context API для редко меняющихся данных (тема, язык). Zustand для частых обновлений и лучшей производительности.
