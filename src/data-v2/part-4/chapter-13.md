# Глава 13. CSS основы: каскад, специфичность, наследование, слои, бокс-модель и поток документа

Эта глава формирует базу для профессиональной работы с вёрсткой. Даже Senior-фронтендеры регулярно попадают в ловушки из-за неправильного понимания потоков, специфичности и механики layout.

Если HTML — это скелет, то CSS — это материалы и геометрия: размеры, цвета, сетки, отступы, размещение элементов. Проблема новичков и даже мидлов в том, что CSS кажется магией: почему-то блок прыгает, почему-то не центрируется, почему-то Grid не работает так, как в примере.

На самом деле CSS — это строгая система, и если понять её фундамент, то верстка становится предсказуемой, как математика.

CSS — это язык вычисления стилей, а не просто набор свойств. Браузер постоянно вычисляет:

- где находится элемент
- сколько он занимает
- какие правила к нему применяются
- как он реагирует на изменения структуры

Чтобы писать оптимальный и предсказуемый код, нужно глубоко понимать эти механизмы.

---

## 13.1. Бокс-модель и поток документа

Каждый элемент в CSS — это прямоугольная коробка (box). Абсолютно каждый: div, span, button, img, даже текстовые строки.

**Состав box-модели:**

margin → border → padding → content

**Итого размер элемента:**

`width + padding + border + margin`

**Почему это важно?**

Потому что 80% «непонятных» багов верстки происходят из-за того, что разработчик не учитывает, что padding/border расширяют коробку.

### box-sizing

**По умолчанию:**

`box-sizing: content-box;`

Т.е. width задаёт только content, padding и border прибавляются.

**Современная практика:**

```css
* {
  box-sizing: border-box;
}
```

Это делает расчёты проще и верстку предсказуемей. Поэтому почти все проекты начинают с этого.

border-box: width включает padding и border.

`width = content + padding + border`

Это уменьшает количество сюрпризов.

### Поток документа (Document Flow)

Поток документа — это порядок, в котором элементы располагаются на странице по умолчанию.

**Блочные элементы (block):**

- Занимают всю доступную ширину
- Начинаются с новой строки
- Вертикально выстраиваются друг за другом

**Строчные элементы (inline):**

- Занимают только необходимое пространство
- Не начинают новую строку
- Горизонтально выстраиваются друг за другом

**Поток нарушается при:**

- `position: absolute` / `fixed` — элемент удаляется из потока
- `float` — элемент выходит из потока (устаревший подход)
- `display: none` — элемент полностью исключается

---

## 13.2. Специфичность, наследование, каскад

CSS = Cascading Style Sheets.

**Каскад — набор правил:**

Если несколько селекторов претендуют на один элемент, применяется тот, что:

1. выигрывает по специфичности
2. если равны — тот, что ниже по порядку (позже в файле)
3. если есть !important — оно побеждает всё, но использовать его нужно осторожно

### Специфичность

Система весов селекторов:

**inline-style** — вес 1000

**#id** — вес 100

**.class, [attr], pseudo-class** — вес 10

**tag, pseudo-element** — вес 1

**Пример:**

`#header .menu li a { ... }`

Вес = 100 + 10 + 1 + 1 = 112

**Важно:** Специфичность не складывается линейно. Например, 11 классов не победят один ID (100 > 110 в старой системе, но в реальности ID всегда побеждает).

**Современная система специфичности:**

- (0, 0, 0, 0) — четыре числа
- Первое: inline styles
- Второе: IDs
- Третье: классы, атрибуты, псевдоклассы
- Четвёртое: элементы, псевдоэлементы

**Примеры:**

```css
/* (0, 0, 0, 1) */
div { }

/* (0, 0, 1, 0) */
.class { }

/* (0, 1, 0, 0) */
#id { }

/* (1, 0, 0, 0) */
style="..." (inline)
```

### Наследование

**Некоторые свойства наследуются автоматически:**

- font-size
- color
- line-height
- font-family
- text-align
- visibility

**Другие никогда не наследуются:**

- padding
- margin
- border
- background
- width/height
- position

**Принудительное наследование:**

```css
.child {
  color: inherit; /* Явно наследует от родителя */
}
```

### Приоритеты в каскаде

1. user-agent stylesheet (браузер)
2. ваш CSS
3. inline-стили
4. !important

**!important:**

```css
.button {
  color: red !important; /* Побеждает всё */
}
```

⚠️ Использовать только в крайних случаях. Усложняет поддержку и отладку.

---

## 13.3. Каскадные слои (CSS Cascade Layers)

Это один из самых больших апдейтов CSS за последние годы.

**Проблема старая:** когда проект растёт, порядок подключения файлов превращается в ад. Ты можешь подключать стили в нужной последовательности, но один маленький CSS от компонента ломает всю страницу.

Cascade Layers решают эту проблему.

**Как это выглядит:**

```css
@layer reset, base, components, utilities;

@layer reset {
  * {
    margin: 0;
    padding: 0;
  }
}

@layer base {
  body {
    font-family: sans-serif;
  }
}

@layer components {
  .btn {
    padding: 8px 12px;
  }
}

@layer utilities {
  .btn {
    padding: 16px; /* Побеждает, т.к. utilities объявлен позже */
  }
}
```

Приоритет зависит не от порядка объявления правил, а от порядка слоёв.

**Почему это революция?**

Теперь структура приоритетов стилей:

1. пользовательские стили (user styles)
2. авторские стили (author styles)
3. каскадные слои
4. важность: !important
5. специфичность
6. порядок объявления

Впервые за 25 лет CSS в середину каскада добавили ещё один уровень управления. Это делает большие проекты гораздо проще.

**Использование:**

```css
/* Объявление слоёв */
@layer reset, base, components, utilities;

/* Импорт в слои */
@import url('reset.css') layer(reset);
@import url('components.css') layer(components);

/* Анонимные слои */
@layer {
  .custom { }
}
```

Используется в design-system'ах и UI-библиотеках.

---

## 13.4. Margin collapsing

Margin collapsing — это особенность CSS, когда вертикальные margin'ы соседних элементов «схлопываются».

**Пример:**

```css
h1 {
  margin-bottom: 20px;
}

p {
  margin-top: 30px;
}
```

Между h1 и p будет не 50px, а **30px** (больший margin).

**Когда происходит:**

- Вертикальные margin'ы соседних элементов
- Родитель и первый/последний ребёнок
- Пустые элементы

**Как избежать:**

- Использовать padding вместо margin
- Использовать flexbox/grid (у них нет margin collapsing)
- Использовать border или padding на родителе
- Использовать `display: flow-root` на родителе

---

## Вопросы на собеседовании

### 1. Объясните бокс-модель

content + padding + border + margin. box-sizing изменяет расчёт.

### 2. Что делает box-sizing: border-box?

width включает padding и border, что делает расчёты проще и верстку предсказуемей.

### 3. Как работает специфичность?

Система весов селекторов: inline-style (1000) > #id (100) > .class (10) > tag (1).

### 4. Что такое каскадные слои?

Механизм управления приоритетами стилей через уровни (layers), независимо от порядка подключения.

### 5. Какие свойства наследуются в CSS?

font-size, color, line-height, font-family, text-align и другие текстовые свойства.

### 6. Что такое margin collapsing?

Особенность CSS, когда вертикальные margin'ы соседних элементов «схлопываются» до большего значения.

### 7. Когда использовать !important?

Только в крайних случаях: для переопределения сторонних библиотек или критических стилей. Избегать в собственном коде.

---

## Key Takeaways

- CSS — строгая система, а не хаос
- Бокс-модель и box-sizing — основа стабильной верстки
- Специфичность определяет, какое правило применится при конфликте
- Каскадные слои дают новый уровень контроля над приоритетами
- Наследование работает только для определённых свойств
- Margin collapsing может вызывать неожиданное поведение
- Понимание каскада критично для работы с большими проектами

