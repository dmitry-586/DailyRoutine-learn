# Глава 26. Event Loop

Event Loop нужен, чтобы понимать **порядок выполнения** в браузере: почему “таймер 0ms” не срабатывает мгновенно, почему промисы часто выполняются раньше таймеров, и почему иногда интерфейс “замирает”.

---

## 26.1. Базовая модель

Есть три сущности:

- **Call Stack** — место, где выполняется текущий синхронный код.
- **Очереди задач** — место, куда попадают коллбеки, которые надо выполнить позже.
- **Event Loop** — механизм, который берёт задачи из очередей и запускает их, когда стек пуст.

Главная мысль:

> Пока Call Stack не пуст, ничего “параллельно” в этом же потоке не выполнится.

---

## 26.2. Два типа очередей: microtasks и tasks

### Tasks

Это “обычные” отложенные задачи.

Чаще всего вы видите их как:

- `setTimeout`, `setInterval`
- обработчики событий (`click`, `input`, `scroll` и т.п.)

### Microtasks

Это задачи “сразу после текущего кода”.

Примеры:

- `Promise.then/catch/finally`
- `queueMicrotask`
- `MutationObserver`

### Правило порядка

Когда синхронный код закончился, движок:

1. выполняет все microtasks, которые успели накопиться
2. берёт следующую task и выполняет её
3. снова выполняет все microtasks, которые появились во время этой task

Из этого и получается эффект “промис обгоняет setTimeout”.

---

## 26.3. Два базовых примера

### Пример 1: Promise раньше таймера

```javascript
console.log(1)
setTimeout(() => console.log(2), 0)
Promise.resolve().then(() => console.log(3))
console.log(4)
```

Порядок: `1, 4, 3, 2`

### Пример 2: microtask внутри таймера

```javascript
console.log(1)
setTimeout(() => {
  console.log(2)
  Promise.resolve().then(() => console.log(3))
}, 0)
console.log(4)
```

Порядок: `1, 4, 2, 3`

---

## 26.4. Нестандартные случаи, которые часто путают

### 1. Microtasks могут “задушить” интерфейс

Если вы постоянно добавляете microtasks, браузер может долго не дойти до следующей task и не успеть перерисовать UI.

```javascript
function loop() {
  Promise.resolve().then(loop)
}
loop()
```

Эта штука может “зависить” вкладку, хотя явного бесконечного `while` нет.

Идея: **microtasks выполняются до конца**, поэтому их нельзя бесконтрольно генерировать.

### 2. `async/await` тоже “перекидывает” выполнение в microtasks

`await` не блокирует поток, но переносит продолжение функции “на потом” через microtask.

```javascript
async function f() {
  console.log(1)
  await Promise.resolve()
  console.log(2)
}
f()
console.log(3)
```

Порядок: `1, 3, 2`

### 3. `setTimeout(fn, 0)` не означает “сразу”

Даже без промисов, таймер не может выполниться, пока не завершится текущий синхронный код.

Плюс есть технические ограничения:

- браузеры могут задавать минимальную задержку таймеров
- во вкладке в фоне таймеры могут выполняться реже

Из-за этого “0ms” может стать заметно больше в реальности.

### 4. `requestAnimationFrame` живёт рядом с отрисовкой

Если ваша задача связана с анимацией или обновлением DOM перед кадром, используют `requestAnimationFrame`.
Он планирует коллбек “к следующему кадру” и обычно выполняется перед отрисовкой.

Это не замена промисам и не замена таймерам, а отдельный инструмент под рендеринг.

### 5. Почему порядок иногда кажется странным

Частая причина — вы одновременно используете несколько механизмов планирования:

- `Promise.then` (microtask)
- `setTimeout` (task)
- DOM события (task)
- `requestAnimationFrame` (перед кадром)

Чтобы не путаться, держите в голове правило: **после текущего синхронного кода сначала “чистятся” microtasks**, и только потом выполняются следующие tasks.

---

## Вопросы на собеседовании

### 1. Что такое Event Loop?

Механизм, который запускает отложенные задачи из очередей, когда Call Stack пуст.

### 2. Чем отличаются microtasks и tasks?

Microtasks выполняются раньше: после синхронного кода выполняются все накопившиеся microtasks, и только потом — следующая task.

### 3. Почему таймер с 0ms не “мгновенный”?

Потому что это task: она выполнится только после завершения текущего синхронного кода и после выполнения microtasks. Плюс браузер может ограничивать частоту таймеров.

# Глава 26. Event Loop

Event Loop нужен, чтобы понять **порядок выполнения**: почему “таймер с 0ms” не срабатывает сразу и почему промисы часто “обгоняют” `setTimeout`.

---

## 26.1. Три вещи, которые достаточно знать

1. **Call Stack** — выполняется синхронный код (строка за строкой).
2. **Очереди задач** — туда попадают коллбеки, которые надо выполнить позже.
3. **Event Loop** — запускает задачи из очередей, когда стек пуст.

---

## 26.2. Microtasks vs Macrotasks (практический минимум)

### Macrotasks (очередь “обычных задач”)

Примеры:

- `setTimeout`, `setInterval`
- события (клик, input и т.п.)

### Microtasks (очередь “сразу после текущего кода”)

Примеры:

- `Promise.then/catch/finally`
- `queueMicrotask`
- `MutationObserver`

### Главное правило

> После завершения текущего синхронного кода движок **сначала выполняет все microtasks**, и только потом берёт следующую macrotask.

---

## 26.3. Понятная визуализация

```
Синхронный код выполняется в Call Stack
          │
          ▼ (когда стек пуст)
   выполняем ВСЕ microtasks
          │
          ▼
   выполняем ОДНУ macrotask
          │
          └── повторяем цикл
```

Запоминалка: **stack → microtasks (все) → macrotask (одна) → microtasks (все) → ...**

---

## 26.4. Примеры (2 штуки, чтобы стало ясно)

### Пример 1: Promise “обгоняет” setTimeout

```javascript
console.log(1)

setTimeout(() => console.log(2), 0)

Promise.resolve().then(() => console.log(3))

console.log(4)
```

Порядок: `1, 4, 3, 2`

Почему:

- `1` и `4` — синхронно
- `then` — microtask → выполнится раньше
- `setTimeout` — macrotask → после microtasks

### Пример 2: microtask внутри macrotask

```javascript
console.log(1)

setTimeout(() => {
  console.log(2)
  Promise.resolve().then(() => console.log(3))
}, 0)

console.log(4)
```

Порядок: `1, 4, 2, 3`

Почему:

- сначала синхронно `1, 4`
- потом macrotask (таймер) печатает `2`
- и только затем microtask из `then` печатает `3`

---

## Вопросы на собеседовании

### 1. Что такое Event Loop?

Механизм, который запускает отложенные задачи (из очередей) **когда Call Stack пуст**.

### 2. Чем microtask отличается от macrotask?

Microtasks выполняются **раньше**: после синхронного кода сначала выполняются **все microtasks**, и только потом — следующая macrotask.

### 3. Почему `setTimeout(fn, 0)` не “сразу”?

Потому что это macrotask: она выполнится только когда завершится текущий синхронный код и будут выполнены microtasks.

