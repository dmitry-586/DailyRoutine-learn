# Глава 63. Архитектурные договоренности: Evolution Design (ED)

Evolution Design — методология масштабирования фронтенд-приложений, основанная на когнитивных ограничениях человеческого мозга и прагматичном подходе. Вместо фиксированных правил ED предлагает систему принятия решений, которая позволяет архитектуре эволюционировать вместе с проектом.

---

## 63.1. Когнитивная база: Кошелек Миллера

Архитектура строится на ограничении человеческого мозга: мы можем удерживать в фокусе одновременно только **7±2 абстракции** (правило Миллера).

**Практическое применение:** Любой модуль или папка, где больше 6–7 элементов, становится сложным для понимания. Если в папке больше 7 файлов — пора декомпозировать. Если в компоненте больше 7 пропсов — пора разбить на части. Если в функции больше 7 параметров — пора использовать объект.

**Правило:** Если структура не помещается в «кошелек Миллера» — декомпозируй.

---

## 63.2. Четыре слоя Evolution Design

ED определяет четыре основных слоя приложения.

**App** — точка входа, самая часто меняющаяся логика. Содержит маршрутизацию, провайдеры (QueryClient, Theme, Auth), глобальные обработчики ошибок, конфигурацию приложения. Меняется чаще всего, зависит от всех остальных слоёв, не содержит бизнес-логику.

**Features** — крупные независимые куски функционала, которые решают конкретную бизнес-задачу. Важное отличие от FSD: в ED код страниц и виджеты живут внутри фич, а не в отдельных слоях. Содержит компоненты фичи, хуки для работы с данными, API-вызовы, страницы и виджеты. Фичи независимы друг от друга, прямые импорты между фичами запрещены, взаимодействие через инверсию зависимостей (события, контекст).

**Структура фичи:**
```
features/
├── auth/
│   ├── api/
│   │   └── login.ts
│   ├── hooks/
│   │   └── useAuth.ts
│   ├── components/
│   │   ├── LoginForm.tsx
│   │   └── LogoutButton.tsx
│   └── pages/
│       └── LoginPage.tsx
└── products/
    ├── api/
    ├── hooks/
    ├── components/
    └── pages/
        └── ProductsPage.tsx
```

**Services** — переиспользуемые бизнес-модули, которые используются несколькими фичами. Отличие от Features: Services не привязаны к конкретной странице или виджету. Содержат бизнес-логику (например, управление сессией), могут содержать UI (модальные окна, уведомления), API-клиенты для конкретных доменов, утилиты для работы с данными. Не зависят от слоя App.

**Структура сервиса:**
```
services/
├── session/
│   ├── api/
│   ├── hooks/
│   └── components/
│       └── SessionModal.tsx
├── notifications/
│   ├── api/
│   └── hooks/
└── analytics/
    └── lib/
```

**Shared** — ядро приложения, фундамент, который не зависит ни от чего выше. Содержит бизнес-типы и интерфейсы, UI-kit (базовые компоненты), API-клиент (базовая настройка), утилиты (форматирование, валидация), константы. Это опасный слой — изменения здесь влияют на всё приложение. Не может импортировать ничего из features, services или app. Должен быть максимально стабильным.

**Структура shared:**
```
shared/
├── ui/
│   ├── Button/
│   ├── Input/
│   └── Modal/
├── lib/
│   ├── api/
│   │   └── client.ts
│   └── utils/
│       ├── formatDate.ts
│       └── validateEmail.ts
└── types/
    └── common.ts
```

---

## 63.3. Эволюция модулей

Вместо фиксированной структуры ED предлагает эволюцию модуля по мере его роста. Модуль проходит через 4 стадии.

**Этап 1: Single file (до 400 строк)** — модуль может быть одним файлом, если он небольшой и понятный. Переход к этапу 2: когда файл превышает 400 строк или становится сложным для понимания.

```
features/auth/login.ts  # Всё в одном файле
```

**Этап 2: Flat module (до 6 файлов)** — модуль разделяется на несколько файлов в одной папке с `index.ts` как Public API. Не больше 6–7 файлов в папке (кошелек Миллера).

```
features/auth/
├── index.ts          # Public API
├── api.ts            # API-вызовы
├── hooks.ts          # Кастомные хуки
├── components.tsx    # Компоненты
└── types.ts          # Типы
```

**Этап 3: Grouped module** — используется стандартная структура с группами: `ui` (компоненты интерфейса), `model` (бизнес-логика, состояние, хуки), `lib` (утилиты, хелперы), `api` (API-вызовы). Каждая группа не должна содержать больше 6–7 файлов.

```
features/auth/
├── index.ts          # Public API
├── ui/               # UI-компоненты
│   ├── LoginForm.tsx
│   └── LogoutButton.tsx
├── model/            # Бизнес-логика
│   ├── hooks.ts
│   └── store.ts
├── lib/              # Утилиты
│   └── validate.ts
└── api/              # API-слой
    ├── login.ts
    └── logout.ts
```

**Этап 4: Module with compose** — высшая стадия, где зависимости между частями модуля убираются через паттерны слабой связанности: слоты (компоненты принимают слоты для кастомизации), события (взаимодействие через события, а не прямые вызовы), контекст (общее состояние через контекст). Используется, когда модуль становится слишком большим и части нужно слабо связать для переиспользования.

---

## 63.4. Правила взаимодействия (Архитектурные границы)

ED определяет строгие правила импортов между слоями, чтобы избежать циклических зависимостей.

**Правило 1: Запрет импорта из App.** Фичи и сервисы не могут зависеть от слоя App. App — это точка входа, которая меняется чаще всего. Зависимость от App создаёт хрупкую архитектуру. Используйте инверсию зависимостей — хуки из библиотек напрямую, а не через App.

**Правило 2: Изоляция фич.** Прямые импорты между фичами запрещены. Фичи должны быть независимыми. Взаимодействие через: Shared (общая логика выносится в shared), Services (переиспользуемая бизнес-логика), события (фичи общаются через Event Bus), контекст (общее состояние через React Context).

**Правило 3: Shared как фундамент.** Слой Shared не может импортировать ничего из features, services или app. Shared — это фундамент. Если он зависит от верхних слоёв, возникает циклическая зависимость. Типы должны быть в Shared, а не в Features.

**Диаграмма зависимостей:** App зависит от всех слоёв. Features зависит от Services и Shared. Services зависит только от Shared. Shared не зависит ни от чего. Импорты идут только вниз по этой диаграмме.

---

## 63.5. Прагматизм: когда что использовать

ED не требует сразу строить сложную архитектуру. Структура должна эволюционировать вместе с проектом.

**Маленький проект (1–3 страницы):** Минимум абстракций, всё в одном месте, быстрая разработка.

```
src/
├── components/
├── pages/
└── utils/
```

**Средний проект (5–10 страниц):** Появились фичи, общий код в shared, структура ещё простая.

```
src/
├── features/
│   ├── auth/
│   └── products/
├── shared/
│   ├── ui/
│   └── lib/
└── pages/
```

**Большой проект (команда, много фич):** Полная структура ED, чёткое разделение слоёв, сложная архитектура оправдана.

```
src/
├── app/
├── features/
├── services/
└── shared/
```

**Правило:** Не внедряйте сложную архитектуру «на будущее». Начните с простого и усложняйте по мере необходимости.

---

## 63.6. Метрики: когда пора менять структуру

Отслеживайте, как структура влияет на скорость разработки: скорость разработки новых фич, количество конфликтов, понятность кода новым людям.

**Сигналы для изменения:** Сложно найти файлы — пора реорганизовать. Много дублирования — пора вынести в Shared или Services. Команда путается — пора стандартизировать структуру. Папка больше 7 элементов — пора декомпозировать (кошелек Миллера).

**Правило:** Если структура начинает мешать разработке — меняйте её. Рефакторинг структуры — нормальный процесс.

---

## Вопросы на собеседовании

### 1. Что такое Evolution Design?

Методология масштабирования фронтенд-приложений, основанная на когнитивных ограничениях (правило Миллера) и прагматичном подходе. Архитектура эволюционирует вместе с проектом, а не навязывается с самого начала.

### 2. Что такое "Кошелек Миллера" и как это применяется в ED?

Правило о том, что человек может удерживать в фокусе 7±2 абстракции одновременно. В ED это означает: если в папке больше 6–7 элементов, пора декомпозировать. Это основа для принятия решений о структуре.

### 3. Какие четыре слоя в ED и чем они отличаются от FSD?

App — точка входа, провайдеры, роутинг. Features — законченные части функционала (в ED страницы и виджеты живут внутри фич). Services — переиспользуемые бизнес-модули. Shared — ядро приложения, не зависит ни от чего.

### 4. Как эволюционирует модуль в ED?

Четыре этапа: 1) Single file (до 400 строк), 2) Flat module (до 6 файлов), 3) Grouped module (стандартные группы ui/model/lib/api), 4) Module with compose (слабая связанность через слоты, события).

### 5. Какие правила взаимодействия между слоями?

1) Фичи и сервисы не могут импортировать из App. 2) Прямые импорты между фичами запрещены — взаимодействие через Shared, Services, события или контекст. 3) Shared не может импортировать из верхних слоёв.

### 6. В чём разница между ED и FSD?

FSD — конкретная методология с фиксированными слоями. ED — философия эволюции архитектуры, которая может использовать FSD на определённом этапе. ED фокусируется на прагматизме и когнитивных ограничениях.

### 7. Когда пора менять структуру проекта?

Когда структура начинает мешать: сложно найти файлы, много дублирования, команда путается, папка больше 7 элементов. Метрики: скорость разработки, количество конфликтов, понятность кода новым людям.
