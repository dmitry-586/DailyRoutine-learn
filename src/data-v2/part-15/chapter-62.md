# Глава 62. Архитектура фронтенда: разделение ответственности и FSD

Когда приложение растёт, становится критически важно организовать код так, чтобы он оставался понятным, масштабируемым и поддерживаемым.

---

## 62.1. Разделение ответственности

React предлагает компонентную модель, но важно правильно разделять ответственность.

**Презентационные компоненты** отвечают только за отображение, получают данные через props, не содержат бизнес-логику и легко переиспользуются.

**Контейнерные компоненты** содержат бизнес-логику, управляют состоянием, загружают данные и передают их в презентационные компоненты.

---

## 62.2. SOLID принципы

SOLID — пять принципов объектно-ориентированного программирования, применимых и к React.

**Single Responsibility:** Один компонент — одна ответственность (отображение ИЛИ логика). Кастомные хуки для переиспользования логики.

**Open/Closed:** Композиция вместо наследования. Пропсы для кастомизации вместо хардкода.

**Liskov Substitution:** Специализированные компоненты должны работать так же, как базовый компонент, не нарушая ожиданий.

**Interface Segregation:** Маленькие, сфокусированные интерфейсы пропсов. Композиция компонентов вместо монолитных.

**Dependency Inversion:** Кастомные хуки как абстракции. Dependency Injection через Context.

---

## 62.3. Feature-Sliced Design (FSD)

Feature-Sliced Design — методология структурирования фронтенда.

**Основные слои:** `app/` — инициализация приложения (провайдеры, роутинг). `pages/` — страницы приложения. `features/` — фичи (законченные части функционала). `entities/` — бизнес-сущности (типы, API, хуки). `shared/` — переиспользуемый код (UI-kit, утилиты, API-клиент). `widgets/` — композиция фич в виджеты.

**Правила FSD:** Импорты только вниз — слой может импортировать только из слоёв ниже. Изоляция фич — фичи не зависят друг от друга. Переиспользование — shared для общего кода. Композиция — widgets собирают фичи вместе.

### Пример структуры FSD

```
src/
├── app/
│   ├── layout.tsx
│   └── providers/
│       ├── QueryProvider.tsx
│       └── ThemeProvider.tsx
├── pages/
│   ├── HomePage/
│   └── ProfilePage/
├── features/
│   ├── auth/
│   │   ├── api/
│   │   │   └── loginUser.ts
│   │   ├── hooks/
│   │   │   └── useAuth.ts
│   │   └── components/
│   │       ├── LoginForm.tsx
│   │       └── LogoutButton.tsx
│   └── comments/
│       ├── api/
│       ├── hooks/
│       └── components/
├── entities/
│   ├── user/
│   │   ├── types.ts
│   │   ├── api.ts
│   │   └── hooks.ts
│   └── post/
│       ├── types.ts
│       ├── api.ts
│       └── hooks.ts
├── shared/
│   ├── ui/
│   │   ├── Button/
│   │   └── Input/
│   ├── lib/
│   │   └── utils.ts
│   └── api/
│       └── axios.ts
└── widgets/
    ├── Header/
    └── Sidebar/
```

---

## 62.4. Управление состоянием

**Server State** — данные с сервера. Используйте TanStack Query для автоматического кеширования, фоновых обновлений и retry логики.

**Client State** — UI состояние. Используйте Zustand или Context API для глобального состояния (theme, sidebar) и временного состояния (modals, forms).

**Local State** — локальное состояние компонента. Используйте `useState` или `useReducer` для состояния внутри компонента, которое не требует глобального доступа.

---

## 62.5. Бизнес-слой в кастомных хуках

Вместо прямой логики в компонентах создавайте хуки, которые оркеструют работу Zustand и TanStack Query. Компонент должен быть «глупым» и только вызывать этот хук.

**Преимущества:** Компонент фокусируется только на отображении. Бизнес-логика переиспользуема. Легко тестировать (хук отдельно от компонента). Проще поддерживать и модифицировать.

---

## 62.6. Структура проекта

### Рекомендуемая структура FSD

```
src/
├── app/                    # Next.js App Router
│   ├── layout.tsx
│   ├── page.tsx
│   └── (routes)/
├── features/               # Фичи
│   ├── auth/
│   │   ├── api/
│   │   ├── hooks/
│   │   └── components/
│   └── products/
├── entities/              # Бизнес-сущности
│   ├── user/
│   └── product/
├── shared/                # Переиспользуемый код
│   ├── ui/               # UI компоненты
│   ├── lib/              # Утилиты
│   └── api/              # API клиент
└── widgets/               # Виджеты
    ├── Header/
    └── Sidebar/
```

### Правила организации

1. **Один файл — одна ответственность**
2. **Именование по функциональности**, а не по типу
3. **Изоляция фич** — фичи не зависят друг от друга
4. **Переиспользование через shared**
5. **Композиция через widgets**

---

## Вопросы на собеседовании

### 1. Как организовать большую кодовую базу?

Разделение на слои (FSD), разделение ответственности, изоляция фич.

### 2. В чём разница между Presentational и Container компонентами?

Presentational — только отображение, Container — логика и состояние.

### 3. Что такое Feature-Sliced Design?

Методология структурирования фронтенда с разделением на слои: app, pages, features, entities, shared, widgets.

### 4. Как разделять типы состояния?

Server state → TanStack Query, Client state → Zustand/Context, Local state → useState.

### 5. Что такое SOLID принципы?

Пять принципов проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. Помогают писать поддерживаемый и масштабируемый код.

### 6. Как применить SOLID в React?

Single Responsibility: разделение компонентов на презентационные и контейнерные. Open/Closed: расширяемость через пропсы и композицию. Dependency Inversion: хуки как абстракции вместо прямых зависимостей от API.
