# Глава 65. Грейды и ожидания: уровень ответственности, а не синтаксис

Грейды различаются не «знаниями терминов», а **уровнем ответственности и самостоятельности**. Junior знает синтаксис, Middle решает задачи, Senior проектирует системы. Это не про «сколько технологий в резюме», это про **системное мышление и способность принимать решения**.

Многие разработчики ошибаются, думая, что знание всех библиотек делает их Senior. На самом деле, Senior — это не про «знать всё», а про способность проектировать системы, которые могут эволюционировать. Junior может знать синтаксис React лучше, чем Senior, но Senior понимает, когда использовать React, а когда выбрать другой инструмент.

---

## Junior: закрывает задачи по инструкции

Junior — это не про «не знает React». Это про **уровень ответственности**: Junior закрывает задачи по инструкции, нуждается в частом код-ревью и подсказках, ошибается, но быстро учится.

Junior получает задачу с описанием и выполняет её. Каждое изменение требует проверки — код-ревью необходимо для каждого коммита. Ошибки неизбежны, но Junior быстро учится на обратной связи. Фокус на синтаксисе — знает, как писать код, но не всегда понимает, почему.

**Что важно:** Junior не должен проектировать архитектуру. Его задача — научиться писать качественный код под руководством. Это нормально — каждый Senior когда-то был Junior.

---

## Middle: сам решает типовые задачи

Middle — это не про «знает все библиотеки». Это про **самостоятельность**: Middle сам решает типовые задачи, предлагает варианты, видит риски и умеет планировать.

Middle не нуждается в постоянном контроле — может работать самостоятельно. Предлагает несколько подходов к решению задачи. Понимает последствия решений и видит риски. Поддерживает качество кода и процессов — следит за стандартами команды.

**Критически важно для Middle:** чёткое разделение Server State и Client State. Middle понимает, что их нельзя синхронизировать вручную через `useEffect`. Использует TanStack Query для серверного состояния, Zustand или Context для клиентского. Понимает компромиссы — знает, когда использовать тот или иной инструмент. Видит системные проблемы — не только баги, но и архитектурные проблемы.

**Что важно:** Middle должен уметь работать самостоятельно, но под общим руководством архитектуры. Это переходный этап от выполнения задач к их проектированию.

---

## Senior: проектирует системы, которые могут эволюционировать

Senior — это не про «знает всё». Это про **системное мышление**: Senior отвечает за архитектуру и технические решения, ведёт сложные обсуждения и менторит, влияет на продукт и процессы команды.

Senior проектирует систему, а не просто пишет код. Помогает команде расти через менторство и обсуждения. Влияет не только на технические решения, но и на процессы команды.

**Критически важно для Senior:** архитектурная гибкость через Evolution Design. Senior демонстрирует понимание, что архитектура должна эволюционировать вместе с проектом. Вместо догматичного следования паттернам («делаем только так»), применяет **Evolution Design**: строит систему, которая может развиваться постепенно, не перегружая проект сложностью на старте.

Понимает принцип **«Everything is a Trade-off»** — каждый выбор должен быть обоснован контекстом проекта. Не внедряет FSD в лендинг, но закладывает возможность его внедрения позже. Системное мышление — видит не только код, но и процессы, команду, продукт.

**Главная мысль:** Senior не строит замок сразу. Он проектирует систему, которая может эволюционировать.

---

## Как обычно оценивают: не технологии, а мышление

Оценка грейда — это не про «сколько технологий в резюме». Это про уровень самостоятельности — может ли разработчик работать без постоянного контроля. Качество решений и их аргументация — не просто «использовал Zustand», а «Zustand подошёл лучше Redux в этом контексте, потому что меньше бойлерплейта». Умение видеть риски и планировать — понимает ли последствия решений.

Это важнее списка технологий в резюме. Можно знать все библиотеки, но не понимать, когда что использовать. Можно не знать конкретную библиотеку, но быстро разобраться, потому что понимаешь принципы.

---

## Что важнее, чем «знание фреймворка»

Понимание продукта и приоритетов важнее знания синтаксиса. Не просто «знаю React», а «понимаю, как React помогает решить бизнес-задачи». Умение объяснять решения — может обосновать выбор инструмента контекстом проекта. Способность учиться на ошибках — не повторяет одни и те же ошибки.

---

## Признаки роста: от задач к системам

Ты закрываешь задачи без постоянного контроля — можешь работать самостоятельно. Видишь системные проблемы, а не только баги — понимаешь, что проблема не в коде, а в архитектуре. Берёшь ответственность за качество — не просто «сделал задачу», а «сделал так, чтобы это не сломалось завтра».

---

## Переход между грейдами: не про «знать больше»

**Junior → Middle:** самостоятельность и стабильность. Не про «выучить больше библиотек», а про «научиться работать самостоятельно и стабильно». Важно не количество знаний, а способность применять их без помощи.

**Middle → Senior:** системность и влияние на решения. Не про «знать больше технологий», а про «видеть систему целиком и влиять на её развитие». Важно не знание всех инструментов, а понимание, когда что использовать.

Переход не про «знать больше», а про **«делать лучше»**.

---

## Что смотрят в резюме

Реальные проекты и вклад важнее списка технологий. Не просто «работал с React», а «построил архитектуру приложения на React, которая масштабировалась с 3 до 30 разработчиков». Роли и ответственность в команде — не просто «разработчик», а «отвечал за архитектуру фронтенда, менторил команду из 5 разработчиков». Понятные достижения, а не только список технологий — не просто «React, TypeScript, Next.js», а «оптимизировал бандл с 2 МБ до 200 КБ, улучшил время загрузки на 80%».

---

## Что важно на собеседовании

Как ты думаешь, а не только что знаешь. Не просто «знаю React», а «понимаю, почему React использует Virtual DOM и как это влияет на производительность». Как решаешь проблемы — не просто «использовал библиотеку X», а «выбрал библиотеку X, потому что она решает проблему Y лучше, чем альтернативы, учитывая контекст проекта». Как объясняешь решения — можешь обосновать выбор инструмента через принцип «Everything is a Trade-off».

---

## Самооценка: честный взгляд на себя

Определи, какие задачи ты решаешь без помощи — можешь ли работать самостоятельно. Посмотри, где чаще всего ошибаешься — это покажет слабые места. Сформируй план улучшений — не просто «выучить больше», а «научиться работать системно».

---

## Когда просить повышение

Ты стабильно выполняешь задачи уровня выше — не просто «делаю задачи», а «решаю задачи, которые обычно решают Middle/Senior». Команда доверяет тебе сложные решения — тебя просят помочь с архитектурой, не только с кодом. Ты влияешь на качество и процессы — не просто «пишу код», а «улучшаю процессы команды».

---

## Подготовка к следующему грейду

Собери список решённых сложных задач — не просто «сделал фичу», а «спроектировал архитектуру фичи, которая масштабировалась». Зафиксируй улучшения, которые сделал в проекте — не просто «использовал библиотеку», а «внедрил библиотеку, которая улучшила производительность на X%». Покажи инициативу в архитектуре и процессах — не просто «следовал правилам», а «предложил улучшение архитектуры, которое команда приняла».

---

## Заключение: как закрепить знания

Теория работает только тогда, когда её применяют.

### Что делать после курса

Собери небольшой проект целиком (лендинг + форма + API). **Анализ через Evolution Design:** разбери 1–2 чужих проекта и обоснуй архитектурные решения через призму **Evolution Design**. Почему в конкретном случае выбрана простая структура, а не жесткий FSD? Руководствуйся принципом **«Everything is a Trade-off»** — каждый выбор должен быть обоснован контекстом проекта.

**Валидация на границах:** внедри **Zod** для проверки не только форм, но и всех входящих данных от API и localStorage. Это гарантирует безопасность типов в runtime и защищает от невалидных данных на границах приложения. Выдели «слабые» темы и добей их практикой.

### Как расти быстрее

Пиши меньше, но качественнее — лучше один качественный проект, чем три «полуготовых». Читай чужие PR и обсуждения — учись на опыте других. Держи заметки по ошибкам и фиксируй их — не повторяй одни и те же ошибки.

### Цикл непрерывного улучшения

**Неделя как итерация:** практика → теория → рефлексия. **2 дня: практика кода** — маленький проект или улучшение существующего. **2 дня: повторение теории** — углубление в слабую тему, чтение документации. **1 день: рефлексия и выводы** — анализ ошибок, фиксация решений, планирование следующей итерации.

Так быстрее появляется уверенность и формируется привычка к постоянному росту.

---

## Собеседование: подготовка и поведение

Собеседование — это не экзамен, а диалог о том, как вы решаете задачи.

### Подготовка

Подготовь 2–3 проекта, о которых можешь говорить уверенно. Разбери типовые вопросы: сети, JS, React, архитектура. Прогони рассказ «что делал» по формуле: задача → действие → результат.

### Поведение на встрече

Сначала уточняй требования, потом отвечай — не угадывай, уточняй. Если не знаешь — скажи честно и объясни, как бы искал решение — честность важнее «знания всего». Думай вслух — интервьюер оценивает логику, а не только ответ.

### Структура ответа

Хорошая структура помогает выглядеть увереннее: уточнить вводные — не угадывай, уточняй контекст. Предложить решение — покажи, как думаешь. **Архитектурный диалог для Middle+:** объясни, почему выбран конкретный инструмент. Не просто «я использовал Zustand», а «Zustand подошёл лучше Redux в этом контексте, потому что меньше бойлерплейта и проще для PoC». Покажи понимание компромиссов и принципа **«Everything is a Trade-off»**. Обсудить риски и ограничения — покажи системное мышление. Подвести итог — резюмируй решение.

### Технические задания

Сначала проясни требования — не угадывай, уточняй. Оцени время и сложность — покажи планирование. Покажи промежуточный результат — демонстрируй процесс. Поясни принятые решения — обоснуй выбор инструментов.

Это важнее «идеального» кода.

### Актуальность TanStack Query v5

**Breaking Changes, которые важно знать:** **`cacheTime` → `gcTime`** — переименован для ясности (Garbage Collection Time). Интервьюер может спросить про `cacheTime`, и правильный ответ — в v5 он переименован в `gcTime`. **`isLoading` → `isPending`** — переименован для более точного описания состояния. `isPending` показывает первую загрузку (данных ещё нет в кэше), `isFetching` — любую загрузку, включая фоновую.

**Почему это важно:** знание breaking changes показывает, что вы следите за обновлениями библиотек и понимаете эволюцию инструментов.

### Безопасность Next.js

**Вопрос-ловушка про секреты:** все переменные **без префикса `NEXT_PUBLIC_`** доступны только на сервере — это база безопасности в App Router. Переменные с `NEXT_PUBLIC_` попадают в клиентский бандл и видны всем.

**Правило:** никогда не используй `NEXT_PUBLIC_` для секретов (API ключи, токены, пароли БД).

### Разбор Hydration Error

**Что это:** несоответствие HTML на сервере и клиенте. Одна из самых частых тем на интервью по Next.js.

**Причина:** компонент рендерится по-разному на сервере и клиенте (например, использует `localStorage`, `window`, или зависит от времени).

**Решение:** всегда рендери одинаковый HTML на сервере и клиенте, а клиент-специфичный контент показывай только после монтирования.

---

## Вопросы на собеседовании

### 1. В чём разница между Junior, Middle и Senior?

Junior закрывает задачи по инструкции, нуждается в контроле. Middle сам решает типовые задачи, предлагает варианты, видит риски. Senior проектирует системы, ведёт обсуждения, влияет на продукт и процессы. Разница не в «знании технологий», а в уровне ответственности и системном мышлении.

### 2. Что важно для Middle?

Чёткое разделение Server State и Client State, понимание компромиссов, умение работать самостоятельно, видение системных проблем, а не только багов.

### 3. Что важно для Senior?

Архитектурная гибкость через Evolution Design, понимание принципа «Everything is a Trade-off», системное мышление, способность проектировать системы, которые могут эволюционировать.

### 4. Как оценивают грейд?

По уровню самостоятельности, качеству решений и их аргументации, умению видеть риски и планировать. Это важнее списка технологий в резюме.

### 5. Когда просить повышение?

Когда стабильно выполняешь задачи уровня выше, команда доверяет сложные решения, влияешь на качество и процессы.
