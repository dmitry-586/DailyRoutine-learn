# Глава 67. Грейды и ожидания

Грейды различаются не «знаниями терминов», а уровнем ответственности и самостоятельности.

---

## 67.1. Junior

- Закрывает задачи по инструкции.
- Нуждается в частом код-ревью и подсказках.
- Ошибается, но быстро учится.

---

## 67.2. Middle

- Сам решает типовые задачи и предлагает варианты.
- **Чётко разделяет Server State и Client State:** понимает, что их нельзя синхронизировать вручную через `useEffect`. Использует TanStack Query для серверного состояния, Zustand/Context для клиентского.
- Видит риски и умеет планировать.
- Поддерживает качество кода и процессов.

---

## 67.3. Senior

- Отвечает за архитектуру и технические решения.
- **Архитектурная гибкость через Evolution Design:** демонстрирует понимание, что архитектура должна эволюционировать вместе с проектом. Вместо догматичного следования паттернам («делаем только так»), применяет **Evolution Design**: строит систему, которая может развиваться постепенно, не перегружая проект сложностью на старте. Понимает принцип **«Everything is a Trade-off»** и обосновывает выбор инструментов контекстом проекта.
- Ведёт сложные обсуждения и менторит.
- Влияет на продукт и процессы команды.

---

## 67.4. Как обычно оценивают

- Уровень самостоятельности.
- Качество решений и их аргументация.
- Умение видеть риски и планировать.

Это важнее списка технологий в резюме.

---

## 67.5. Что важнее, чем «знание фреймворка»

- Понимание продукта и приоритетов.
- Умение объяснять решения.
- Способность учиться на ошибках.

---

## 67.6. Признаки роста

- Ты закрываешь задачи без постоянного контроля.
- Видишь системные проблемы, а не только баги.
- Берёшь ответственность за качество.

---

## 67.7. Переход между грейдами

- Junior → Middle: самостоятельность и стабильность.
- Middle → Senior: системность и влияние на решения.

Переход не про «знать больше», а про «делать лучше».

---

## 67.8. Что смотрят в резюме

- Реальные проекты и вклад.
- Роли и ответственность в команде.
- Понятные достижения, а не только список технологий.

---

## 67.9. Что важно на собеседовании

- Как ты думаешь, а не только что знаешь.
- Как решаешь проблемы.
- Как объясняешь решения.

---

## 67.10. Самооценка

- Определи, какие задачи ты решаешь без помощи.
- Посмотри, где чаще всего ошибаешься.
- Сформируй план улучшений.

---

## 67.11. Мини-чек-лист роста

- Есть проекты с заметным вкладом.
- Есть опыт работы в команде.
- Есть понимание рисков и качества.

---

## 67.12. Когда просить повышение

- Ты стабильно выполняешь задачи уровня выше.
- Команда доверяет тебе сложные решения.
- Ты влияешь на качество и процессы.

---

## 67.13. Подготовка к следующему грейду

- Собери список решённых сложных задач.
- Зафиксируй улучшения, которые сделал в проекте.
- Покажи инициативу в архитектуре и процессах.

---

## 67.14. Критические знания для Middle/Senior

### Per-request store в Zustand (Next.js App Router)

**Проблема:** в Next.js App Router нельзя объявлять стор как глобальную константу, иначе данные утекут между разными пользователями сервера.

**Решение:** стор должен создаваться **на каждый запрос** через Context API:

```typescript
// lib/store-context.tsx
'use client'
import { createContext, useContext, useRef } from 'react'
import { create } from 'zustand'

const StoreContext = createContext(null)

export function StoreProvider({ children, initialState }) {
  const storeRef = useRef()
  
  if (!storeRef.current) {
    storeRef.current = create((set) => ({
      ...initialState,
      setUser: (user) => set({ user }),
    }))
  }

  return (
    <StoreContext.Provider value={storeRef.current}>
      {children}
    </StoreContext.Provider>
  )
}

export function useStore() {
  const store = useContext(StoreContext)
  if (!store) throw new Error('useStore must be used within StoreProvider')
  return store
}
```

**Почему это важно:** понимание изоляции состояния на сервере критично для безопасности и корректной работы SSR приложений.
