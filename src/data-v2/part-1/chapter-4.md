# Глава 4. API: REST и GraphQL, контракты и версионирование

API (Application Programming Interface) — это способ общения между клиентом и сервером. Для фронтенд-разработчика критично понимать разные подходы к проектированию API: REST, GraphQL, их плюсы и минусы, а также практические аспекты работы с контрактами и версионированием.

---

## 4.1. REST и RESTful API

REST (Representational State Transfer) — архитектурный стиль поверх HTTP, предложенный Роем Филдингом в 2000 году. Всё крутится вокруг **ресурсов** и их представлений.

### REST vs REST API: в чём разница?

Важно понимать различие между **REST** (архитектурный стиль) и **REST API** (конкретная реализация):

**REST** — это набор **принципов и ограничений**, описанных в диссертации Роя Филдинга:

- Абстрактная архитектурная концепция
- Не привязана к конкретной технологии
- Описывает, **как** должна быть организована система
- Фокус на масштабируемости, производительности, простоте

**REST API** — это **конкретная реализация** этих принципов:

- HTTP API, который следует принципам REST
- Конкретные эндпоинты, методы, форматы данных
- Практическая реализация для обмена данными

**Аналогия:**

- REST — это «рецепт» (принципы приготовления блюда)
- REST API — это «готовое блюдо» (конкретная реализация по рецепту)

**На практике:**

Большинство API, которые называют «REST API», на самом деле **не полностью соответствуют** всем принципам REST (особенно HATEOAS). Их правильнее называть:

- **RESTful API** — API, который следует большинству принципов REST, но не всем
- **HTTP API** — просто API поверх HTTP без строгого следования REST

**Для фронтенд-разработчика:**

На собеседованиях важно понимать:

- REST — это архитектурный стиль, не протокол
- REST API — это практическая реализация
- Большинство реальных API — это RESTful, а не «чистый» REST
- Важно знать принципы, чтобы понимать, почему API устроен именно так

---

## 4.2. Основные принципы REST

### 1. Ресурсы и URI

- URL описывает _ресурс_: `/users`, `/users/1`, `/orders/42/items`.
- Ресурсы должны быть существительными, не глаголами.
- Иерархия через вложенность: `/users/1/posts/5/comments`.

### 2. HTTP‑методы как действия

- GET — получение (без побочных эффектов)
- POST — создание нового ресурса
- PUT — полная замена ресурса (идемпотентный)
- PATCH — частичное обновление
- DELETE — удаление (идемпотентный)

### 3. Статусы HTTP описывают результат

- `200 OK` — успешное получение
- `201 Created` — ресурс создан
- `204 No Content` — успешно, но без тела ответа
- `400 Bad Request` — ошибка клиента
- `401 Unauthorized` — требуется аутентификация
- `403 Forbidden` — доступ запрещён
- `404 Not Found` — ресурс не найден
- `409 Conflict` — конфликт (например, дубликат)
- `422 Unprocessable Entity` — валидационная ошибка
- `500 Internal Server Error` — ошибка сервера

### 4. Stateless (без состояния)

- Каждый запрос содержит всю необходимую информацию.
- Сервер не хранит состояние клиента между запросами.
- Аутентификация через токены (JWT, Bearer), не через сессии.

### 5. Кэшируемость (Cacheable)

- GET‑запросы должны быть кэшируемыми.
- Использование заголовков: `Cache-Control`, `ETag`, `Last-Modified`.
- `304 Not Modified` для экономии трафика.

### 6. Единообразный интерфейс (Uniform Interface)

- Стандартные HTTP‑методы и статусы.
- Предсказуемая структура URL.
- JSON как стандартный формат обмена данными.

### 7. Слоистая архитектура (Layered System)

- Клиент не знает, общается ли он напрямую с сервером или через прокси/CDN/балансировщик.

---

## 4.3. Примеры REST API

**Базовые операции:**

- `GET /api/users` — получить список пользователей (с пагинацией: `?page=1&limit=20`);
- `GET /api/users/1` — получить пользователя с id=1;
- `POST /api/users` — создать нового пользователя (тело: `{ "name": "Иван", "email": "ivan@example.com" }`);
- `PUT /api/users/1` — полностью заменить пользователя (идемпотентный);
- `PATCH /api/users/1` — частично обновить пользователя (тело: `{ "name": "Пётр" }`);
- `DELETE /api/users/1` — удалить пользователя.

**Вложенные ресурсы:**

- `GET /api/users/1/posts` — получить посты пользователя;
- `POST /api/users/1/posts` — создать пост для пользователя;
- `GET /api/users/1/posts/5` — получить конкретный пост.

**Фильтрация и поиск:**

- `GET /api/users?role=admin&status=active` — фильтрация через query‑параметры;
- `GET /api/users?search=ivan&sort=name&order=asc` — поиск и сортировка.

---

## 4.4. Версионирование API

**Подходы:**

1. **В URL:** `/api/v1/users`, `/api/v2/users` — явно, но «загрязняет» URL.
2. **В заголовке:** `Accept: application/vnd.api+json;version=2` — чище, но требует настройки.
3. **В поддомене:** `v1.api.example.com` — удобно для микросервисов.

**Рекомендация:** для публичных API — версионирование в URL (`/api/v1/`), для внутренних — можно через заголовки.

### Контракты API

**OpenAPI (Swagger)** — стандарт описания REST API:

- Автогенерация документации
- Валидация запросов/ответов
- Генерация клиентского кода
- Тестирование через Swagger UI

**Пример:**

```yaml
paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: User found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
```

---

## 4.5. HATEOAS (Hypermedia as the Engine of Application State)

Идеальный REST API должен возвращать не только данные, но и **ссылки на возможные действия**:

```json
{
  "id": 1,
  "name": "Иван",
  "email": "ivan@example.com",
  "_links": {
    "self": { "href": "/api/users/1" },
    "posts": { "href": "/api/users/1/posts" },
    "update": { "href": "/api/users/1", "method": "PATCH" },
    "delete": { "href": "/api/users/1", "method": "DELETE" }
  }
}
```

На практике HATEOAS редко используется полностью, но идея «самодокументируемого API» важна.

---

## 4.6. Best Practices для фронтенда

**Структура запросов:**

- Используй правильные HTTP‑методы (не GET для создания).
- Обрабатывай все статусы, не только `200` и `404`.
- Используй правильные заголовки: `Content-Type: application/json`, `Authorization: Bearer <token>`.

**Обработка ошибок:**

```typescript
// Хорошо: структурированные ошибки
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required",
    "fields": { "email": "This field is required" }
  }
}
```

**Пагинация:**

```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

**Плюсы REST для фронтенда:**

- простой, читаемый контракт;
- легко дебажить через браузер/Insomnia/Postman;
- хорошо ложится на HTTP‑инфраструктуру (кеши, прокси, CDN);
- предсказуемая структура URL;
- стандартизированные методы и статусы упрощают разработку.

**Минусы:**

- возможна **перегрузка/недогрузка данных** (overfetching/underfetching): один эндпоинт отдаёт слишком много или слишком мало;
- сложнее, когда нужен очень гибкий выбор полей и связей;
- множественные запросы для связанных данных (проблема N+1);
- нет стандарта на структуру ошибок и пагинацию (каждый API делает по‑своему).

---

## 4.7. GraphQL

GraphQL — это **запросный язык к данным** и сервер, который умеет эти запросы выполнять.

Ключевые идеи:

- один endpoint, например `/graphql`;
- клиент _декларативно_ описывает, какие поля ему нужны;
- сервер возвращает ровно эти поля — ни больше, ни меньше.

**Пример запроса:**

```graphql
query {
  user(id: "1") {
    id
    name
    posts(limit: 5) {
      id
      title
    }
  }
}
```

**Плюсы:**

- решает проблему overfetching/underfetching;
- удобен для **фронтенд‑heavy** приложений и сложных UI;
- сильная типизация схемы (SDL), автогенерация TypeScript‑типов;
- удобная интеграция с кэшами на клиенте (Apollo, Relay, URQL).

**Минусы:**

- сложнее кеширование на уровне CDN (всё идёт через один endpoint);
- сложнее дебаг HTTP‑трафик «глазами» (нужно смотреть в тело запроса);
- оверхед для простых CRUD‑API.

---

## 4.8. SOAP и gRPC

### SOAP

SOAP — «старый корпоративный тяжеловес»:

- формат сообщений — XML;
- строгие контракты через WSDL;
- сложная, но формальная типизация;
- много расширений (транзакции, безопасность).

Где всё ещё встречается:

- банки и крупные корпорации;
- государственные системы;
- старые интеграции B2B.

Фронтендеру важно:

- уметь работать через **backend‑gateway** (часто SOAP  REST/GraphQL преобразуется на бэкенде);
- понимать, что «давайте просто добавим поле в ответ» в мире SOAP может значить изменение схем, контрактов и согласований.

### gRPC

gRPC — RPC‑фреймворк поверх HTTP/2 (и HTTP/3 в новых версиях) с бинарным протоколом **Protocol Buffers (protobuf)**.

Характеристики:

- очень маленькие и быстрые сообщения;
- чёткая контрактная типизация;
- отличен для общения микросервисов между собой.

Типичный сценарий:

- фронтенд общается с **REST/GraphQL‑шлюзом**;
- этот шлюз уже говорит с внутренними сервисами по gRPC.

На фронтенде gRPC чаще встречается:

- в десктопных/мобильных клиентах;
- в internal‑инструментах;
- при использовании gRPC‑web через proxy (Envoy и др.).

---

## Вопросы на собеседовании

### 1. Что такое REST?

REST — архитектурный стиль поверх HTTP, основанный на ресурсах, методах и статусах.

### 2. В чём разница между REST и RESTful API?

REST — это принципы, RESTful API — практическая реализация, которая следует большинству принципов.

### 3. Чем GraphQL отличается от REST?

GraphQL — один endpoint с декларативными запросами, решает проблему overfetching/underfetching. REST — множественные endpoints с фиксированной структурой ответов.

### 4. Как версионировать API?

В URL (`/api/v1/`), в заголовках (`Accept: application/vnd.api+json;version=2`) или в поддомене (`v1.api.example.com`).

### 5. Что такое HATEOAS?

Hypermedia as the Engine of Application State — принцип REST, когда API возвращает ссылки на возможные действия вместе с данными.

### 6. Когда использовать GraphQL, а когда REST?

GraphQL — для сложных UI с гибкими требованиями к данным. REST — для простых CRUD, когда важна простота и кэширование на уровне CDN.
