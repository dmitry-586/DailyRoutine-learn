# Глава 21. Execution context, call stack и замыкания

Эта глава — про то, **почему код выполняется именно в таком порядке** и **как функции “помнят” переменные**.

---

## 21.1. Execution Context (контекст выполнения)

Когда движок JS выполняет код, он создаёт **контекст выполнения** (Execution Context) — «запись о том, что сейчас выполняется».

- **глобальный контекст** (при загрузке файла)
- **контекст функции** (при вызове любой функции)
- (в ES-модулях — ещё и контекст модуля)

### Что важно запомнить

Внутри контекста есть:

- **переменные/функции текущей области**
- **ссылка на внешнюю область** (где искать переменные, если в текущей нет)
- **`this`** (отдельная тема, но здесь достаточно знать, что он определяется при вызове)

Можно думать так:

- Сначала движок «готовит место» (регистрирует объявления, создаёт переменные).
- Потом начинает выполнять строки кода по порядку.

---

## 21.2. Lexical Environment (лексическое окружение)

**Lexical Environment** — это «коробка», в которой лежат переменные текущей области видимости.
И у этой коробки есть «ссылка наружу» — на коробку, которая была снаружи при создании кода.

### Цепочка областей видимости (Scope Chain)

Когда вы обращаетесь к переменной, движок ищет так:

1. Ищет в текущем Lexical Environment
2. Если не найдена — идёт по ссылке Outer во внешнее окружение
3. Продолжает до глобального контекста
4. Если не найдена — ReferenceError

**Пример:**

```javascript
const global = 'global'

function outer() {
  const outerVar = 'outer'

  function inner() {
    const innerVar = 'inner'
    console.log(global) // ищет: inner → outer → global
    console.log(outerVar) // ищет: inner → outer
    console.log(innerVar) // ищет: inner
  }

  inner()
}

outer()
```

---

## 21.3. Call Stack (стек вызовов)

JavaScript — **однопоточный** язык: в каждый момент времени выполняется только один фрагмент кода. Управляет этим **стек вызовов** (Call Stack).

### Как работает Call Stack

Стек работает по принципу LIFO (Last In, First Out):

- При вызове функции её контекст **добавляется** на вершину стека
- При завершении функции её контекст **удаляется** со стека
- Выполняется всегда контекст на **вершине** стека

### Пример стека вызовов

```javascript
function a() {
  b()
}

function b() {
  c()
}

function c() {
  console.log('Hi')
}

a()
```

**Последовательность в стеке:**

1. Глобальный контекст
2. Вызов `a` → контекст `a` на вершине стека
3. `a` вызывает `b` → сверху новый контекст `b`
4. `b` вызывает `c` → сверху контекст `c`
5. `c` завершилась → её контекст снимается со стека
6. Завершается `b`, потом `a`, потом глобальный код

**Визуализация:**

```
[глобальный]
[глобальный, a]
[глобальный, a, b]
[глобальный, a, b, c]
[глобальный, a, b] ← c завершилась
[глобальный, a] ← b завершилась
[глобальный] ← a завершилась
```

### Stack Overflow

Если стек переполняется (слишком много вложенных вызовов), возникает ошибка:

```javascript
function recursive() {
  recursive() // Бесконечная рекурсия
}

recursive() // RangeError: Maximum call stack size exceeded
```

---

## 21.4. Замыкания (Closures)

Самое простое определение:

> **Замыкание — это когда функция использует переменные “снаружи”, и эти переменные продолжают жить, пока функция доступна.**

### Базовый пример

```javascript
function makeCounter() {
  let count = 0

  return function () {
    count++
    return count
  }
}

const counter = makeCounter()
counter() // 1
counter() // 2
counter() // 3
```

**Что здесь важно понять:**

- `count` не «копируется» в функцию.
- Внутренняя функция хранит **доступ к переменной `count`**.
- Поэтому при каждом вызове счётчик продолжает увеличиваться.

### Важно: замыкание — это ссылка, а не копия

Частая ошибка в голове: «функция запомнила значение».
Правильнее: «функция имеет доступ к переменной, и она может меняться».

**Пример:**

```javascript
function outer() {
  let x = 10

  function inner() {
    console.log(x)
  }

  x = 20 // Изменяем x

  return inner
}

const fn = outer()
fn() // 20, а не 10!
```

### Классическая задача с циклом

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10)
}
// Выведет: 3, 3, 3
```

**Почему?**

`var` создаёт **одну переменную `i`** на весь цикл, и все стрелочные функции смотрят в одно и то же место в памяти. К моменту выполнения setTimeout цикл уже завершился, и `i = 3`.

**Как сделать понятный и правильный вариант:**

```javascript
// 1. let даёт новую переменную i на каждую итерацию
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10)
}
// Выведет: 0, 1, 2

// 2. IIFE (исторический паттерн)
for (var i = 0; i < 3; i++) {
  ;((j) => {
    setTimeout(() => console.log(j), 10)
  })(i)
}
// Выведет: 0, 1, 2
```

---

## 21.5. Практическое использование замыканий

### Инкапсуляция состояния

```javascript
function createCounter() {
  let count = 0

  return {
    increment() {
      count++
      return count
    },
    getValue() {
      return count
    },
  }
}

const counter = createCounter()
counter.increment() // 1
counter.increment() // 2
counter.getValue() // 2
// count недоступен снаружи
```

### Фабрики функций

```javascript
function createMultiplier(multiplier) {
  return function (number) {
    return number * multiplier
  }
}

const double = createMultiplier(2)
const triple = createMultiplier(3)

double(5) // 10
triple(5) // 15
```

---

## 21.6. Функции высшего порядка (HOF)

**Функция высшего порядка (Higher-Order Function, HOF)** — это функция, которая:

- принимает другую функцию как аргумент **или**
- возвращает функцию как результат

**Встроенные примеры:**

```javascript
;[1, 2, 3]
  .map((x) => x * 2) // [2, 4, 6]
  [(1, 2, 3)].filter((x) => x > 1) // [2, 3]
  [(1, 2, 3)].reduce((a, b) => a + b, 0) // 6
```

**Кастомный пример:**

```javascript
function withLogging(fn) {
  return function (...args) {
    console.log('Calling with', args)
    const result = fn(...args)
    console.log('Result:', result)
    return result
  }
}

const sum = (a, b) => a + b
const loggedSum = withLogging(sum)

loggedSum(4, 5)
// Calling with [4, 5]
// Result: 9
```

---

## 21.7. Каррирование и частичное применение

### Каррирование (currying)

Каррирование — это когда функцию вида `f(a, b, c)` превращают в `f(a)(b)(c)`.
Зачем? Чтобы удобно «заранее настроить» функцию, а потом многократно использовать.

```javascript
const sum3 = (a, b, c) => a + b + c
const curriedSum3 = (a) => (b) => (c) => a + b + c

curriedSum3(1)(2)(3) // 6
```

**Понятный пример из жизни:** «сначала выбираем валюту, потом форматируем числа».

```javascript
const formatMoney = (currency) => (value) => `${value} ${currency}`

const formatRub = formatMoney('₽')
formatRub(100) // '100 ₽'
formatRub(250) // '250 ₽'
```

### Частичное применение (partial application)

Частичное применение — когда мы фиксируем **часть аргументов**, но не обязаны превращать всё в цепочку `()()()`.
То есть мы делаем «специализированную версию» функции.

```javascript
function partial(fn, ...fixed) {
  return (...rest) => fn(...fixed, ...rest)
}

const multiply = (a, b, c) => a * b * c
const double = partial(multiply, 2)

double(3, 4) // 24 (2 * 3 * 4)
```

### В чём разница (простая формулировка)

- **Каррирование** меняет форму функции: `f(a, b)` → `f(a)(b)`
- **Partial** просто фиксирует часть аргументов: `f(a, b)` → `f(фиксированныйA, b)`

---

## 21.8. Утечки памяти в замыканиях

Иногда замыкание случайно удерживает большой объект в памяти (потому что «снаружи» лежит ссылка).
Это не значит, что замыкания плохие — просто помните правило: **не держите в замыкании то, что не нужно держать**.

```javascript
function createHandler() {
  const largeData = new Array(1000000).fill('data')

  return function () {
    // Использует только smallData, но largeData тоже в памяти
    const smallData = largeData.slice(0, 10)
    console.log(smallData)
  }
}

const handler = createHandler()
// largeData остаётся в памяти, пока существует handler
```

**Решение:**

```javascript
function createHandler() {
  const largeData = new Array(1000000).fill('data')
  const smallData = largeData.slice(0, 10) // Извлекаем нужное

  return function () {
    console.log(smallData)
    // largeData больше не нужна
  }
  // largeData может быть удалена сборщиком мусора
}
```

---

## Вопросы на собеседовании

### 1. Что такое Execution Context?

«Запись» о выполняющемся коде (глобальном или функции): какие переменные доступны, где искать внешние, чему равен `this`.

### 2. Что такое Lexical Environment?

«Коробка с переменными» текущей области + ссылка наружу. По этой ссылке строится scope chain.

### 3. Как работает Call Stack?

Стек вызовов управляет выполнением кода. При вызове функции её контекст добавляется на вершину стека, при завершении — удаляется.

### 4. Что такое замыкание?

Функция вместе с её лексическим окружением. Функция «помнит» переменные из внешней области видимости даже после её завершения.

### 5. Почему цикл с var выводит 3, 3, 3?

var создаёт одну переменную на весь цикл. Все замыкания ссылаются на одно и то же значение, которое к моменту выполнения уже равно 3.

### 6. Как замыкания используются на практике?

Инкапсуляция состояния (счётчики), фабрики функций (настроить функцию один раз и переиспользовать), коллбеки/обработчики, которым нужно помнить данные.

### 7. Что такое функция высшего порядка?

Функция, которая принимает другую функцию как аргумент или возвращает функцию как результат.

### 8. В чём разница между каррированием и частичным применением?

Каррирование превращает функцию в цепочку функций с одним аргументом. Частичное применение фиксирует часть аргументов заранее.
