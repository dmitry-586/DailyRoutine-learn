# Глава 18. Типы данных и сравнение

Понимание типов данных и правил сравнения — фундамент JavaScript. От этого зависит, как передаются значения и как работает сравнение.

---

## 18.1. Примитивы и объекты

В JavaScript 8 встроенных типов:

**7 примитивных типов** (передаются по значению):

- `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

**1 ссылочный тип:**

- `object` — объекты, массивы, функции, `Map`, `Set`, `Date` и т.п.

**Примечание про `WeakMap` и `WeakSet`:** это специальные коллекции, которые позволяют объектам удаляться из памяти (сборщиком мусора), даже если они являются ключами в этих коллекциях. Это критично для предотвращения утечек памяти при работе с DOM-узлами. В отличие от обычных `Map` и `Set`, `WeakMap` и `WeakSet` не препятствуют сборке мусора для своих ключей.

### Ключевое различие

**Примитивы** — независимые копии значений:

```javascript
let a = 10
let b = a
b = 20
console.log(a) // 10 — не изменился
```

**Объекты** — ссылки на одну область памяти:

```javascript
const obj1 = { x: 1 }
const obj2 = obj1
obj2.x = 2
console.log(obj1.x) // 2 — изменился исходный объект
```

**Практический вывод:** примитивы копируются, объекты — нет.

---

## 18.2. Копирование объектов

При присваивании объекта создаётся только ссылка, а не копия. Чтобы получить независимую копию, нужно копировать явно.

### Неглубокое копирование (Shallow Copy)

Копируется только первый уровень. Вложенные объекты остаются ссылками.

**Способы неглубокого копирования:**

**1. Spread оператор:**

```javascript
const original = { a: 1, b: { c: 2 } }
const copy = { ...original }

copy.a = 10
console.log(original.a) // 1 — не изменился

copy.b.c = 20
console.log(original.b.c) // 20 — изменился! (та же ссылка)
```

**2. Object.assign():**

```javascript
const original = { a: 1, b: { c: 2 } }
const copy = Object.assign({}, original)

copy.a = 10
console.log(original.a) // 1

copy.b.c = 20
console.log(original.b.c) // 20 — изменился
```

**3. Для массивов:**

```javascript
const original = [1, 2, [3, 4]]
const copy = [...original]
// или
const copy2 = original.slice()
// или
const copy3 = Array.from(original)
```

### Глубокое копирование (Deep Copy)

Копируются все уровни вложенности. Каждый вложенный объект становится независимым.

**Практический минимум:** если доступен `structuredClone()` — используйте его.

```javascript
const original = { a: 1, b: { c: 2 }, date: new Date() }
const copy = structuredClone(original)

copy.b.c = 20
console.log(original.b.c) // 2 — не изменился
console.log(copy.date instanceof Date) // true
```

`structuredClone()` не копирует функции — это нормально: функции обычно не «клонируют», а переиспользуют.

**Про JSON-способ (`JSON.parse(JSON.stringify(...))`)**: можно встретить в старом коде, но он имеет **критические ограничения**:
- **ломает `Date`** — превращает в строку (потеря типа данных)
- **теряет `undefined`** — поля с `undefined` исчезают
- **теряет функции** — функции удаляются
- **теряет `Symbol`** — символы игнорируются
- **падает на циклических ссылках** — вызывает ошибку
- **не копирует `Map`, `Set`, `RegExp`** — теряются или превращаются в пустые объекты

**Важно:** `structuredClone()` — единственный встроенный способ, который корректно копирует `Date`, `RegExp`, `Map` и `Set`. На собеседованиях это стандартный вопрос на «подвох» — знание этого показывает понимание современного стандарта.

### Когда что использовать

- **Неглубокое копирование** — когда нужно скопировать только первый уровень (например, обновление состояния в React)
- **Глубокое копирование** — когда структура вложенная и нужно полное разделение данных
- **structuredClone()** — предпочтительный способ для глубокого копирования в современном JavaScript

---

## 18.3. Сравнение `==` и `===`

### Практический минимум

- **Почти всегда используйте `===`** (или `!==`). Это предсказуемо: без приведения типов.
- **Единственное «нормальное» исключение** — проверка на `null` _или_ `undefined` сразу:

```javascript
if (value == null) {
  // true только для null и undefined
}
```

### Почему `==` кажется «магией»

`==` умеет приводить типы, и из‑за этого легко получить неожиданные совпадения.
Запоминать всю спецификацию не нужно — хватит нескольких самых частых правил/ловушек.

### Самые важные правила `==` (которые реально встречаются)

1. **`null` и `undefined` равны только друг другу**

```javascript
null == undefined // true
null == 0 // false
undefined == 0 // false
```

2. **Строка ↔ число**: строка приводится к числу

```javascript
'5' == 5 // true
'  5 ' == 5 // true
'' == 0 // true (пустая строка -> 0)
```

3. **Boolean приводится к числу** (`true -> 1`, `false -> 0`)

```javascript
false == 0 // true
true == 1 // true
```

4. **Объект ↔ примитив**: объект пытается стать примитивом (по сути — «строкой/числом»)

```javascript
[] == 0 // true ([] -> '' -> 0)
[] == false // true (false -> 0, [] -> '' -> 0)
[5] == 5 // true ([5] -> '5' -> 5)
```

### Отдельно важное (часто путают)

- **Объекты сравниваются по ссылке**, даже если «одинаковые по содержимому»:

```javascript
{} === {} // false
const a = {}
const b = a
a === b // true
```

- **`NaN` не равен ничему, включая себя**:

```javascript
NaN === NaN // false
Number.isNaN(NaN) // true
```

---

## 18.4. Приведение типов

### Явное приведение

Ты сам указываешь преобразование:

```javascript
Number('42') // 42
String(42) // '42'
Boolean(0) + // false
  '42' // 42 (унарный плюс)
!!1 // true (двойное отрицание)
```

### Неявное приведение

JavaScript делает это автоматически:

**При операциях:**

- `+` с строкой → оба к строке: `'5' + 2` → `'52'`
- `-`, `*`, `/` → оба к числу: `'5' - 2` → `3`

**В условиях:**

- Значение приводится к `boolean`

**Falsy-значения (8 штук):**

- `false`, `0`, `-0`, `0n`, `''`, `null`, `undefined`, `NaN`

Всё остальное — **truthy**:

```javascript
if ([]) {
} // выполнится
if ({}) {
} // выполнится
if ('0') {
} // выполнится
```

---

## 18.5. Проверка типов

### typeof

Быстрая проверка, но с ограничениями:

```javascript
typeof 42 // 'number'
typeof 'hello' // 'string'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof null // 'object' (историческая ошибка)
typeof [] // 'object'
typeof function () {} // 'function'
```

### Специализированные проверки

```javascript
Array.isArray([])      // true
[] instanceof Array    // true
Object.prototype.toString.call([])  // '[object Array]'
```

**Практика:** для массивов используй `Array.isArray()`, для `null` — `value === null`.

---

## Вопросы на собеседовании

### 1. Какие типы данных есть в JavaScript?

8 типов: 7 примитивных (number, string, boolean, null, undefined, symbol, bigint) и 1 ссылочный (object).

### 2. В чём разница между примитивами и объектами?

Примитивы передаются по значению (копируются), объекты — по ссылке (указывают на одну область памяти).

### 3. В чём разница между == и ===?

`===` — строгое сравнение (без приведения типов). `==` — сравнение с приведением типов, поэтому чаще даёт «сюрпризы». На практике почти всегда выбирают `===`, а `value == null` используют как короткую проверку на `null` или `undefined`.

### 4. Что такое falsy значения?

8 значений, которые приводятся к `false`: `false`, `0`, `-0`, `0n`, `''`, `null`, `undefined`, `NaN`. Всё остальное — truthy.

### 5. Почему typeof null возвращает 'object'?

Историческая ошибка в JavaScript. `null` — примитив, но `typeof` возвращает `'object'` из-за бага в ранних версиях.

### 6. Как проверить, является ли значение массивом?

`Array.isArray(value)` — самый надёжный способ.

### 7. Как скопировать объект?

Неглубокое копирование: `{ ...obj }` или `Object.assign({}, obj)` (вложенные объекты останутся ссылками). Глубокое копирование: `structuredClone(obj)` (если доступен). JSON‑способ встречается в старом коде, но его лучше избегать из‑за ограничений.

### 8. В чём разница между неглубоким и глубоким копированием?

Неглубокое копирование копирует только первый уровень, вложенные объекты остаются ссылками. Глубокое копирование создаёт независимые копии всех уровней вложенности.
