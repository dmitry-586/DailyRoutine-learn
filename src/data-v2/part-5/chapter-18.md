# Глава 18. Типы данных, значения, ссылки и приведение типов

Понимание типов данных и их поведения — фундамент JavaScript. От этого зависит, как передаются значения, как работает сравнение, как устроена память. Без этого понимания невозможно уверенно работать с языком.

---

## 18.1. Типы данных в JavaScript: примитивы и объекты

В JavaScript 8 встроенных типов данных:

**Примитивные типы (передаются по значению):**

1. `number`
2. `string`
3. `boolean`
4. `null`
5. `undefined`
6. `symbol`
7. `bigint`

**Ссылочный тип:**

8. `object` — всё остальное: объекты, массивы, функции, `Map`, `Set`, `Date` и т.п.

### Почему разделение на примитивы и объекты так важно

От этого зависит:

- **как передаётся значение** в функцию и при присваивании
- **как ведёт себя `===` и `==`**
- **как устроена память:** что лежит в стеке, а что — в куче (heap)

### Примитивы: копия значения

```javascript
let a = 10
let b = a

b = 20

console.log(a) // 10 — a не изменился
console.log(b) // 20
```

`a` и `b` — два независимых значения.

### Объекты: ссылка на одну и ту же область памяти

```javascript
const obj1 = { x: 1 }
const obj2 = obj1

obj2.x = 2

console.log(obj1.x) // 2 — изменился исходный объект
console.log(obj2.x) // 2
```

`obj1` и `obj2` указывают **на один и тот же объект**.

### Иммутабельность примитивов

Примитивы нельзя «изменить по месту» — только заменить новым значением:

```javascript
let str = 'hi'
str[0] = 'H' // попытка ничего не изменит

str = 'Hi' // создана новая строка
```

**Ключевая мысль:**

- примитивы ведут себя как «значения в коробках»
- объекты — как «бирки с адресом», по которому лежат данные

### Детали примитивных типов

**number:**

```javascript
typeof 42 // 'number'
typeof 3.14 // 'number'
typeof NaN // 'number' (специальное значение)
typeof Infinity // 'number'
```

**string:**

```javascript
typeof 'hello' // 'string'
typeof "world" // 'string'
typeof `template` // 'string'
```

**boolean:**

```javascript
typeof true // 'boolean'
typeof false // 'boolean'
```

**null:**

```javascript
typeof null // 'object' (историческая ошибка!)
null === null // true
```

**undefined:**

```javascript
typeof undefined // 'undefined'
let x
console.log(x) // undefined
```

**symbol:**

```javascript
const sym = Symbol('description')
typeof sym // 'symbol'
```

**bigint:**

```javascript
const big = 9007199254740991n
typeof big // 'bigint'
```

---

## 18.2. Приведение типов (Type Coercion)

JavaScript часто сам пытается «договориться» о типах между собой. Это называется **приведение типов** (coercion) и бывает:

- **явным** — когда ты сам вызываешь `Number()`, `String()`, `Boolean()`
- **неявным** — когда это делает движок за тебя при операциях `+`, `-`, сравнении и т.п.

### Явное приведение

```javascript
Number('42') // 42
String(42) // '42'
Boolean(1) // true
Boolean('') // false
Boolean(0) // false
Boolean(null) // false
Boolean(undefined) // false
```

**Другие способы:**

```javascript
+'42' // 42 (унарный плюс)
'' + 42 // '42' (конкатенация)
!!1 // true (двойное отрицание)
```

### Неявное приведение: странные, но логичные правила

```javascript
'5' + 2   // '52'      — строка + число → строка
'5' - 2   // 3         — минус всегда приводит к number
[] + []   // ''        — оба приводятся к строке
{} + []   // '[object Object]' — объект → строка
[1, 2] + [3, 4] // '1,23,4' — массивы → строки
```

За этим стоят формальные правила спецификации (ECMAScript), а не «рандом». На собеседованиях важно **объяснять логику, а не зубрить частные случаи**.

**Правила неявного приведения:**

1. При `+` если один операнд — строка, оба приводятся к строке
2. При `-`, `*`, `/` оба операнда приводятся к числу
3. При сравнении (`==`) происходит приведение к общему типу
4. При строгом сравнении (`===`) приведение не происходит

### Truthy / Falsy значения

В условных конструкциях (`if`, `while`, `?:`) значение сначала приводится к `boolean`.

**Falsy-знаений всего 8:**

- `false`
- `0`
- `-0`
- `0n` (BigInt)
- `''` (пустая строка)
- `null`
- `undefined`
- `NaN`

Всё остальное — **truthy**.

**Примеры:**

```javascript
if ('') {
  // не выполнится
}

if ([]) {
  // выполнится (массив — truthy)
}

if ({}) {
  // выполнится (объект — truthy)
}

if (0) {
  // не выполнится
}
```

### Сравнение `==` и `===`

- `===` — **строгое сравнение**: сначала проверяется тип, потом значение, без приведения типов
- `==` — **нестрогое сравнение**: пытается привести значения к общему типу

```javascript
0 == false      // true
'' == 0         // true
null == undefined // true
[] == 0         // true
[1] == 1        // true

0 === false     // false
'' === 0        // false
null === undefined // false
[] === 0        // false
[1] === 1       // false
```

**Правила `==`:**

1. Если типы одинаковы → сравниваются значения
2. Если один `null`, другой `undefined` → `true`
3. Если один — число, другой — строка → строка → число
4. Если один — boolean → boolean → число
5. Если один — объект → объект → примитив

**Практическое правило:**

- в прикладном коде почти всегда используй `===`
- `== null` иногда используют осознанно для проверки сразу на `null` **или** `undefined`

```javascript
if (value == null) {
  // Проверяет и null, и undefined
}
```

---

## 18.3. Stack vs Heap: память в JavaScript

Упрощённо:

- **stack (стек)** — для примитивов и ссылок на объекты
- **heap (куча)** — для самих объектов

Отсюда:

- копируя примитив, ты получаешь **новое значение**
- копируя объект, ты копируешь **ссылку** на область в куче

**Пример:**

```javascript
// Примитивы в стеке
let a = 10
let b = a // Копия значения
b = 20
console.log(a) // 10

// Объекты в куче
let obj1 = { x: 1 }
let obj2 = obj1 // Копия ссылки
obj2.x = 2
console.log(obj1.x) // 2
```

### Сборщик мусора (Garbage Collector)

Современные движки (V8 и др.) используют модификации алгоритма **mark-and-sweep**:

1. находят «корневые» объекты (глобальный контекст, текущий стек вызовов и т.п.)
2. обходят по ссылкам всё, что достижимо
3. всё недостижимое помечается как мусор и удаляется

**Практический вывод:**

- объекты и замыкания могут «жить» в памяти дольше, чем ты ожидаешь
- удержание больших структур в замыканиях или глобале может привести к утечкам

---

## 18.4. Проверка типов

### typeof

```javascript
typeof 42 // 'number'
typeof 'hello' // 'string'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof null // 'object' (историческая ошибка!)
typeof {} // 'object'
typeof [] // 'object'
typeof function() {} // 'function'
```

**Ограничения:**

- `typeof null` возвращает `'object'` (историческая ошибка)
- `typeof []` возвращает `'object'`, а не `'array'`

### instanceof

Проверяет, является ли объект экземпляром конструктора:

```javascript
[] instanceof Array // true
{} instanceof Object // true
new Date() instanceof Date // true
```

### Object.prototype.toString

Более надёжный способ:

```javascript
Object.prototype.toString.call([]) // '[object Array]'
Object.prototype.toString.call({}) // '[object Object]'
Object.prototype.toString.call(null) // '[object Null]'
```

### Array.isArray()

```javascript
Array.isArray([]) // true
Array.isArray({}) // false
```

---

## Вопросы на собеседовании

### 1. Какие типы данных есть в JavaScript?

8 типов: 7 примитивных (number, string, boolean, null, undefined, symbol, bigint) и 1 ссылочный (object).

### 2. В чём разница между примитивами и объектами?

Примитивы передаются по значению, объекты — по ссылке. Примитивы иммутабельны, объекты мутабельны.

### 3. Что такое приведение типов?

Процесс преобразования значения одного типа в другой. Бывает явным (Number(), String()) и неявным (при операциях).

### 4. Что такое falsy значения?

8 значений, которые приводятся к false: false, 0, -0, 0n, '', null, undefined, NaN.

### 5. В чём разница между == и ===?

=== — строгое сравнение без приведения типов. == — нестрогое сравнение с приведением типов.

### 6. Почему typeof null возвращает 'object'?

Историческая ошибка в JavaScript. null — это примитив, но typeof возвращает 'object' из-за бага в ранних версиях.

### 7. Как проверить, является ли значение массивом?

Array.isArray(value) или Object.prototype.toString.call(value) === '[object Array]'.
