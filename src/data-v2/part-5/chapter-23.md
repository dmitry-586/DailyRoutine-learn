# Глава 23. Прототипы, наследование и классы

Эта тема кажется сложной, потому что в JavaScript исторически две «упаковки» одной и той же идеи:

- **прототипы** (как язык реально работает под капотом)
- **классы** (удобный синтаксис поверх прототипов)

Цель главы — понять **одну ключевую механику**: *как движок ищет свойства/методы у объекта*.

---

## 23.1. Главная идея: у объекта есть «запасной» объект

У каждого объекта есть скрытая ссылка на другой объект — `[[Prototype]]`.
Если коротко:

> Если у объекта нет свойства, движок идёт искать его в прототипе, затем в прототипе прототипа, и так далее.

Эта цепочка называется **цепочка прототипов (prototype chain)**.

---

## 23.2. Как происходит поиск свойства (самое важное)

Когда вы пишете `obj.someMethod`, движок делает примерно так:

1. Проверяет: есть ли `someMethod` прямо в `obj`
2. Если нет — смотрит в `obj.[[Prototype]]`
3. Если нет — идёт дальше по цепочке
4. Если дошёл до конца цепочки (там `null`) — возвращает `undefined`

Минимальный пример:

```javascript
const obj = {}
obj.toString() // метод найден не в obj, а в Object.prototype
```

Практический вывод: **объект может “уметь” что-то не потому, что у него есть метод, а потому что метод есть у прототипа**.

---

## 23.3. `[[Prototype]]`, `__proto__` и `Object.getPrototypeOf`

- `[[Prototype]]` — внутренняя (скрытая) ссылка.
- `__proto__` — исторический аксессор к `[[Prototype]]` (в учебных примерах встречается, но в коде лучше не использовать).
- `Object.getPrototypeOf(obj)` — нормальный способ посмотреть прототип.

```javascript
const obj = {}
Object.getPrototypeOf(obj) === Object.prototype // true
```

---

## 23.4. `prototype` у функций и `[[Prototype]]` у объектов — это разное

Тут чаще всего и начинается путаница.

### `[[Prototype]]` есть у объектов

Это «куда идти дальше», если свойства не нашлось.

### `prototype` есть у функций (конструкторов)

`User.prototype` — это объект, который станет прототипом (`[[Prototype]]`) для экземпляров, созданных через `new User()`.

Запоминалка:

- **`prototype`** — «шаблон прототипа для будущих экземпляров»
- **`[[Prototype]]`** — «прототип конкретного объекта прямо сейчас»

---

## 23.5. Что делает `new`

`new` нужен, чтобы создать объект и привязать его прототип к `Constructor.prototype`.

Если очень коротко, `new` делает так:

1. Создаёт новый объект
2. Ставит ему `[[Prototype]] = Constructor.prototype`
3. Вызывает конструктор с `this = новый объект`
4. Возвращает новый объект

Важная мысль: **именно из-за шага (2) экземпляр получает методы через прототип**.

---

## 23.6. Классы: удобный синтаксис над прототипами

В современном коде чаще всего используют `class`, но под капотом всё равно работает прототипная цепочка.

### Методы класса находятся в прототипе

Когда вы пишете:

```javascript
class User {
  say() {
    return 'hi'
  }
}
```

Движок фактически делает так, что метод `say` лежит не в каждом объекте отдельно, а в `User.prototype`.

---

## 23.7. Наследование: `extends` и `super`

### Что делает `extends`

`extends` настраивает цепочку прототипов так, чтобы:

- экземпляр наследника мог найти методы родителя
- и сам класс наследника мог наследовать статические методы/свойства родителя

### Зачем нужен `super`

- `super()` в конструкторе вызывает конструктор родителя и инициализирует `this`.
- `super.method()` вызывает метод родителя с текущим `this`.

Ключевое правило:

> В наследнике нельзя использовать `this` до `super()` в конструкторе.

---

## 23.8. Статические методы

**Статические методы** принадлежат классу, а не экземпляру.

```javascript
class MathUtils {
  static sum(a, b) {
    return a + b
  }
}

MathUtils.sum(1, 2) // 3
```

У экземпляра `new MathUtils()` этого метода не будет.

---

## 23.9. Приватные поля `#`

Поля с `#` доступны только внутри класса:

```javascript
class User {
  #password = 'secret'
  getPassword() {
    return this.#password
  }
}
```

Снаружи обратиться к `user.#password` нельзя — это синтаксическая ошибка.

**Важно:** это **жесткая инкапсуляция**. В отличие от старого соглашения с нижним подчёркиванием (`_protected`), к полям с `#` невозможно обратиться извне класса даже через квадратные скобки (динамический доступ):

```javascript
class User {
  #password = 'secret'
  _oldStyle = 'accessible'
}

const user = new User()
user._oldStyle // 'accessible' — работает
user['_oldStyle'] // 'accessible' — работает
user.#password // SyntaxError
user['#password'] // undefined — не работает
```

---

## 23.10. Как проверять «принадлежность» (instanceof)

`instanceof` отвечает на вопрос:

> Есть ли `Prototype.prototype` где-то в цепочке `obj`?

```javascript
class Animal {}
class Dog extends Animal {}

const dog = new Dog()
dog instanceof Dog // true
dog instanceof Animal // true
```

---

## Короткое резюме (что нужно реально унести)

- **Прототипная цепочка** — механизм поиска свойств/методов.
- **`prototype`** (у функций/классов) — «что будет прототипом у экземпляров».
- **`[[Prototype]]`** (у объектов) — «куда идти за свойствами, если их нет в самом объекте».
- **Классы** — просто удобный синтаксис; суть — всё та же цепочка прототипов.

---

## Вопросы на собеседовании (простые ответы)

### 1. Что такое прототип?

Объект, на который указывает `[[Prototype]]`. Если у объекта нет свойства, оно ищется в прототипе по цепочке.

### 2. В чём разница между `prototype` и `__proto__`?

`prototype` — свойство функции/класса (шаблон прототипа для экземпляров). `__proto__` — доступ к `[[Prototype]]` у конкретного объекта (лучше использовать `Object.getPrototypeOf`).

### 3. Что делает `new`?

Создаёт объект, связывает его `[[Prototype]]` с `Constructor.prototype`, вызывает конструктор с `this = новый объект`.

### 4. Зачем `extends` и `super`?

`extends` настраивает наследование (цепочку прототипов). `super()` вызывает конструктор родителя, `super.method()` — метод родителя.

