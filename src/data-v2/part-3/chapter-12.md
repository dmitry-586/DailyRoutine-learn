# Глава 12. Формы: валидация и UX ошибок (короткий минимум)

Про формы на собеседованиях обычно спрашивают не “перечисли все `input type`”, а **как сделать форму удобной, понятной и безопасной**. Важно помнить две идеи: валидация влияет на UX, а безопасность обеспечивается на сервере.

---

## 12.1. Семантика формы: без неё всё остальное ломается

Базовый фундамент — нативные элементы и правильные связи:

- у каждого поля должен быть `label` (явный через `for/id` или оборачивающий),
- кнопка отправки должна быть кнопкой (`<button type="submit">`),
- если есть подсказка или ошибка — она должна быть связана с полем (например, через `aria-describedby`).

`label` важен не только для screen readers: он улучшает UX (клик по тексту фокусирует поле) и помогает автозаполнению.

---

## 12.2. Валидация: что делать на клиенте и что обязательно на сервере

### Клиентская валидация

Цель — быстро подсказать пользователю, что исправить. Часто достаточно нативной HTML5-валидации:

- `required`,
- корректный `type` (например, `email`),
- ограничения длины/диапазона (`min`, `max`, `minlength`, `maxlength`),
- `pattern` там, где формат действительно важен.

Нативная валидация хороша тем, что она “из коробки” работает с доступностью и даёт предсказуемое поведение.

### Серверная валидация

Это обязательная часть: на сервере проверяются те же правила (и чаще — больше), потому что клиенту доверять нельзя. На собеседовании это ожидают как “гигиену”: **клиент — для удобства, сервер — для истины**.

---

## 12.3. UX ошибок: как делать, чтобы не раздражать

Главная задача ошибок — помочь быстро исправить ввод, не превращая форму в “борьбу”.

Практичные правила:

- показывать ошибки после попытки отправки и/или после `blur` (когда человек закончил ввод),
- не спамить ошибками при каждом символе (кроме случаев, где это явно полезно),
- писать сообщения конкретно: что не так и как исправить,
- подсвечивать ошибку рядом с полем, а не только “где-то наверху”.

Для доступности ошибок обычно достаточно:

- помечать невалидное поле через `aria-invalid="true"`,
- связывать поле с текстом ошибки через `aria-describedby`,
- для динамических сообщений использовать живую область (например, `role="alert"`/`aria-live`), чтобы читатель озвучил изменения.

---

## 12.4. Доступность и удобство: минимум, который должен быть всегда

- У каждого поля есть `label`.
- Ошибка связана с полем и понятна без цвета (“красная рамка” — это не сообщение).
- Логический порядок табуляции сохранён (полями можно пройтись `Tab`).
- Автозаполнение работает там, где уместно (например, email/пароль/имя) — это реальная экономия времени пользователю.

---

## Вопросы на собеседовании

1. Зачем `label` в формах?  
   `label` даёт полю понятное имя для пользователя и ассистивных технологий. Плюс это практичный UX: по клику на текст метки фокус переходит в поле, а автозаполнение работает надёжнее. Это и про удобство, и про доступность.

2. Когда достаточно HTML5-валидации, а когда нужна кастомная?  
   Нативной HTML5-валидации часто достаточно для базовых вещей: обязательность, тип (email), длина, диапазон. Кастомная валидация нужна, когда правила завязаны на бизнес-логику или требуется единый формат сообщений. Важно: кастомная валидация не должна ухудшать UX и ломать доступность.

3. Где должна быть “главная” валидация?  
   На сервере, потому что клиенту доверять нельзя: пользователь может отключить JS, подменить запрос или отправить данные напрямую. Клиентская валидация нужна, чтобы быстрее подсказать пользователю, но она не заменяет серверные проверки. На клиенте — дружелюбная подсказка, на сервере — гарантия корректности.

4. Как сделать ошибки доступными?  
   Ошибка должна быть связана с полем через `aria-describedby`, поле помечают как невалидное через `aria-invalid="true"`. Если текст ошибки появляется динамически, важно, чтобы он был озвучен (например, через `aria-live`/`role="alert"`). Ошибка не должна быть “только красной рамкой” — нужен текст, который объясняет, что исправить.
