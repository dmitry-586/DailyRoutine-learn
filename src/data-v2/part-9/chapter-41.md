# Глава 41. Сборка: превращение кода в продукт

Представь сборщик как переводчика и логиста в одном лице. Он берет твой современный, понятный человеку код — с TypeScript, JSX, импортами модулей — и превращает его в компактные чанки, которые браузер сможет проглотить максимально быстро. При этом он делает это так, чтобы твоя страница загружалась мгновенно, а пользователь не ждал.

---

## Конвейер трансформации кода

Представь путь файла от сохранения в IDE до появления в браузере. Ты сохраняешь `Component.tsx` с TypeScript и JSX. Что происходит дальше?

Сначала **TypeScript** проверяет типы — он не собирает код, он только проверяет его на этапе разработки. Если типы не совпадают, ты получишь ошибку сразу, а не в браузере пользователя. Это первый этап защиты от ошибок.

Затем код попадает в **транспайлер** (Babel или esbuild). Он преобразует современный JavaScript и TypeScript в совместимый с браузерами формат. JSX превращается в вызовы `React.createElement`, стрелочные функции и деструктуризация преобразуются в совместимый ES5, если нужно. В современных инструментах (Vite, Next.js) это всё «встроено», поэтому отдельный конфиг не нужен почти никогда. Ты просто пишешь TypeScript и JSX, а сборщик сам разбирается, что с этим делать.

Минимальная практическая формула:

```
TypeScript → (Babel/esbuild) → Bundler → Prod-чанки
```

Параллельно с транспиляцией сборщик делает несколько вещей, которые напрямую влияют на скорость первого экрана. Он **удаляет неиспользуемые экспорты** (tree-shaking), уменьшая размер бандла. Он **минифицирует JS и CSS**, убирая пробелы, комментарии и сокращая имена переменных. Он **разделяет код на чанки** по страницам и фичам, чтобы пользователь загружал только то, что нужно сейчас. Он **упорядочивает порядок загрузки ресурсов** для оптимальной производительности и **стабилизирует имена файлов** для кеширования, чтобы браузер мог эффективно использовать кеш.

Всё это для того, чтобы страница загружалась быстро, а пользователь не чувствовал ожидания. Результат — быстрый старт страницы и меньше ошибок в проде, потому что сборщик ловит проблемы на этапе сборки, а не в браузере пользователя.

Но есть важное различие между режимами разработки и продакшена. В режиме разработки тебе нужна скорость: ты меняешь код, и изменения должны появляться мгновенно. Dev сервер даёт тебе горячую замену модулей (HMR) — когда ты меняешь компонент, обновляется только он, а не вся страница. Это делает цикл разработки быстрым и приятным.

В продакшене приоритеты другие: максимальная оптимизация, минификация, tree-shaking, стабильные чанки с предсказуемыми именами для кеширования. Здесь скорость сборки менее важна, чем качество результата. Для больших проектов важно, как быстро пересобирается проект после изменений. Dev сборка должна быть быстрой, даже если prod сборка занимает больше времени. Инкрементальные сборки экономят часы в больших репозиториях — сборщик пересобирает только изменённые части, а не всё с нуля. Полная очистка кеша нужна только при странных ошибках, а не «по привычке». Кеш — это не враг, это инструмент ускорения.

---

## Эволюция сборщиков: от Webpack к Vite

История сборщиков — это история поиска баланса между гибкостью и скоростью. **Webpack** появился, когда нужен был мощный инструмент, который мог собрать что угодно. Он гибкий, зрелый, с огромной экосистемой плагинов, но тяжелее в настройке. Если у тебя нестандартные требования, legacy-код или сложная архитектура, Webpack даст тебе контроль над каждым шагом сборки.

Но у Webpack есть проблема: он пересобирает весь проект при изменении одного файла. Это работает, но медленно. На больших проектах dev сервер может запускаться минутами, а каждое изменение требует пересборки всего бандла.

**Vite** решает это, используя нативные ES модули в dev режиме. Браузер сам загружает модули по требованию, а сборщик только преобразует их на лету. Поэтому сервер запускается мгновенно, а изменения применяются без перезагрузки страницы. В продакшене Vite использует Rollup для создания оптимизированных бандлов. Отличный выбор для новых проектов, где важна скорость разработки.

Vite использует нативные ESM модули в браузере, что избавляет нас от необходимости пересобирать весь проект при изменении одного файла, как это делал Webpack. Браузер сам загружает модули по требованию, а сборщик только преобразует их на лету. Это революция в скорости разработки.

**Turbopack** — это следующий шаг. Это родной сборщик для Next.js, написанный на Rust. Он делает dev режим очень быстрым даже на больших проектах. Экосистема ещё растёт, но для Next.js проектов это перспективный выбор.

Выбор зависит от проекта:

- **Next.js** → Turbopack (или Webpack по умолчанию)
- **Новый SPA** → Vite
- **Сложная/старая система** → Webpack

Главный критерий — требования проекта, а не модность инструмента. Если текущий сборщик решает твои задачи и не тормозит команду, менять его «просто потому что» не стоит. Менять сборщик стоит только если скорость сборки тормозит команду (люди ждут по 5-10 минут каждый раз), нужна специфичная функциональность, которую текущий инструмент не поддерживает, или текущий инструмент упирается в ограничения, которые нельзя обойти.

---

## Source maps: цена отладки в продакшене

Source maps — это возможность видеть исходный код в продакшене при ошибках. Без них ты увидишь минифицированный код, который невозможно читать. Но включение source maps в продакшене имеет свою цену.

**Цена включения source maps:**

- **Увеличение веса бандла** — source maps могут добавить 20-50% к размеру бандла. Это влияет на время загрузки страницы.
- **Риск утечки исходного кода** — source maps содержат исходный код, который может быть доступен всем, кто знает, где искать. Для публичных приложений это может быть проблемой безопасности.
- **Производительность** — браузер должен загружать и обрабатывать source maps при отладке, что может замедлить работу инструментов разработчика.

**Когда включать:**

- **Staging** — всегда. Это позволяет отлаживать проблемы перед релизом без риска для продакшена.
- **Продакшен** — только если есть безопасный доступ и команда понимает риски. Для публичных приложений разумно ограничивать детализацию или использовать отдельные source maps только для критичных частей.

**Альтернативы:**

- Использовать source maps только для критичных частей приложения.
- Генерировать source maps отдельно и хранить их в безопасном месте, недоступном публично.
- Использовать сервисы мониторинга ошибок (Sentry, LogRocket), которые могут работать с source maps безопасно.

Source maps — это инструмент, который нужно использовать осознанно, понимая цену его включения.

---

## Мини-чек-лист для проекта

Убедись, что:

- Выбран инструмент и версия, и это зафиксировано в документации.
- Настроены окружения dev/prod с правильными оптимизациями.
- Понимание, где включены sourcemaps и зачем, и какая цена их включения.
- Бандл анализируется перед релизом (размер, состав чанков).
- У команды есть единые правила сборки, все знают, как запускать проект.

Этого достаточно, чтобы сборка не превратилась в источник проблем.

---

## Вопросы на собеседовании

### 1. В чём ключевое отличие Vite от Webpack?

Vite использует нативные ESM модули для мгновенного старта dev-сервера — браузер сам загружает модули по требованию, а сборщик только преобразует их на лету. Webpack строит полный бандл перед запуском, что медленнее на больших проектах. В продакшене Vite использует Rollup для создания оптимизированных бандлов.

### 2. Что такое Tree-shaking и когда он работает?

Tree-shaking — это процесс удаления неиспользуемого кода. Он эффективен только при использовании ES-модулей, статических импортов и отсутствии побочных эффектов в модулях. Если модуль делает побочные эффекты (например, импортирует CSS), он не будет удалён, даже если его экспорты не используются.

### 3. Зачем нужны Source maps в продакшене?

Source maps позволяют сопоставить сжатый код с исходным для дебага ошибок. Но их стоит включать осторожно: они увеличивают размер бандла на 20-50% и могут раскрыть исходный код публично, что является риском безопасности. Для публичных приложений разумно ограничивать детализацию или использовать отдельные source maps только для критичных частей.

### 4. Как работает конвейер трансформации кода?

TypeScript проверяет типы на этапе разработки, затем транспайлер (Babel или esbuild) преобразует современный JavaScript и JSX в совместимый формат, сборщик склеивает модули в чанки, удаляет неиспользуемое (tree-shaking) и минифицирует результат. В современных инструментах это всё «встроено», поэтому отдельный конфиг не нужен почти никогда.

### 5. Когда стоит менять сборщик?

Только если скорость сборки тормозит команду (люди ждут по 5-10 минут каждый раз), нужна специфичная функциональность, которую текущий инструмент не поддерживает, или текущий инструмент упирается в ограничения, которые нельзя обойти. Менять сборщик «просто потому что новый быстрее» редко стоит усилий, если текущий и так справляется.
