# Глава 42. Оптимизация бандла: логика и последовательность

Цель оптимизации бандла проста: быстрее первый экран и меньше JavaScript для пользователя. Но делать это нужно по шагам, чтобы понимать, зачем именно ты что-то меняешь, а не просто «оптимизировать ради оптимизации».

---

## 42.1. Шаг 1 — понять, что тормозит

Прежде чем что-то оптимизировать, нужно измерить. Какой у тебя размер бандла? Какие чанки самые тяжёлые? Что грузится на первом экране, а что можно отложить?

Без этого легко «оптимизировать» не то. Ты можешь потратить день на оптимизацию библиотеки, которая весит 10 КБ, в то время как основная проблема — это 500 КБ неиспользуемого кода в другом месте.

Используй инструменты анализа бандла (webpack-bundle-analyzer, source-map-explorer) чтобы увидеть реальную картину. Только после этого принимай решения.

---

## 42.2. Шаг 2 — убрать неиспользуемое (tree-shaking)

Tree-shaking — это не магия, это процесс удаления неиспользуемых экспортов. Он работает, если:

- используются ES Modules (не CommonJS);
- импорты статические (не динамические);
- модуль не имеет side-effects (не выполняет код при импорте).

Минимальный пример:

```ts
// Хорошо: ESM + именованные экспорты
import { sum } from './math'
```

Если модуль делает побочные эффекты (например, импортирует CSS или регистрирует глобальные обработчики), он не будет «выкинут», даже если ты не используешь его экспорты.

Важно понимать: tree-shaking работает автоматически, если твой код написан правильно. Не нужно его «включать» — нужно просто не мешать ему работать.

---

## 42.3. Шаг 3 — разделить загрузку (code splitting)

Смысл code splitting простой: не грузить всё сразу. Пользователю нужен только текущий экран, зачем ему код админки, если он смотрит главную страницу?

### Динамический импорт

```tsx
const HeavyChart = lazy(() => import('./HeavyChart'))
```

Это говорит React: «не грузи этот компонент сразу, загрузи его только когда он понадобится».

### Когда это нужно

- Редкие экраны (админка, отчёты, настройки) — пользователь заходит туда раз в месяц, зачем грузить это на главной?
- Тяжёлые библиотеки (графики, редакторы, PDF-просмотрщики) — они могут весить сотни килобайт, но нужны не всем.
- Большие модальные окна — зачем грузить код модалки, если пользователь может её никогда не открыть?

Но не переусердствуй: слишком много «ленивых» чанков создаёт эффект «постоянной подгрузки», когда пользователь видит спиннеры везде. Баланс важнее максимального дробления.

---

## 42.4. Шаг 4 — контролировать импорты

Частая проблема — импорт всей библиотеки, когда нужна только одна функция:

```ts
// Плохо: импортируем всю библиотеку
import _ from 'lodash'
const result = _.debounce(fn, 300)

// Хорошо: импортируем только нужное
import debounce from 'lodash/debounce'
const result = debounce(fn, 300)
```

Для тяжёлых библиотек ищи «лёгкие» альтернативы. Например, вместо `moment.js` (67 КБ) можно использовать `date-fns` (2 КБ при tree-shaking) или нативный `Intl.DateTimeFormat`.

Не тащи весь пакет «на всякий случай». Если функция простая, лучше написать её самому, чем тащить библиотеку ради одной утилиты.

---

## 42.5. Минимальный чек-лист

Убедись, что:

- Бандл измерен — ты знаешь размер и состав.
- Динамические импорты стоят там, где это реально помогает (редкие экраны, тяжёлые компоненты).
- Большие библиотеки загружаются лениво или заменены на лёгкие альтернативы.
- Лишние импорты удалены.

Этого достаточно, чтобы получить реальный выигрыш без лишней сложности.

---

## 42.6. Как измерять правильно

Замеряй **общий размер JS** и **размер первого экрана** — это разные метрики. Первый экран — это то, что пользователь видит сразу, и это критично для воспринимаемой скорости.

Сравнивай до/после одной конкретной правки. Не пытайся оптимизировать всё сразу — так не поймёшь, что реально помогло.

Смотри, какие чанки грузятся на первом экране. Если там код админки или редких фич — это проблема.

Учитывай кеш: повторный заход может быть быстрым, но первый — нет. Оптимизируй для первого визита.

---

## 42.7. Типичные источники «жирного» бандла

Обычно бандл раздувается из-за:

- Библиотек графиков, редакторов и PDF — они могут весить сотни килобайт. Загружай их лениво.
- UI-комплектов с монолитными импортами — если ты импортируешь `import { Button } from '@ui-kit'`, а под капотом подтягивается весь комплект, это проблема.
- Больших утилит, которые можно заменить локальной функцией — `lodash` для одной функции `debounce` это избыточно.
- Дублирования библиотек из-за разных версий — одна и та же библиотека в двух версиях увеличивает бандл вдвое.

---

## 42.8. Что важно для UX

Помни: пользователь ждёт **первый экран**, а не весь сайт. Если главная страница загружается за 2 секунды, а админка за 5 — это нормально, если админка грузится только когда нужна.

Слишком много «ленивых» чанков даёт эффект «постоянной подгрузки» — пользователь видит спиннеры везде, и это хуже, чем один большой бандл.

Баланс важнее максимального дробления. Оптимизируй то, что реально влияет на первый экран, а остальное можно загружать по требованию.

---

## 42.9. Практические правила

- Ленивая загрузка — только для реально редких экранов. Если экран открывается часто, лучше загрузить его сразу.
- Общие библиотеки лучше держать в одном стабильном чанке — так они кешируются и не перезагружаются при навигации.
- Для модалок и редких функций — динамический импорт.
- Для общих компонентов — статический импорт.

---

## 42.10. Ошибки, которые часто делают

- Включают динамический импорт «везде», и UX становится хуже — постоянные спиннеры и задержки.
- Удаляют полифиллы, ломая старые браузеры, если они нужны — оптимизация не должна ломать функциональность.
- Заменяют библиотеку ради размера, теряя функциональность — иногда размер оправдан возможностями.

---

## 42.11. Мини-бюджет производительности

Определи лимиты для команды:

- Размер JS первого экрана (например, не более 200 КБ).
- Максимальный размер одного чанка (например, не более 500 КБ).
- Время загрузки на медленной сети (например, первый экран за 3 секунды на 3G).

Это дисциплинирует и даёт понятные цели. Когда бандл приближается к лимиту, команда знает, что нужно оптимизировать, а не просто «делать меньше».
