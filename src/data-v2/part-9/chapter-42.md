# Глава 42. Оптимизация бандла: стратегия «здорового веса»

Цель оптимизации бандла проста: быстрее первый экран и меньше JavaScript для пользователя. Но делать это нужно по шагам, чтобы понимать, зачем именно ты что-то меняешь, а не просто «оптимизировать ради оптимизации».

---

## Этап 1: Диагностика — сначала замеряем, потом режем

Оптимизация без замеров — это гадание на кофейной гуще, которое часто приводит к тому, что мы чиним то, что и так работает. Весь процесс должен начинаться с анализа: какие чанки (куски кода) являются самыми тяжелыми и что именно попадает на первый экран.

Без этого легко «оптимизировать» не то. Ты можешь потратить день на оптимизацию библиотеки, которая весит 10 КБ, в то время как основная проблема — это 500 КБ неиспользуемого кода в другом месте.

Используй инструменты анализа бандла (webpack-bundle-analyzer, source-map-explorer) чтобы увидеть реальную картину. Только после этого принимай решения.

Важно понимать разницу между **общим размером JS** и тем **«критическим весом»**, который пользователь вынужден скачать для отображения первого кадра. Первый экран — это то, что пользователь видит сразу, и это критично для воспринимаемой скорости. Смотри, какие чанки грузятся на первом экране. Если там код админки или редких фич — это проблема.

Сравнивай до/после одной конкретной правки. Не пытайся оптимизировать всё сразу — так не поймёшь, что реально помогло. Учитывай кеш: повторный заход может быть быстрым, но первый — нет. Оптимизируй для первого визита.

Установите для команды **«бюджет производительности»** — четкие лимиты на размер одного файла и время загрузки на медленной сети. Например:

- Размер JS первого экрана (например, не более 200 КБ).
- Максимальный размер одного чанка (например, не более 500 КБ).
- Время загрузки на медленной сети (например, первый экран за 3 секунды на 3G).

Это дисциплинирует и даёт понятные цели. Когда бандл приближается к лимиту, команда знает, что нужно оптимизировать, а не просто «делать меньше». Оптимизация становится частью культуры разработки, а не разовой акцией.

---

## Этап 2: Статическая очистка — Tree-shaking и контроль импортов

Когда фронт работ понятен, мы приступаем к удалению лишнего. Главный механизм здесь — **tree-shaking**, который, подобно встряхиванию дерева, удаляет «сухие ветки» (неиспользуемые экспорты).

Tree-shaking — это не магия, это процесс удаления неиспользуемых экспортов. Он работает идеально только в мире ES-модулей со статическими импортами и отсутствием побочных эффектов:

- используются ES Modules (не CommonJS);
- импорты статические (не динамические);
- модуль не имеет side-effects (не выполняет код при импорте).

```ts
// Хорошо: ESM + именованные экспорты
import { sum } from './math'
```

Если модуль делает побочные эффекты (например, импортирует CSS или регистрирует глобальные обработчики), он не будет «выкинут», даже если ты не используешь его экспорты.

Важно понимать: tree-shaking работает автоматически, если твой код написан правильно. Не нужно его «включать» — нужно просто не мешать ему работать.

На этом этапе важно пересмотреть свои привычки. Частая проблема — импорт всей библиотеки, когда нужна только одна функция:

```ts
// Плохо: импортируем всю библиотеку
import _ from 'lodash'
const result = _.debounce(fn, 300)

// Хорошо: импортируем только нужное
import debounce from 'lodash/debounce'
const result = debounce(fn, 300)
```

Для тяжёлых библиотек ищи «лёгкие» альтернативы. Например, вместо `moment.js` (67 КБ) можно использовать `date-fns` (2 КБ при tree-shaking) или нативный `Intl.DateTimeFormat`.

Не тащи весь пакет «на всякий случай». Если функция простая, лучше написать её самому, чем тащить библиотеку ради одной утилиты. Обычно бандл раздувается из-за:

- Библиотек графиков, редакторов и PDF — они могут весить сотни килобайт. Загружай их лениво.
- UI-комплектов с монолитными импортами — если ты импортируешь `import { Button } from '@ui-kit'`, а под капотом подтягивается весь комплект, это проблема.
- Больших утилит, которые можно заменить локальной функцией — `lodash` для одной функции `debounce` это избыточно.
- Дублирования библиотек из-за разных версий — одна и та же библиотека в двух версиях увеличивает бандл вдвое.

---

## Этап 3: Динамическая доставка — баланс между скоростью и UX

Когда код очищен, мы разделяем его на части с помощью **code splitting** и динамических импортов. Основная идея в том, чтобы не заставлять пользователя качать админку или тяжелые модальные окна, пока он просто зашел на главную страницу.

Смысл code splitting простой: не грузить всё сразу. Пользователю нужен только текущий экран, зачем ему код админки, если он смотрит главную страницу?

### Динамический импорт

```tsx
const HeavyChart = lazy(() => import('./HeavyChart'))
```

Это говорит React: «не грузи этот компонент сразу, загрузи его только когда он понадобится».

### Когда это нужно

- Редкие экраны (админка, отчёты, настройки) — пользователь заходит туда раз в месяц, зачем грузить это на главной?
- Тяжёлые библиотеки (графики, редакторы, PDF-просмотрщики) — они могут весить сотни килобайт, но нужны не всем.
- Большие модальные окна — зачем грузить код модалки, если пользователь может её никогда не открыть?

Однако здесь кроется ловушка: если дробить код слишком мелко, пользователь будет видеть индикаторы загрузки (spinners) на каждом шагу, что портит впечатление от работы с сайтом.

Помни: пользователь ждёт **первый экран**, а не весь сайт. Если главная страница загружается за 2 секунды, а админка за 5 — это нормально, если админка грузится только когда нужна.

Слишком много «ленивых» чанков даёт эффект «постоянной подгрузки» — пользователь видит спиннеры везде, и это хуже, чем один большой бандл.

**Практические правила:**

- Ленивая загрузка — только для реально редких экранов. Если экран открывается часто, лучше загрузить его сразу.
- Общие библиотеки лучше держать в одном стабильном чанке — так они кешируются и не перезагружаются при навигации.
- Для модалок и редких функций — динамический импорт.
- Для общих компонентов — статический импорт.

Баланс важнее максимального дробления. Оптимизируй то, что реально влияет на первый экран, а остальное можно загружать по требованию.

### Ошибки, которые часто делают

- Включают динамический импорт «везде», и UX становится хуже — постоянные спиннеры и задержки.
- Удаляют полифиллы, ломая старые браузеры, если они нужны — оптимизация не должна ломать функциональность.
- Заменяют библиотеку ради размера, теряя функциональность — иногда размер оправдан возможностями.

---

## Минимальный чек-лист

Убедись, что:

- Бандл измерен — ты знаешь размер и состав.
- Динамические импорты стоят там, где это реально помогает (редкие экраны, тяжёлые компоненты).
- Большие библиотеки загружаются лениво или заменены на лёгкие альтернативы.
- Лишние импорты удалены.
- Установлен бюджет производительности для команды.

Этого достаточно, чтобы получить реальный выигрыш без лишней сложности.

---

## Вопросы на собеседовании

### 1. С чего нужно начинать оптимизацию бандла?

С диагностики. Нужно измерить размер бандла, понять, какие чанки самые тяжёлые, и что именно попадает на первый экран. Без замеров легко оптимизировать не то, что реально тормозит.

### 2. Что такое tree-shaking и когда он работает?

Tree-shaking — это процесс удаления неиспользуемых экспортов. Он работает только при использовании ES-модулей, статических импортов и отсутствии побочных эффектов в модулях.

### 3. Когда использовать динамический импорт?

Для редких экранов (админка, отчёты), тяжёлых библиотек (графики, редакторы) и больших модальных окон. Но не стоит дробить код слишком мелко — это создаёт эффект «постоянной подгрузки» и портит UX.

### 4. В чём разница между общим размером JS и размером первого экрана?

Общий размер JS — это весь JavaScript приложения. Размер первого экрана — это только тот код, который нужен для отображения первого кадра. Оптимизировать нужно в первую очередь первый экран, потому что это критично для воспринимаемой скорости.

### 5. Что такое «бюджет производительности»?

Это четкие лимиты для команды на размер бандла и время загрузки. Например, не более 200 КБ для первого экрана или загрузка за 3 секунды на 3G. Это делает оптимизацию частью культуры разработки, а не разовой акцией.
