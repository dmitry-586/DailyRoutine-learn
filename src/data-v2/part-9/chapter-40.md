# Глава 40. Менеджеры зависимостей и SemVer

Представь, что `package.json` — это не просто список библиотек, а **контракт проекта**. В нём прописано, что нужно для работы приложения, какие инструменты помогают тебе писать код, и какие версии библиотек гарантируют, что всё соберётся одинаково у тебя, у коллеги и на сервере в три часа ночи.

---

## 40.1. package.json как контракт проекта

Когда ты открываешь `package.json`, ты видишь договорённости проекта. В секции `dependencies` лежит всё, что нужно пользователю в браузере — React, Next.js, библиотеки для работы с данными. Это то, что попадает в финальный бандл и отправляется на клиент.

А `devDependencies` — это твой рабочий инструментарий. TypeScript, ESLint, тестовые фреймворки. Они помогают тебе писать код, но пользователю они не нужны. Разделение это не формальность: оно влияет на размер установки, скорость CI и понимание того, что действительно критично для работы приложения.

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18.3.0",
    "next": "^15.0.0"
  },
  "devDependencies": {
    "typescript": "^5.7.0",
    "eslint": "^9.0.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
```

Есть ещё `peerDependencies` — это способ библиотек сказать: «мне нужен React, но не тащи его сам, используй тот, что уже есть в проекте». Это предотвращает дублирование и конфликты версий. А `optionalDependencies` — это вещи, которые «хорошо бы иметь», но если их нет, приложение не сломается.

---

## 40.2. SemVer: язык версий

Semantic Versioning — это не просто три числа через точку. Это способ договориться о том, что означает изменение версии.

- **MAJOR** (1.0.0 → 2.0.0) — «я сломал совместимость, будь осторожен». Это когда API изменился так, что старый код перестанет работать.
- **MINOR** (1.0.0 → 1.1.0) — «я добавил что-то новое, но старое работает как раньше». Новые функции, но без ломающих изменений.
- **PATCH** (1.0.0 → 1.0.1) — «я исправил баг, всё остальное без изменений».

Когда ты пишешь `"react": "^18.3.0"`, ты говоришь менеджеру: «дай мне версию 18.3.0 или любую более новую из серии 18.x, но не переходи на 19.x». Это баланс между получением исправлений и защитой от неожиданных изменений.

- `^1.2.3` — разрешает обновления до 2.0.0 (но не включает её). Это самый частый выбор.
- `~1.2.3` — разрешает только патчи (1.2.4, 1.2.5, но не 1.3.0). Более консервативный вариант.
- `1.2.3` — фиксированная версия, никаких обновлений. Используй, когда нужна максимальная стабильность.

---

## 40.3. Lock-файлы: защита от сюрпризов

Lock-файл — это не просто список версий. Это **полное дерево зависимостей**, зафиксированное в момент, когда всё работало. Представь ситуацию: сегодня у тебя всё собирается, а завтра коллега делает `npm install` и получает другую версию вложенной зависимости, которая ломает сборку.

Lock-файл — это защита от таких сюрпризов в три часа ночи на CI. Он фиксирует не только прямые зависимости, но и все их зависимости, и зависимости зависимостей. Это гарантирует, что у всех будет одинаковое дерево пакетов.

- npm → `package-lock.json`
- pnpm → `pnpm-lock.yaml`
- yarn → `yarn.lock`
- bun → `bun.lockb`

**Правило простое:** lock-файл всегда коммитим в репозиторий. Это не временный файл, это часть проекта. И никогда не смешивай менеджеры в одном проекте — это путь к хаосу.

---

## 40.4. Выбор менеджера: не про модность, а про задачу

Выбор менеджера зависимостей — это не про то, какой инструмент «лучше». Это про то, какой подходит твоей команде и проекту.

**npm** — это дефолтный выбор. Он встроен в Node.js, у него максимальная совместимость, огромная экосистема. Если у тебя стандартный проект и команда без особых требований, npm — безопасный и предсказуемый вариант.

**pnpm** — это скорость и экономия места. Он использует общий store для всех проектов, поэтому не дублирует пакеты на диске. Он жёстче к зависимостям (не даст импортировать то, что не объявлено), что предотвращает скрытые зависимости. Отличный выбор для монорепо и больших проектов.

**Yarn Classic (v1)** — стабильный, проверенный временем, но архитектурно устаревший. Подходит для legacy-проектов, где миграция не оправдана.

**Yarn Berry (v3+)** — это другой подход. По умолчанию он использует PnP (Plug'n'Play), что означает отсутствие `node_modules`. Это очень быстро, но требует правильной настройки IDE и может ломать некоторые инструменты экосистемы. Хорош для крупных репозиториев, где скорость установки критична.

**Bun** — самый быстрый из всех, но менее зрелый. Отличен для экспериментов и pet-проектов, но в продакшене стоит быть осторожным.

---

## 40.5. Практические правила

Выберите **один** менеджер на команду и закрепите это в README. Смешивание менеджеров — это источник проблем.

Коммитьте lock-файл и не меняйте его вручную. Это автоматически генерируемый файл, который отражает реальное состояние зависимостей.

Для CI используйте «чистую» установку: `npm ci` или `pnpm install --frozen-lockfile`. Эти команды гарантируют, что установка будет точно соответствовать lock-файлу, без попыток обновить что-то.

Обновляйте зависимости регулярно, но **мажорные версии** обновляйте только вручную, после проверки changelog и тестирования. Автоматические обновления мажоров — это риск сломать приложение.

И последнее: не тяните тяжёлые пакеты «на всякий случай». Каждая зависимость — это размер бандла, время установки и потенциальная точка отказа. Если библиотека не используется, удали её.
