# Глава 40. Управление зависимостями: от контракта к реализации

Представь, что `package.json` — это не просто список библиотек, а **контракт проекта**. В нём прописано, что нужно для работы приложения, какие инструменты помогают тебе писать код, и какие версии библиотек гарантируют, что всё соберётся одинаково у тебя, у коллеги и на сервере в три часа ночи.

---

## Анатомия проекта и контроль версий

Когда ты открываешь `package.json`, ты видишь договорённости проекта. В секции `dependencies` лежит всё, что нужно пользователю в браузере — React, Next.js, библиотеки для работы с данными. Это то, что попадает в финальный бандл и отправляется на клиент.

А `devDependencies` — это твой рабочий инструментарий. TypeScript, ESLint, тестовые фреймворки. Они помогают тебе писать код, но пользователю они не нужны. Разделение это не формальность: оно влияет на размер установки, скорость CI и понимание того, что действительно критично для работы приложения.

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18.3.0",
    "next": "^15.0.0"
  },
  "devDependencies": {
    "typescript": "^5.7.0",
    "eslint": "^9.0.0"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
```

Есть ещё `peerDependencies` — это способ библиотек сказать: «мне нужен React, но не тащи его сам, используй тот, что уже есть в проекте». Это предотвращает дублирование и конфликты версий. А `optionalDependencies` — это вещи, которые «хорошо бы иметь», но если их нет, приложение не сломается.

Но самое важное поле, которое часто игнорируют — это `engines`. Оно фиксирует версию Node.js, которая нужна для проекта. Это критично для больших команд: без этого у одного разработчика проект собирается на Node.js 20, а у другого падает на Node.js 18 из-за разницы в рантайме. Фиксация версии Node.js предотвращает ситуацию, когда «у меня работает, а у тебя нет» из-за разницы в окружении.

Теперь про версии. Semantic Versioning — это не просто три числа через точку. Это способ договориться о том, что означает изменение версии. **MAJOR** (1.0.0 → 2.0.0) — «я сломал совместимость, будь осторожен». Это когда API изменился так, что старый код перестанет работать. **MINOR** (1.0.0 → 1.1.0) — «я добавил что-то новое, но старое работает как раньше». Новые функции, но без ломающих изменений. **PATCH** (1.0.0 → 1.0.1) — «я исправил баг, всё остальное без изменений».

Когда ты пишешь `"react": "^18.3.0"`, ты говоришь менеджеру: «дай мне версию 18.3.0 или любую более новую из серии 18.x, но не переходи на 19.x». Символ `^` позволяет зависимостям обновляться автоматически в рамках минорных версий, получая исправления и новые функции, но защищая от ломающих изменений. Это баланс между получением исправлений и защитой от неожиданных изменений.

- `^1.2.3` — разрешает обновления до 2.0.0 (но не включает её). Это самый частый выбор, потому что даёт гибкость без риска.
- `~1.2.3` — разрешает только патчи (1.2.4, 1.2.5, но не 1.3.0). Более консервативный вариант для критичных зависимостей.
- `1.2.3` — фиксированная версия, никаких обновлений. Используй, когда нужна максимальная стабильность, но помни: ты не получишь исправления безопасности.

Но вот проблема: даже с такими правилами, сегодня у тебя всё собирается, а завтра коллега делает `npm install` и получает другую версию вложенной зависимости, которая ломает сборку. Это происходит потому, что `package.json` описывает только прямые зависимости, а каждая зависимость имеет свои зависимости, и так далее.

Именно здесь в игру вступает **lock-файл**. Это не просто список версий — это **полное дерево зависимостей**, зафиксированное в момент, когда всё работало. Lock-файл фиксирует не только прямые зависимости, но и все их зависимости, и зависимости зависимостей, гарантируя, что у всех будет одинаковое дерево пакетов.

- npm → `package-lock.json`
- pnpm → `pnpm-lock.yaml`
- yarn → `yarn.lock`
- bun → `bun.lockb`

Lock-файл — это защита от сюрпризов в три часа ночи на CI. Он гарантирует воспроизводимость сборки: то, что работает у тебя, будет работать у коллеги и на сервере. **Правило простое:** lock-файл всегда коммитим в репозиторий. Это не временный файл, это часть проекта. И никогда не смешивай менеджеры в одном проекте — это путь к хаосу.

---

## Выбор инструмента под задачу

Выбор менеджера зависимостей — это не про то, какой инструмент «лучше». Это про то, какой подходит твоей команде и проекту. Каждый инструмент решает свои задачи, и понимание этих задач помогает сделать правильный выбор.

**npm** — это стандарт. Он встроен в Node.js, у него максимальная совместимость, огромная экосистема. Если у тебя стандартный проект и команда без особых требований, npm — безопасный и предсказуемый вариант. Он просто работает, и это его главное преимущество.

**pnpm** — это спасение для экономии места и монорепозиториев. Он использует общий store для всех проектов, поэтому не дублирует пакеты на диске. Если у тебя несколько проектов, pnpm может сэкономить гигабайты места. Он жёстче к зависимостям (не даст импортировать то, что не объявлено), что предотвращает скрытые зависимости и делает зависимости более явными. Отличный выбор для монорепо и больших проектов, где контроль зависимостей критичен.

**Yarn Classic (v1)** — стабильный, проверенный временем, но архитектурно устаревший. Подходит для legacy-проектов, где миграция не оправдана. Если проект уже работает на Yarn v1, менять его «просто потому что» редко стоит усилий.

**Yarn Berry (v3+)** — это другой подход. По умолчанию он использует PnP (Plug'n'Play), что означает отсутствие `node_modules`. Это очень быстро, но требует правильной настройки IDE и может ломать некоторые инструменты экосистемы. Хорош для крупных репозиториев, где скорость установки критична, но готовность команды к настройке окружения важнее скорости.

**Bun** — для тех, кто гонится за скоростью в экспериментальных проектах. Самый быстрый из всех, но менее зрелый. Отличен для экспериментов и pet-проектов, но в продакшене стоит быть осторожным. Если скорость установки критична, а стабильность менее важна — Bun может быть выбором.

---

## Практические правила

Выберите **один** менеджер на команду и закрепите это в README. Смешивание менеджеров — это источник проблем.

Коммитьте lock-файл и не меняйте его вручную. Это автоматически генерируемый файл, который отражает реальное состояние зависимостей.

Для CI используйте «чистую» установку: `npm ci` или `pnpm install --frozen-lockfile`. Эти команды гарантируют, что установка будет точно соответствовать lock-файлу, без попыток обновить что-то.

Обновляйте зависимости регулярно, но **мажорные версии** обновляйте только вручную, после проверки changelog и тестирования. Автоматические обновления мажоров — это риск сломать приложение.

И последнее: не тяните тяжёлые пакеты «на всякий случай». Каждая зависимость — это размер бандла, время установки и потенциальная точка отказа. Если библиотека не используется, удали её.

---

## Вопросы на собеседовании

### 1. Зачем нужны lock-файлы?

Lock-файл фиксирует точные версии всех транзитивных зависимостей, гарантируя, что сборка будет идентичной у всех разработчиков и на CI. Без lock-файла разные разработчики могут получить разные версии вложенных зависимостей, что может привести к проблемам "у меня работает, а у тебя нет".

### 2. В чём разница между `dependencies` и `devDependencies`?

В `dependencies` попадает то, что нужно для работы приложения в браузере (runtime) — React, Next.js, библиотеки для работы с данными. В `devDependencies` — инструменты для разработки, сборки и тестов — TypeScript, ESLint, тестовые фреймворки. Разделение влияет на размер установки, скорость CI и понимание того, что действительно критично для работы приложения.

### 3. Как работает SemVer (символы `^` и `~`)?

Символ `^` позволяет обновлять minor и patch версии (например, `^1.2.3` разрешает обновления до 2.0.0, но не включает её). Символ `~` разрешает только patch версии (например, `~1.2.3` разрешает только 1.2.4, 1.2.5, но не 1.3.0). Это помогает балансировать между безопасностью и получением исправлений.

### 4. Зачем нужно поле `engines` в `package.json`?

Поле `engines` фиксирует версию Node.js, которая нужна для проекта. Это критично для больших команд: без этого у одного разработчика проект собирается на Node.js 20, а у другого падает на Node.js 18 из-за разницы в рантайме. Фиксация версии предотвращает ситуацию, когда «у меня работает, а у тебя нет» из-за разницы в окружении.

### 5. В чём разница между npm, pnpm и Bun?

npm — стандарт, встроен в Node.js, максимальная совместимость. pnpm — экономит место за счёт общего store, жёстче к зависимостям, отличен для монорепо. Bun — самый быстрый, но менее зрелый, хорош для экспериментов. Выбор зависит от задач проекта и готовности команды.
