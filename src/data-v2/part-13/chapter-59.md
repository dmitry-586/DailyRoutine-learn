# Глава 59. Server Components и границы ответственности

Server Components выполняются на сервере и не попадают в клиентский бандл. Это снижает размер JS и ускоряет старт.

---

## 59.1. В чём смысл

- меньше JS на клиенте,
- данные можно получать напрямую на сервере,
- быстрый первый экран.

В отличие от SSR, клиент получает только то, что действительно интерактивно.

---

## 59.2. Server vs Client

**Server Components** — по умолчанию, подходят для:

- загрузки данных,
- статического контента,
- SEO-критичных блоков.

**Client Components** — только когда нужна интерактивность:

- состояние,
- события,
- браузерные API.

Правило: **Server по умолчанию, Client по необходимости**.

**Критически важно:** RSC (Server Components) **не должны** взаимодействовать со сторами (Zustand/Redux). Они работают вне контекста клиентского состояния. Сторы доступны только в Client Components.

---

## 59.3. Границы ответственности (без схем)

Серверные компоненты готовят данные и HTML. Клиентские компоненты принимают готовые данные через props и отвечают за интерактивность. Клиент не должен импортировать серверные компоненты.

---

## 59.4. Простой пример разделения

```tsx
// Server Component
async function ProductPage() {
  const product = await getProduct()
  return <AddToCartButton productId={product.id} />
}

// Client Component
'use client'
function AddToCartButton({ productId }: { productId: string }) {
  return <button>Add to cart</button>
}
```

---

## 59.5. Streaming с useSuspenseQuery

`useSuspenseQuery` позволяет Next.js автоматически стримить контент по мере готовности данных. Это улучшает воспринимаемую производительность:

```typescript
'use client'
import { useSuspenseQuery } from '@tanstack/react-query'

function UserProfile({ userId }: { userId: number }) {
  const { data: user } = useSuspenseQuery({
    queryKey: ['users', userId],
    queryFn: () => fetchUser(userId),
  })

  return <div>{user.name}</div>
}

// В Server Component
export default function Page() {
  return (
    <Suspense fallback={<Skeleton />}>
      <UserProfile userId={123} />
    </Suspense>
  )
}
```

**Преимущества:**
- Данные стримятся по мере готовности
- UI отображается постепенно, без блокировки
- Лучший UX для медленных запросов

---

## 59.6. Server Actions — зачем

Server Actions упрощают мутации: форма вызывает серверную функцию без отдельного API-роута. Это снижает количество кода и ошибок.

---

## 59.7. Короткий чек-лист

- Данные грузим на сервере.
- Интерактивность — только в Client Components.
- Передача данных — через props.
- Сторы (Zustand/Redux) — только в Client Components.

---

## 59.8. Что чаще всего делают неправильно

- Перенос интерактивности в Server Components.
- Использование браузерных API на сервере.
- Попытка использовать сторы в Server Components.
- Слишком большие Client Components, которые тянут весь бандл.

Если сомневаешься — выноси интерактивность в отдельный маленький клиентский компонент.

---

## 59.9. Как думать про границы

Простой принцип:

- Server готовит данные и HTML.
- Client отвечает за события и состояние.
- Сторы работают только на клиенте.

Чем меньше Client — тем быстрее сайт.

---

## 59.10. Server Actions vs API Routes

Server Actions подходят, когда:

- есть формы и мутации,
- нужен простой путь «клиент → сервер».

API Routes остаются полезными, если:

- нужен внешний доступ к API,
- есть сложные интеграции,
- нужно отдавать данные другим клиентам.

---

## 59.11. Производительность и бандл

Server Components уменьшают JS, но:

- большие клиентские библиотеки всё равно попадут в бандл,
- если компонент «use client» — всё дерево ниже тоже клиентское.

Контролируй границы, иначе эффект исчезает.

---

## 59.12. Мини-памятка

- Старайся держать UI-логику в маленьких Client Components.
- Не делай всё «use client» из удобства.
- Разделяй отображение и интерактивность.
- Сторы (Zustand/Redux) — только в Client Components.