# Глава 58. Data fetching и кэширование в Next.js

Главная идея: в App Router данные лучше получать на сервере, а кэширование выбирать по типу контента.

---

## 58.1. Почему не нужен useEffect

В Server Components запросы делаются прямо в компоненте — это нормально и правильно для Next.js.

`useEffect` нужен только в Client Components, когда:

- используется браузерный API,
- данные зависят от действий пользователя,
- нужен эффект после рендера.

Итог: **на сервере — без useEffect, на клиенте — с useEffect или React Query**.

---

## 58.2. Три режима кэша, которые реально нужны

- **Статический контент** — кэш навсегда (по умолчанию).
- **Периодическое обновление** — `revalidate`.
- **Всегда свежие данные** — `cache: 'no-store'`.

Минимальные примеры:

```ts
fetch(url) // статично
fetch(url, { next: { revalidate: 3600 } }) // обновлять раз в час
fetch(url, { cache: 'no-store' }) // всегда свежие
```

---

## 58.3. Как выбрать режим на практике

- Маркетинг/документация → статично.
- Каталог/цены → `revalidate`.
- Кабинет/дашборд → `no-store`.

---

## 58.4. Производительность без лишней сложности

- Параллель `Promise.all` для независимых запросов.
- Streaming/Suspense, если часть страницы может подгружаться позже.

Этого достаточно для большинства проектов.

---

## 58.5. Где нужен клиентский data fetching

Клиентский запрос уместен, если:

- данные зависят от действий пользователя,
- нужен частый рефетч без перезагрузки страницы,
- важно «живое» обновление в UI.

В таком случае используйте React Query или SWR, а `useEffect` — только для простых кейсов.

---

## 58.6. Про useEffect и «плохой подход»

`useEffect` не плох сам по себе. Плохой подход — использовать его там, где данные должны быть на сервере.

Правило:

- данные для первого экрана — на сервере,
- интерактивные обновления — на клиенте.

Так вы и UX улучшаете, и избегаете лишнего JS.

---

## 58.7. Кеш и консистентность

- `revalidate` подходит, если данные могут быть «почти свежими».
- `no-store` обязателен для персональных данных.
- Внутри одного запроса Next.js может дедуплицировать одинаковые fetch.

Это помогает не дублировать запросы.

---

## 58.8. Когда нужна принудительная ревалидация

Если данные меняются по событию (создание, удаление):

- используйте `revalidatePath`,
- или `revalidateTag`, если настроены теги.

Это даёт контроль без полного отключения кеша.

---

## 58.9. Практическая схема выбора

- Контент не меняется → статично.
- Меняется раз в часы → `revalidate`.
- Меняется постоянно → `no-store`.
- Нужен интерактив → клиентский запрос.

Это закрывает 90% кейсов.