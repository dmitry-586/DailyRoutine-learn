# Глава 51. Инструменты тестирования: Unit/Integration/E2E и как их запускать

В прошлой главе мы договорились: тесты — это не “галочка”, а способ жить спокойнее. Теперь давай про практику: что именно ставят на проекте и как сделать так, чтобы тесты не были отдельной болью.

Я предлагаю думать не “какой пакет скачать”, а “какой вопрос мы хотим закрыть”:

- быстро проверить логику и поведение компонентов;
- проверить интеграцию с API (и ошибки тоже);
- прогнать ключевой пользовательский сценарий “как в жизни”;
- получить удобный цикл разработки: написал → запустил → понял, что сломалось.

---

## 51.1. Карта инструментов: кто за что отвечает

Типовой стек (и его чаще всего достаточно):

- **Unit/Integration**: `Vitest` (или `Jest`) + `@testing-library/react`
- **Моки API “как по-настоящему”**: MSW (`msw`)
- **E2E**: `Playwright`
- **Покрытие**: coverage из Vitest/Jest (не культ, а индикатор)
- **Статика до тестов**: ESLint + Prettier (это не тесты, но ловят ошибки раньше тестов)

Смысл карты простой: разные проблемы дешевле решать разными инструментами.

---

## 51.2. Vitest vs Jest: выбираем без фанатизма

### Vitest

Хорош, когда хочется современного DX:

- быстрый запуск и удобный watch;
- отлично дружит с Vite-экосистемой;
- “упал тест” обычно читается без расшифровки.

### Jest

Хорош, когда проект уже живёт в Jest-мире:

- де-факто стандарт в огромном количестве репозиториев;
- много готовых примеров/интеграций;
- мигрировать “просто потому что Vitest моднее” редко стоит усилий.

### Практическое правило

- новый проект + Vite → чаще берут **Vitest**;
- старый проект/команда с привычками → чаще берут **Jest**;
- лучший раннер — тот, который **не мешает** и запускается за секунды.

---

## 51.3. React Testing Library: писать тесты “языком пользователя”

Testing Library ценят не за API, а за подход:

- ищем элементы так, как их “видит” пользователь (текст, role, label);
- проверяем поведение и результат на экране;
- избегаем тестов вида “проверим, что вызвалась внутренняя функция”.

Если тест читается как мини-история — он обычно живёт долго:

- «пользователь нажал кнопку»
- «увидел ошибку/успех»
- «форма отправилась/не отправилась»

И это сильно снижает шанс, что тест сломается при нормальном рефакторинге.

---

## 51.4. Моки: как не превратить тесты в театральную постановку

Моки нужны, чтобы сделать тест быстрым и детерминированным. Но “перемокать” — очень легко.

### Что обычно мокают (и это нормально)

- сеть (`fetch`, `axios`) — чтобы не зависеть от бэка;
- время (таймеры, `Date`) — чтобы сценарии не дрожали;
- тяжёлые внешние интеграции (карты, аналитика) — если они не цель теста.

### Что лучше не мокать без причины

- собственную бизнес-логику “просто чтобы было проще”;
- важные куски поведения компонента (иначе вы не проверяете продукт).

### Нормальная стратегия по уровням

- **Unit**: мокаете всё вокруг, проверяете маленькую логику.
- **Integration**: мокаете только внешнее (API), а внутри приложения пусть всё работает по-настоящему.

Если вам постоянно приходится мокать половину приложения, это часто намёк: границы модулей/слоёв стоит сделать чище.

---

## 51.5. MSW: мок API без ощущения фальши

MSW хорош тем, что вы не подменяете `fetch` руками. Вы задаёте “серверные ответы”, а приложение делает запросы как обычно.

Почему это обычно ощущается лучше:

- тесты остаются похожими на реальную работу приложения;
- проще покрывать негативные сценарии (400/401/500);
- меньше “магии” и случайных моков в каждом тесте.

Если приложение активно общается с API, MSW обычно окупается очень быстро.

---

## 51.6. E2E на Playwright: минимум, который даёт максимум пользы

E2E — самый дорогой уровень. Поэтому цель не “покрыть всё”, а защитить самые болезненные регрессы.

Обычно достаточно 3–7 сценариев:

- логин/выход (если есть);
- критичная форма (регистрация/оплата/создание заказа);
- главный happy-path продуктового сценария.

Playwright часто выбирают за практичность:

- хорошие ожидания и дебаг;
- артефакты (trace/скриншоты/видео) экономят часы;
- параллельный прогон помогает держать скорость.

---

## 51.7. Запуск локально и в CI: сделать “ритуал”, а не “танец с бубном”

Плохой знак — когда тесты запускают только “перед релизом, потому что страшно”.
Хороший знак — когда у команды есть простой ритм.

Что помогает:

- локально — быстрый watch-режим для unit/integration;
- в CI — стабильный прогон и понятный вывод ошибок;
- E2E — отдельным джобом (или хотя бы перед релизом), чтобы не тормозить каждый PR.

Самое важное правило: **быстрее и стабильнее = тесты запускают чаще**.

---

## 51.8. Как разбирать падения (и не ненавидеть тесты)

Когда тест упал, есть три причины:

- **сломался код** (это хорошо: тест вас спас);
- **сломался тест** (ожидание было неверным или тест хрупкий);
- **сломалось окружение** (flaky/тайминги/нестабильность).

Мини-чек-лист, который реально помогает:

- что именно ожидалось и что получили?
- не используем ли мы таймауты вместо ожидания события?
- если это E2E — смотрим trace/видео: там обычно сразу видно “где жизнь пошла не так”.

---

## 51.9. Где хранить тесты: рядом с кодом или отдельно

Есть два рабочих подхода — выберите один и держитесь его.

1) **Рядом с кодом** (`Component.test.tsx` рядом с `Component.tsx`)
- удобно менять код и тест вместе;
- тесты редко “отрываются” и не превращаются в музей.

2) **Отдельная папка** (`__tests__/`)
- иногда удобно для больших модулей;
- но есть риск, что тесты перестанут обновлять синхронно с кодом.

Важнее не “правильность”, а единообразие внутри репозитория.

---

## 51.10. Минимальные команды, которые реально нужны

Не надо 20 скриптов. На большинстве проектов хватает:

- `test` — прогон unit/integration;
- `test:watch` — быстрый цикл разработки;
- `test:e2e` — E2E сценарии;
- `test:coverage` — иногда перед большим рефакторингом.

Если команда не понимает, какую команду запускать, тесты начинают игнорировать. Если понимает — тесты становятся привычкой.

---

## 51.11. Мини-чек-лист “у нас нормальная тестовая система”

- Unit/integration прогоняются достаточно быстро, чтобы их запускали в работе.
- Нет flaky-тестов, которые “переезжают” перезапуском CI.
- E2E покрывают только критичные сценарии, а не всё подряд.
- Падение теста даёт понятный диагноз (что сломалось и где смотреть).

Если эти пункты выполнены — тесты перестают быть обязанностью и становятся поддержкой.
