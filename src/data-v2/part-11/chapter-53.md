# Глава 53. TanStack Query: мутации, invalidation, optimistic updates, prefetch и infinite queries

Мутации, инвалидация, optimistic updates и prefetch — продвинутые возможности TanStack Query для эффективной работы с изменениями данных и оптимизации UX.

---

## 53.1. useMutation: изменение данных

`useMutation` — хук для операций, изменяющих данные на сервере (POST, PUT, PATCH, DELETE).

**Ключевые отличия от useQuery:**

- Не выполняется автоматически — нужно вызвать `mutate()`
- Не кешируется — каждый вызов отправляет запрос
- Имеет колбэки `onSuccess`, `onError`, `onSettled` для обработки результата

**Основные свойства:**

- **mutate(data)** — запускает мутацию (fire-and-forget)
- **mutateAsync(data)** — возвращает Promise (для await)
- **isPending** — мутация выполняется
- **isSuccess/isError** — результат мутации
- **reset()** — сброс состояния

**После успешной мутации** обычно нужно инвалидировать связанные запросы через `queryClient.invalidateQueries()`, чтобы UI обновился.

---

## 53.2. Invalidation (инвалидация)

Инвалидация помечает данные как устаревшие и вызывает их автоматическое обновление.

**Зачем нужна инвалидация?**

После мутации (создание, обновление, удаление) кешированные данные устарели. Инвалидация сообщает TanStack Query: «эти данные нужно обновить».

**Стратегии инвалидации:**

1. **Широкая** — `invalidateQueries({ queryKey: ['users'] })` обновит ВСЕ запросы пользователей
2. **Точечная** — `invalidateQueries({ queryKey: ['users', 'detail', 123] })` обновит только конкретного пользователя
3. **С предикатом** — `predicate: (query) => ...` для сложной логики выбора

**Рекомендация:** используйте точечную инвалидацию. Это сохраняет неизмененные данные в кеше и сокращает количество запросов.

**Типичный паттерн:** в `onSuccess` мутации инвалидируйте связанные списки и конкретную сущность.

---

## 53.3. Optimistic Updates

Optimistic updates — обновление UI **до** получения ответа от сервера. Пользователь видит мгновенный результат, а если запрос упадёт — откат к предыдущему состоянию.

**Когда использовать:**

- Простые операции с высокой вероятностью успеха (лайк, переключение статуса)
- Критично быстрый отклик UI
- Можно легко откатить изменения

**Алгоритм реализации:**

1. **onMutate** — отменяем активные запросы, сохраняем предыдущее состояние, обновляем кеш оптимистично
2. **onError** — откатываем к сохранённому состоянию при ошибке
3. **onSettled** — инвалидируем данные для синхронизации с сервером

**Важно:** всегда сохраняйте предыдущее состояние для отката! Без этого при ошибке пользователь увидит невалидные данные.

---

## 53.4. Prefetch (предзагрузка)

Предзагрузка позволяет загрузить данные **до** того, как они понадобятся. Когда пользователь перейдёт на страницу — данные уже в кеше.

**Два подхода:**

### prefetchQuery — загрузка по событию

Загружаем данные при наведении на ссылку. К моменту клика данные уже в кеше, страница открывается мгновенно.

**Используйте когда:** пользователь скорее всего перейдёт по ссылке (hover на карточке).

### initialData — использование существующих данных

Берём данные из уже загруженного списка как начальные для детальной страницы. UI рендерится мгновенно с базовой информацией, пока загружаются полные данные.

**Используйте когда:** список уже содержит часть данных для детальной страницы (например, имя и аватар пользователя).

---

## 53.5. Infinite Query (бесконечные списки)

`useInfiniteQuery` — специальный хук для пагинации и бесконечной прокрутки.

**Отличия от обычного useQuery:**

- Хранит массив страниц `data.pages`, а не один результат
- Имеет `fetchNextPage()` и `fetchPreviousPage()` для навигации
- `getNextPageParam` определяет, есть ли следующая страница

**Ключевые свойства:**

- **data.pages** — массив всех загруженных страниц
- **hasNextPage** — есть ли ещё данные
- **fetchNextPage()** — загрузить следующую страницу
- **isFetchingNextPage** — загружается ли следующая страница

**Два варианта UX:**

1. **Кнопка «Загрузить ещё»** — пользователь сам решает, когда загружать
2. **Intersection Observer** — автоматическая загрузка при скролле к концу списка

**Рекомендация:** для бесконечного скролла используйте `react-intersection-observer` с `useInView()` хуком.

---

## 53.6. Dependent Queries (зависимые запросы)

Иногда запрос зависит от результата другого запроса. Например: сначала загрузить пользователя, потом его посты.

**Решение:** параметр `enabled`

Запрос выполняется только когда `enabled: true`. Это позволяет выстраивать цепочки зависимых запросов.

**Типичные случаи:**

- Загрузка связанных данных (user → posts)
- Запрос после получения ID из другого запроса
- Условная загрузка (только для авторизованных)

**Важно:** `enabled` может быть любым boolean выражением: `enabled: !!user`, `enabled: isAuthenticated`, `enabled: id > 0`.

---

## 53.7. Глобальная обработка ошибок

Настройте retry-логику на уровне `QueryClient`, чтобы не дублировать код в каждом запросе.

**Рекомендации по retry:**

- **404** — не повторять (ресурс не существует)
- **401/403** — не повторять, редирект на логин
- **5xx и сетевые ошибки** — повторить 2-3 раза с exponential backoff

**Exponential backoff** — увеличение задержки между попытками: 1с → 2с → 4с. Это снижает нагрузку на сервер при проблемах.

**Глобальный onError для мутаций:**

- Показ toast с сообщением об ошибке
- Логирование в систему аналитики
- Редирект при 401

**Преимущество:** вся логика обработки ошибок в одном месте, легко поддерживать и менять.

---

## Вопросы на собеседовании

### 1. Что такое optimistic update?

Обновление UI до получения ответа от сервера для мгновенного UX. При ошибке выполняется откат.

### 2. Как работает invalidation?

Помечает данные как устаревшие и вызывает их обновление. Можно точечно инвалидировать через query keys.

### 3. Зачем нужен prefetch?

Предзагрузка данных перед навигацией для мгновенной отрисовки страницы.

### 4. Что такое infinite query?

Для пагинации и бесконечной прокрутки. Объединяет страницы в один массив.

### 5. Как обрабатывать ошибки в мутациях?

Через `onError` в мутации или глобально в `defaultOptions.mutations.onError`.
