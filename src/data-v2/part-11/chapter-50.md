# Глава 50. Философия тестирования: стратегия вместо бюрократии

Про тесты часто говорят как про «обязательную галочку». На реальном проекте это обычно заканчивается двумя крайностями:

- «тестов нет», и каждый рефакторинг похож на прогулку по минному полю;
- «тестов слишком много», и команда начинает ненавидеть любые изменения.

Цель этой главы — не "воспитать правильного тестировщика", а дать ощущение контроля: **что тестировать**, **почему это окупается**, и **как не превратить тестирование в бюрократию**.

---

## Что такое тест (по-взрослому)

Тест — это договорённость: *«когда мы делаем X, система должна вести себя как Y»*.

Не «проверим строчку кода», не «померяем покрытие», а именно поведение. Код можно переписать десять раз, а поведение (если продукт жив) останется тем же.

Хороший тест отвечает на два вопроса:

- **какое поведение мы защищаем**;
- **почему это поведение важно** (чем больно, если сломается).

---

## Экономика и риски тестирования

Представь обычную неделю разработки. Ты меняешь валидацию формы: «ничего серьёзного, просто поправить правило». PR зелёный, ревью пройдено, релиз — и через два дня прилетает баг: часть пользователей не может отправить форму, потому что один из крайних кейсов перестал работать.

Тесты в таких местах работают как **страховка от регресса**. Они дают **ранний сигнал** (сломалось в PR, а не в проде), позволяют **рефакторить смелее**, потому что есть "охранные" проверки, и сохраняют **знание о договорённостях**: какие кейсы считаются важными, какие ошибки должны показываться, что нельзя ломать.

Важно: тесты не делают код идеальным. Они делают изменения **менее страшными**.

Но как любая страховка, тесты имеют цену. Тесты начинают мешать, когда тестируют **реализацию**, а не поведение (любой рефакторинг ломает тесты), пишут **E2E на всё**, и прогон занимает вечность, злоупотребляют **моками**, и тесты превращаются в «симуляцию симуляции», или копят **flaky-тесты**, и команда перестаёт доверять CI.

Простой критерий: если тесты чаще мешают, чем помогают — проблема не в тестировании как идее, а в выбранной стратегии.

На фронтенде чаще всего используют три уровня:

- **Unit** — маленькие куски логики (функции, форматирование, вычисления, редьюсеры).
- **Integration** — несколько частей вместе дают нужное поведение (компонент + хук + работа с данными).
- **E2E** — сценарий глазами пользователя (открыл страницу → сделал действие → получил результат).

Это не про теорию, это про **экономику**:

- **Unit тесты дешёвые**: быстрые (миллисекунды), предсказуемые, не зависят от окружения, легко запускать локально.
- **Integration дороже**: больше контекста, больше причин падения, медленнее unit, но быстрее E2E.
- **E2E самые дорогие**: медленные (секунды или минуты), хрупкие, зависят от окружения (браузер, сеть, сервер), сложно отлаживать.

Поэтому нормальный баланс выглядит так: **много unit**, **достаточно integration**, **минимум E2E на критичные сценарии**.

Если ты пишешь E2E на каждую кнопку, прогон тестов будет занимать часы, и команда перестанет их запускать. Если пишешь только unit, можешь пропустить проблемы интеграции. Баланс — это про то, чтобы получить максимум пользы при минимуме затрат.

Ставь тест там, где у регресса будет цена. Обычно это:

- **бизнес-правила**: расчёты, ограничения, форматирование, скрытые условия;
- **критичные формы**: регистрация, оплата, создание заказа, любые «точки денег»;
- **границы UX**: loading/error/empty state, ошибки валидации, запретные состояния;
- **интеграции**: авторизация, роли, доступы, обработка ошибок от API.

А вот что часто не нужно тестировать автотестами:

- верстку "пиксель в пиксель";
- сторонние библиотеки "на доверии" (их тестируют авторы библиотек);
- мелкие декоративные компоненты без поведения.

---

## Тестовое покрытие: почему 100% — это вредная метрика

Тестовое покрытие (Coverage) — это процент кода, который выполняется тестами. Это полезная метрика, но она может стать вредной, если превращается в самоцель.

**Почему 100% покрытие — это часто вредная метрика:**

- **Тесты ради тестов** — команда начинает писать тесты не для защиты поведения, а для повышения метрики. Это приводит к тестам, которые проверяют тривиальные вещи и не дают реальной пользы.
- **Ложное чувство безопасности** — высокое покрытие не означает, что код работает правильно. Можно иметь 100% покрытие и при этом пропустить критичные баги.
- **Замедление разработки** — поддержка тестов на каждую строчку кода замедляет разработку и делает рефакторинг болезненным.

**Что важнее покрытия:**

- **Покрытие критичных путей** (happy paths) — тестируй то, что действительно важно для пользователя, а не каждую строчку кода.
- **Качество тестов** — лучше иметь 50% покрытия качественными тестами, чем 100% покрытие тестами, которые не дают пользы.
- **Баланс** — покрытие должно расти вместе с проектом, но не быть самоцелью.

**Практическое правило:**

Используй покрытие как индикатор, а не как цель. Если покрытие низкое в критичных местах — это сигнал. Если покрытие высокое, но тесты не ловят баги — это тоже сигнал. Покрытие должно помогать принимать решения, а не становиться бюрократией.

---

## TDD: когда помогает, а когда раздражает

TDD — это цикл:

1. **Red** — пишем тест на поведение, которого ещё нет (он падает).
2. **Green** — делаем минимальную реализацию, чтобы тест прошёл.
3. **Refactor** — приводим код в порядок, не меняя поведение.

TDD особенно полезен там, где вы заранее хотите "зацементировать" договорённости:

- сложная логика;
- спорные кейсы;
- код, который будет жить долго и часто меняться.

Но если вы "нащупываете UI" или экспериментируете с дизайном, TDD может замедлять. Это нормально. TDD — инструмент, а не режим "навсегда".

---

## Культура чистого тестирования

### Думай сценариями

Хорошее имя теста читается как фраза:

- «показывает ошибку, если email некорректный»;
- «не отправляет форму, пока пользователь не согласился с условиями»;
- «после успешного сохранения показывает уведомление и очищает форму».

Если тест невозможно назвать нормально, обычно это знак: сценарий размыт или тест пытается проверить слишком много сразу.

### Держи структуру простой

Почти любой тест можно разложить на:

- **Arrange**: подготовили данные/состояние,
- **Act**: сделали действие,
- **Assert**: проверили результат.

Если тест превращается в «роман на 200 строк», чаще всего виноват не тест, а слишком большой компонент/непонятные границы ответственности.

### Flaky-тесты: как не потерять доверие к тестам

Flaky-тест — это когда «то проходит, то падает». И это хуже отсутствия тестов, потому что команда перестаёт верить результатам.

Типовые причины:

- ожидания через таймауты вместо ожидания события;
- общие тестовые данные (тесты влияют друг на друга);
- зависимость от порядка выполнения;
- асинхронщина без явных ожиданий.

Правило простое: **flaky-тест — это баг**, его нужно чинить, а не "перезапускать CI до победы".

### Как внедрять тесты на проекте, где их почти нет

Рабочий путь без героизма:

- начни с **критичных сценариев**, где регресс стоит денег/репутации;
- добавляй тест при **каждом багфиксе** (идеальная точка: ты уже понял проблему);
- новый код — с тестом (пусть минимальным, но чтобы привычка закрепилась);
- рефакторинг без тестов опаснее: сначала стабилизируй поведение, потом переписывай.

Так тесты растут вместе с продуктом и не выглядят навязанной бюрократией.

---

## Тесты в CI: что важно, чтобы это работало

CI должен давать два ощущения:

- **быстро** (иначе никто не ждёт и начинают "обходить" процесс);
- **надёжно** (иначе никто не верит).

Практические ориентиры:

- unit/integration — быстрый прогон на каждый PR;
- E2E — отдельным джобом или перед релизом (в зависимости от проекта);
- если тесты становятся медленными — это сигнал улучшать стратегию, а не "терпеть".

Если после этой главы у тебя осталось ощущение «тесты — это про спокойствие», значит мы попали в цель.

---

## Вопросы на собеседовании

### 1. Что такое «Пирамида тестов» и в чём её экономический смысл?

Пирамида тестов — это распределение тестов по уровням: много дешёвых и быстрых Unit-тестов (миллисекунды, не зависят от окружения), меньше интеграционных (больше контекста, медленнее unit) и минимум дорогих и медленных E2E-тестов (секунды или минуты, зависят от окружения). Экономический смысл в том, чтобы получить максимум пользы при минимуме затрат: если писать E2E на каждую кнопку, прогон будет занимать часы, и команда перестанет их запускать.

### 2. Что такое Flaky-тесты и чем они опасны?

Flaky-тесты — это нестабильные тесты, которые падают без изменений в коде («то проходит, то падает»). Они опасны тем, что команда перестаёт доверять результатам CI и начинает игнорировать падения тестов. Типовые причины: ожидания через таймауты вместо ожидания события, общие тестовые данные, зависимость от порядка выполнения. Flaky-тест — это баг, его нужно чинить, а не "перезапускать CI до победы".

### 3. Что стоит тестировать на фронтенде в первую очередь?

Бизнес-логику (расчёты, ограничения, форматирование), критические пути (оплата, регистрация, создание заказа — любые «точки денег»), границы UX (loading/error/empty state, ошибки валидации) и сложные интеграции (авторизация, роли, доступы, обработка ошибок от API), где цена ошибки велика. Не стоит тестировать верстку "пиксель в пиксель", сторонние библиотеки или мелкие декоративные компоненты без поведения.

### 4. Почему 100% покрытие — это вредная метрика?

100% покрытие часто ведёт к написанию тестов ради тестов, а не для защиты поведения. Это создаёт ложное чувство безопасности (высокое покрытие не означает, что код работает правильно) и замедляет разработку (поддержка тестов на каждую строчку делает рефакторинг болезненным). Важнее покрывать критичные пути (happy paths) качественными тестами, чем каждую строчку кода.

### 5. Что такое TDD и когда он полезен?

TDD — это цикл: Red (пишем тест на поведение, которого ещё нет), Green (делаем минимальную реализацию), Refactor (приводим код в порядок). TDD полезен для сложной логики, спорных кейсов и кода, который будет жить долго и часто меняться. Но если вы "нащупываете UI" или экспериментируете с дизайном, TDD может замедлять. TDD — инструмент, а не режим "навсегда".
