# Глава 43. Рендеринг и reconciliation, keys

React — это библиотека для декларативного описания интерфейсов, основанная на идее, что **UI — это функция от состояния**. Понимание процесса рендеринга и reconciliation критично для эффективной работы с React.

---

## 43.1. Virtual DOM и Fiber

### Что такое Virtual DOM

**Virtual DOM** — это объектное представление реального DOM в памяти JavaScript.

Когда ты пишешь JSX:

```jsx
const element = <h1 className='title'>Hello</h1>
```

Под капотом это компилируется в вызов `React.createElement`:

```javascript
React.createElement('h1', { className: 'title' }, 'Hello')
```

Который возвращает обычный JavaScript-объект:

```javascript
{
  type: "h1",
  props: {
    className: "title",
    children: "Hello"
  }
}
```

Это и есть Virtual DOM элемент — легковесное представление того, как должен выглядеть реальный DOM.

### Зачем нужен Virtual DOM

Прямые операции с DOM **дорогие**. Каждое изменение:

- вызывает пересчёт стилей (reflow);
- может вызвать перерисовку (repaint);
- может затронуть другие элементы (каскадные обновления).

React решает это через **алгоритм reconciliation**:

1. **Строит Virtual DOM** — создаёт объектное представление желаемого состояния UI.
2. **Сравнивает с предыдущей версией** (diffing) — находит минимальный набор изменений.
3. **Минимально обновляет реальный DOM** — применяет только найденные различия.

Это позволяет React эффективно обновлять только изменённые части интерфейса, избегая лишних операций с DOM.

### Пример: почему Virtual DOM эффективнее

Представь, что у тебя есть список из 1000 элементов, и изменился только один:

**Без Virtual DOM (наивный подход):**

- нужно вручную найти, какой элемент изменился;
- обновить его в DOM;
- убедиться, что не сломались другие элементы.

**С Virtual DOM:**

- React сравнивает два дерева объектов в памяти (быстро);
- находит, что изменился только один элемент;
- обновляет только этот элемент в реальном DOM.

### Fiber Architecture

**Fiber** — это внутренняя архитектура React, которая пришла на смену старому стековому алгоритму в React 16.

**Что она даёт:**

- **приоритеты обновлений** — React может отложить менее важные обновления (например, анимации) и сначала обработать критичные (ввод пользователя);
- **прерываемый рендеринг** — React может «поставить на паузу» рендер сложного компонента, чтобы обработать более важную задачу;
- **concurrent features** — основа для Suspense, `startTransition`, `useDeferredValue` и других современных возможностей.

Проще говоря: React может ставить рендер «на паузу», чтобы интерфейс оставался отзывчивым. Это основа для всех concurrent features.

**Важно понимать:**

- Fiber — это не то, что ты используешь напрямую в коде;
- это внутренняя реализация, которая делает React быстрее и отзывчивее;
- на собеседованиях важно показать, что ты понимаешь, **зачем** это нужно, а не зубришь детали реализации.

---

## 43.2. Процесс рендера

Когда изменяется состояние компонента, React запускает процесс обновления:

1. **Изменилось состояние** — вызван `setState` или обновлён проп.
2. **Компонент перерендерился** — вызвалась функция компонента заново.
3. **React сравнил деревья** (diffing) — сравнение нового Virtual DOM с предыдущим.
4. **Применил минимальные изменения в DOM** — обновление только изменённых узлов.

### Важно понимать: рендер ≠ обновление DOM

**Рендер** — это вызов функции компонента. React может вызывать компонент много раз, даже если DOM не изменился.

**Обновление DOM** — это физическое изменение в браузере. React обновляет DOM только при необходимости.

```jsx
function Counter({ count }) {
  console.log('Рендер компонента')

  return <div>{count}</div>
}

// Если count не изменился, компонент всё равно может перерендериться,
// но React не будет обновлять DOM, если результат JSX идентичен
```

---

## 43.3. Reconciliation (согласование)

Reconciliation — это процесс сравнения двух деревьев Virtual DOM и определения минимального набора изменений для обновления реального DOM.

### Алгоритм diffing

React использует эвристический алгоритм O(n) для сравнения деревьев:

1. **Сравнение по типу элемента:**
   - Если типы разные — React заменяет старое дерево новым.
   - Если типы одинаковые — React обновляет только изменённые свойства.

2. **Сравнение по ключам (keys):**
   - React использует `key` для идентификации элементов в списках.
   - Это позволяет эффективно обновлять элементы при изменении порядка.

### Пример reconciliation

```jsx
// До
<ul>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Orange</li>
</ul>

// После (добавлен элемент в начало)
<ul>
  <li key="0">Grape</li>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Orange</li>
</ul>
```

**С ключами:**
- React понимает, что элементы с ключами 1, 2, 3 не изменились.
- Добавляет только новый элемент с ключом 0.
- Обновляет DOM минимально.

**Без ключей (или с индексами):**
- React может неправильно сопоставить элементы.
- Может пересоздать все элементы вместо добавления одного.
- Может потерять состояние компонентов.

---

## 43.4. Keys: зачем они нужны

При рендеринге списков React требует уникальный `key` для каждого элемента:

```jsx
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' }
]

<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

** `key` нужен React, а не вам.**

`key` помогает React:

- отслеживать, какие элементы изменились, добавились или удалились;
- эффективно обновлять только изменённые элементы;
- сохранять состояние компонентов при изменении порядка элементов.

### Правила для `key`

- должен быть **уникальным** среди siblings (братьев и сестёр);
- должен быть **стабильным** (не меняться между рендерами);
- лучше использовать **ID из данных**, а не индекс массива.

### Почему индекс — плохой `key`

```jsx
//  Плохо: индекс меняется при удалении/добавлении элементов
{
  items.map((item, index) => <li key={index}>{item.name}</li>)
}

//  Хорошо: ID стабилен
{
  items.map((item) => <li key={item.id}>{item.name}</li>)
}
```

**Проблема с индексом:**

```jsx
// Исходный список
[
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' }
]

// После удаления первого элемента
[
  { id: 2, name: 'Banana' },   // key={0} (было key={1})
  { id: 3, name: 'Orange' }    // key={1} (было key={2})
]
```

React видит, что элементы с ключами 0 и 1 изменились, и может пересоздать компоненты, потеряв их внутреннее состояние.

---

## 43.5. Частая ошибка: побочные эффекты в теле компонента

```jsx
function App() {
  fetch('/api') //  Выполнится при каждом рендере!
  return <div>Content</div>
}
```

**Проблема:**

- компонент может рендериться много раз;
- `fetch` будет вызываться при каждом рендере;
- это приведёт к лишним запросам, багам и проблемам производительности.

**Правильное решение:**

```jsx
function App() {
  useEffect(() => {
    fetch('/api') //  Выполнится только при монтировании
  }, [])

  return <div>Content</div>
}
```

Побочные эффекты (запросы, подписки, таймеры) должны быть в `useEffect`, а не в теле компонента.

---

## Вопросы на собеседовании

### 1. Что такое Virtual DOM и зачем он нужен?

Virtual DOM — это объектное представление реального DOM в памяти. React использует его для эффективного обновления интерфейса: сравнивает два дерева объектов (быстро) и обновляет только изменённые части реального DOM.

### 2. В чём разница между рендером и обновлением DOM?

Рендер — это вызов функции компонента. React может вызывать компонент много раз. Обновление DOM — это физическое изменение в браузере. React обновляет DOM только при необходимости.

### 3. Что такое reconciliation?

Reconciliation — это процесс сравнения двух деревьев Virtual DOM и определения минимального набора изменений для обновления реального DOM.

### 4. Зачем нужны keys в списках?

Keys помогают React отслеживать, какие элементы изменились, эффективно обновлять только изменённые элементы и сохранять состояние компонентов при изменении порядка.

### 5. Почему индекс — плохой key?

Индекс меняется при удалении/добавлении элементов, что может привести к неправильному сопоставлению элементов и потере состояния компонентов.

### 6. Что такое Fiber?

Fiber — это внутренняя архитектура React, которая позволяет ставить рендер «на паузу» для обработки более важных задач, обеспечивая отзывчивость интерфейса.
