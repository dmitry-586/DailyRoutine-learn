# Глава 43. Рендеринг, Reconciliation и Keys

React — это библиотека для декларативного описания интерфейсов, основанная на идее, что **UI — это функция от состояния**. Понимание процесса рендеринга и reconciliation критично для эффективной работы с React, но важно понимать не детали реализации, а **зачем** это всё нужно.

---

## 43.1. Virtual DOM: как React бережёт браузер

Представь, что браузер — это очень занятой работник. Каждое изменение в реальном DOM требует от него много работы: пересчёт стилей (reflow), перерисовку (repaint), обновление других элементов. Если ты будешь менять DOM напрямую при каждом изменении состояния, браузер будет постоянно пересчитывать и перерисовывать, и интерфейс начнёт тормозить.

React решает это через **Virtual DOM** — это объектное представление реального DOM в памяти JavaScript. Когда ты пишешь JSX:

```jsx
const element = <h1 className='title'>Hello</h1>
```

Под капотом это компилируется в вызов `React.createElement`, который возвращает обычный JavaScript-объект:

```javascript
{
  type: "h1",
  props: {
    className: "title",
    children: "Hello"
  }
}
```

Это и есть Virtual DOM элемент — легковесное представление того, как должен выглядеть реальный DOM. Работать с объектами в памяти JavaScript **быстро**, а работа с реальным DOM — **медленно**.

### Зачем нужен Virtual DOM

Прямые операции с DOM дорогие. Каждое изменение вызывает пересчёт стилей, может вызвать перерисовку и затронуть другие элементы через каскадные обновления.

React решает это через **алгоритм reconciliation**:

1. **Строит Virtual DOM** — создаёт объектное представление желаемого состояния UI в памяти.
2. **Сравнивает с предыдущей версией** (diffing) — находит минимальный набор изменений, сравнивая два дерева объектов (это быстро).
3. **Минимально обновляет реальный DOM** — применяет только найденные различия, а не перерисовывает всё заново.

Это позволяет React эффективно обновлять только изменённые части интерфейса, избегая лишних операций с DOM. Представь список из 1000 элементов, где изменился только один: React сравнивает два дерева объектов в памяти (быстро), находит, что изменился только один элемент, и обновляет только его в реальном DOM.

### Fiber: приоритеты как в больнице

Представь больницу в час пик. В реанимацию привозят пациента с инфарктом — это **критично**, его нужно принять **сразу**, вне очереди. В то же время в регистратуре сидит человек с плановым осмотром — это **не срочно**, его можно поставить в очередь и принять позже.

**Fiber** работает по тому же принципу: он **приоритизирует задачи** и решает, что обрабатывать первым.

**Метафора приоритетов:**

- **Ввод пользователя** — это реанимация. Пользователь нажал кнопку, ввёл текст, прокрутил страницу — это **критично**, нужно обработать **сразу**, без задержек. React прерывает любые другие задачи и обрабатывает ввод пользователя в первую очередь.

- **Подгрузка данных** — это плановый осмотр. Запрос к API выполняется, данные загружаются — это **не срочно**, можно поставить на паузу, если появилось что-то более важное. React может отложить обновление UI с новыми данными, если пользователь взаимодействует с интерфейсом.

- **Анимации** — это косметические процедуры. Красиво, но не критично. React может отложить анимацию, если нужно обработать ввод пользователя или загрузить данные.

**Как это работает:**

1. **Пользователь вводит текст** → React **прерывает** рендер сложного компонента и обрабатывает ввод **сразу**
2. **Данные загружаются с сервера** → React может **отложить** обновление UI, если пользователь взаимодействует с интерфейсом
3. **Анимация запускается** → React может **поставить её на паузу**, если появилась более важная задача

**Результат:** интерфейс остаётся отзывчивым даже при тяжёлых вычислениях. Пользователь не чувствует фризов, потому что React всегда обрабатывает его действия в первую очередь.

**Важно понимать:**

- Fiber — это не то, что ты используешь напрямую в коде. Это внутренняя реализация, которая делает React отзывчивым.
- На собеседованиях важно показать, что ты понимаешь **зачем** это нужно: чтобы интерфейс оставался отзывчивым, даже когда происходят тяжёлые вычисления или загрузка данных.
- Это основа для всех concurrent features: Suspense, `startTransition`, `useDeferredValue` — всё это работает благодаря Fiber.

---

## 43.2. Процесс рендера

Когда изменяется состояние компонента, React запускает процесс обновления:

1. **Изменилось состояние** — вызван `setState` или обновлён проп.
2. **Компонент перерендерился** — вызвалась функция компонента заново.
3. **React сравнил деревья** (diffing) — сравнение нового Virtual DOM с предыдущим.
4. **Применил минимальные изменения в DOM** — обновление только изменённых узлов.

### Важно понимать: рендер ≠ обновление DOM

**Рендер** — это вызов функции компонента. React может вызывать компонент много раз, даже если DOM не изменился. Это нормально и не проблема производительности, если результат JSX идентичен.

**Обновление DOM** — это физическое изменение в браузере. React обновляет DOM только при необходимости, только когда результат JSX действительно изменился.

```jsx
function Counter({ count }) {
  console.log('Рендер компонента')

  return <div>{count}</div>
}

// Если count не изменился, компонент всё равно может перерендериться,
// но React не будет обновлять DOM, если результат JSX идентичен
```

---

## 43.3. Reconciliation: как React находит изменения

Reconciliation — это процесс сравнения двух деревьев Virtual DOM и определения минимального набора изменений для обновления реального DOM.

### Алгоритм diffing

React использует эвристический алгоритм O(n) для сравнения деревьев:

1. **Сравнение по типу элемента:**
   - Если типы разные — React заменяет старое дерево новым.
   - Если типы одинаковые — React обновляет только изменённые свойства.

2. **Сравнение по ключам (keys):**
   - React использует `key` для идентификации элементов в списках.
   - Это позволяет эффективно обновлять элементы при изменении порядка.

### Пример reconciliation

```jsx
// До
<ul>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Orange</li>
</ul>

// После (добавлен элемент в начало)
<ul>
  <li key="0">Grape</li>
  <li key="1">Apple</li>
  <li key="2">Banana</li>
  <li key="3">Orange</li>
</ul>
```

**С ключами:**
- React понимает, что элементы с ключами 1, 2, 3 не изменились.
- Добавляет только новый элемент с ключом 0.
- Обновляет DOM минимально.

**Без ключей (или с индексами):**
- React может неправильно сопоставить элементы.
- Может пересоздать все элементы вместо добавления одного.
- Может потерять состояние компонентов.

---

## 43.4. Keys: паспорта элементов

При рендеринге списков React требует уникальный `key` для каждого элемента. Ключи — это не просто ID, это **«паспорта» элементов**, по которым React узнаёт их при перемещении, чтобы не перерисовывать всё заново и не терять состояние.

```jsx
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' }
]

<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

**`key` нужен React, а не вам.** Он помогает React:

- отслеживать, какие элементы изменились, добавились или удалились;
- эффективно обновлять только изменённые элементы;
- сохранять состояние компонентов при изменении порядка элементов.

### Правила для `key`

- должен быть **уникальным** среди siblings (братьев и сестёр);
- должен быть **стабильным** (не меняться между рендерами);
- лучше использовать **ID из данных**, а не индекс массива.

### Почему индекс — плохой `key`

```jsx
// Плохо: индекс меняется при удалении/добавлении элементов
{
  items.map((item, index) => <li key={index}>{item.name}</li>)
}

// Хорошо: ID стабилен
{
  items.map((item) => <li key={item.id}>{item.name}</li>)
}
```

**Проблема с индексом:**

```jsx
// Исходный список
[
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' }
]

// После удаления первого элемента
[
  { id: 2, name: 'Banana' },   // key={0} (было key={1})
  { id: 3, name: 'Orange' }    // key={1} (было key={2})
]
```

React видит, что элементы с ключами 0 и 1 изменились, и может пересоздать компоненты, потеряв их внутреннее состояние. Если в этих элементах были инпуты с введённым текстом, этот текст пропадёт.

---

## 43.5. Частая ошибка: побочные эффекты в теле компонента

```jsx
function App() {
  fetch('/api') // Выполнится при каждом рендере!
  return <div>Content</div>
}
```

**Проблема:**

- компонент может рендериться много раз;
- `fetch` будет вызываться при каждом рендере;
- это приведёт к лишним запросам, багам и проблемам производительности.

**Правильное решение:**

```jsx
function App() {
  useEffect(() => {
    fetch('/api') // Выполнится только при монтировании
  }, [])

  return <div>Content</div>
}
```

Побочные эффекты (запросы, подписки, таймеры) должны быть в `useEffect`, а не в теле компонента. Это критично для корректной работы приложения.

---

## Вопросы на собеседовании

### 1. Что такое Virtual DOM и зачем он нужен?

Virtual DOM — это объектное представление реального DOM в памяти. React использует его для эффективного обновления интерфейса: сравнивает два дерева объектов (быстро) и обновляет только изменённые части реального DOM, избегая лишних операций.

### 2. В чём разница между рендером и обновлением DOM?

Рендер — это вызов функции компонента. React может вызывать компонент много раз. Обновление DOM — это физическое изменение в браузере. React обновляет DOM только при необходимости, только когда результат JSX действительно изменился.

### 3. Что такое reconciliation?

Reconciliation — это процесс сравнения двух деревьев Virtual DOM и определения минимального набора изменений для обновления реального DOM. React использует эвристический алгоритм O(n) для эффективного сравнения.

### 4. Зачем нужны keys в списках?

Keys помогают React отслеживать, какие элементы изменились, эффективно обновлять только изменённые элементы и сохранять состояние компонентов при изменении порядка. Ключи — это «паспорта» элементов, по которым React узнаёт их при перемещении.

### 5. Почему индекс — плохой key?

Индекс меняется при удалении/добавлении элементов, что может привести к неправильному сопоставлению элементов и потере состояния компонентов. Лучше использовать стабильный ID из данных.

### 6. Что такое Fiber?

Fiber — это внутренняя архитектура React, которая позволяет ставить рендер «на паузу» для обработки более важных задач, обеспечивая отзывчивость интерфейса. Это основа для concurrent features.
