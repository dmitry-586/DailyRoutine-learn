# Глава 45. useEffect: синхронизация с внешним миром

`useEffect` — один из самых важных и сложных хуков в React. Но важно понимать его не как «замену жизненным циклам», а как **механизм синхронизации твоего компонента с внешним миром** — API, таймеры, события, подписки.

---

## 45.1. useEffect как синхронизация

`useEffect` используется для побочных эффектов — всего, что выходит за рамки рендеринга:

- запросы к API;
- подписки на события;
- таймеры и интервалы;
- работа с DOM напрямую;
- синхронизация с внешними системами.

### Синтаксис

```jsx
useEffect(() => {
  // effect — код, который выполняется
  return () => {
    // cleanup — код, который выполняется перед следующим эффектом или размонтированием
  }
}, [deps]) // массив зависимостей
```

Эффект выполняется после того, как React обновил DOM. Это гарантирует, что эффект работает с актуальным состоянием компонента и может безопасно взаимодействовать с DOM.

---

## 45.2. Массив зависимостей: когда эффект должен сработать

Массив зависимостей — это способ сказать React, **когда** эффект должен выполниться заново.

### deps отсутствует

```jsx
useEffect(() => {
  console.log('Выполняется при каждом рендере')
})
```

**Поведение:** эффект выполняется **при каждом рендере**. Обычно это антипаттерн — эффект будет выполняться слишком часто, что может привести к проблемам производительности и бесконечным циклам.

### deps = `[]`

```jsx
useEffect(() => {
  console.log('Выполняется только при монтировании')
}, [])
```

**Поведение:** эффект выполняется **только один раз** при монтировании компонента. Используй для инициализации, которая должна произойти один раз: загрузка данных, подписка на события, установка таймеров.

### deps = `[a, b]`

```jsx
useEffect(() => {
  console.log('Выполняется при изменении a или b')
}, [a, b])
```

**Поведение:** эффект выполняется при изменении любого из значений в массиве зависимостей. Это позволяет синхронизировать эффект с конкретными значениями из компонента.

---

## 45.3. Cleanup: защита от утечек и зомби-коллбеков

Cleanup функция — это не просто «хорошая практика». Это **защита от катастроф**: утечек памяти, зомби-коллбеков и багов, которые появляются через неделю после релиза.

**Проблема без cleanup:**

Представь: компонент подписывается на событие `resize`, обновляет состояние, компонент размонтируется, но подписка остаётся. Теперь у тебя есть **зомби-коллбек** — функция, которая пытается обновить состояние в размонтированном компоненте. Это приводит к утечкам памяти и ошибкам типа "Can't perform a React state update on an unmounted component".

**Cleanup функция — это защита:**

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Tick')
  }, 1000)

  return () => {
    clearInterval(timer) // Убиваем таймер, когда компонент размонтируется
  }
}, [])
```

**Когда выполняется cleanup:**

- **Перед следующим эффектом** — если зависимости изменились, старый эффект «умирает», cleanup очищает ресурсы, новый эффект запускается
- **При размонтировании компонента** — компонент удаляется из DOM, cleanup убивает все подписки, таймеры и запросы

**Защита от зомби-коллбеков:**

```jsx
useEffect(() => {
  let cancelled = false // Флаг для защиты от зомби-коллбеков

  async function fetchData() {
    const data = await fetch('/api/data').then((res) => res.json())
    
    // Проверяем, не размонтировался ли компонент
    if (!cancelled) {
      setData(data) // Обновляем только если компонент ещё жив
    }
  }

  fetchData()

  return () => {
    cancelled = true // Помечаем, что компонент размонтирован
  }
}, [])
```

**Почему это критично:**

Без cleanup запрос может завершиться **после** того, как компонент размонтировался. React попытается обновить состояние в несуществующем компоненте — это ошибка и утечка памяти. Флаг `cancelled` защищает от этого: если компонент размонтирован, мы просто игнорируем результат запроса.

**Правило простое:** если в эффекте есть подписка, таймер или запрос — **обязательно** добавь cleanup. Это не опционально, это **обязательно** для корректной работы приложения.

### Пример: подписка на события

```jsx
useEffect(() => {
  const handleResize = () => {
    console.log('Window resized')
  }

  window.addEventListener('resize', handleResize)

  return () => {
    window.removeEventListener('resize', handleResize)
  }
}, [])
```

### Пример: отмена запроса

```jsx
useEffect(() => {
  const controller = new AbortController()

  fetch('/api/data', { signal: controller.signal })
    .then((res) => res.json())
    .then(setData)
    .catch((error) => {
      if (error.name !== 'AbortError') {
        console.error(error)
      }
    })

  return () => {
    controller.abort()
  }
}, [])
```

Если компонент размонтируется до завершения запроса, запрос будет отменён, предотвращая обновление состояния в размонтированном компоненте.

---

## 45.4. Ловушки памяти: типичные ошибки

### 1. Забытые зависимости

```jsx
function Component({ userId }) {
  const [data, setData] = useState(null)

  useEffect(() => {
    fetch(`/api/user/${userId}`).then(setData)
  }, []) // userId не в зависимостях!
}
```

**Проблема:** если `userId` изменится, запрос не выполнится заново. Компонент будет показывать данные старого пользователя.

**Решение:**

```jsx
useEffect(() => {
  fetch(`/api/user/${userId}`).then(setData)
}, [userId]) // теперь правильно
```

### 2. Stale closures

```jsx
function Component() {
  const [count, setCount] = useState(0)

  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count) // всегда выводит 0!
    }, 1000)

    return () => clearInterval(timer)
  }, []) // count не в зависимостях
}
```

**Проблема:** `count` в замыкании всегда будет равен начальному значению (0), потому что эффект создаётся один раз и «замораживает» значение.

**Решение 1: функциональное обновление**

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    setCount((prev) => {
      console.log(prev) // актуальное значение
      return prev + 1
    })
  }, 1000)

  return () => clearInterval(timer)
}, []) // можно оставить пустым, т.к. используем функциональное обновление
```

**Решение 2: добавить в зависимости**

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log(count)
  }, 1000)

  return () => clearInterval(timer)
}, [count]) // теперь правильно
```

### 3. Бесконечные циклы

```jsx
function Component() {
  const [data, setData] = useState(null)

  useEffect(() => {
    fetch('/api/data')
      .then((res) => res.json())
      .then(setData)
  }, [data]) // data в зависимостях → бесконечный цикл
}
```

**Проблема:** эффект обновляет `data`, что вызывает новый эффект, который снова обновляет `data`, и так далее.

**Решение:**

```jsx
useEffect(() => {
  fetch('/api/data')
    .then((res) => res.json())
    .then(setData)
}, []) // выполнится только один раз
```

### 4. Отсутствие cleanup для подписок

```jsx
useEffect(() => {
  const subscription = subscribe()
  // нет cleanup → утечка памяти
}, [])
```

**Решение:**

```jsx
useEffect(() => {
  const subscription = subscribe()
  return () => {
    subscription.unsubscribe() // cleanup
  }
}, [])
```

### 5. Объекты и функции в зависимостях

```jsx
function Component({ user }) {
  useEffect(() => {
    fetchUserData(user.id)
  }, [user]) // user — объект, ссылка меняется при каждом рендере
}
```

**Проблема:** объект `user` создаётся заново при каждом рендере, даже если его содержимое не изменилось. Это вызывает лишние выполнения эффекта.

**Решение:**

```jsx
useEffect(() => {
  fetchUserData(user.id)
}, [user.id]) // только нужное значение
```

---

## 45.5. Паттерны использования

### Запрос данных при монтировании

```jsx
useEffect(() => {
  let cancelled = false

  async function fetchData() {
    const data = await fetch('/api/data').then((res) => res.json())
    if (!cancelled) {
      setData(data)
    }
  }

  fetchData()

  return () => {
    cancelled = true
  }
}, [])
```

Флаг `cancelled` предотвращает обновление состояния, если компонент размонтировался до завершения запроса.

### Синхронизация с пропсами

```jsx
useEffect(() => {
  // Выполняется при изменении userId
  fetchUser(userId)
}, [userId])
```

### Подписка на события

```jsx
useEffect(() => {
  const handleKeyPress = (e) => {
    if (e.key === 'Escape') {
      onClose()
    }
  }

  document.addEventListener('keydown', handleKeyPress)

  return () => {
    document.removeEventListener('keydown', handleKeyPress)
  }
}, [onClose])
```

### Таймеры

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    setTime(new Date())
  }, 1000)

  return () => {
    clearInterval(timer)
  }
}, [])
```

---

## 45.6. Правила работы с зависимостями

### 1. Включай все используемые значения

Если в эффекте используется значение из области видимости компонента, оно должно быть в зависимостях:

```jsx
// Плохо
useEffect(() => {
  console.log(count)
}, [])

// Хорошо
useEffect(() => {
  console.log(count)
}, [count])
```

### 2. Используй функциональное обновление для setState

Если нужно обновить состояние на основе предыдущего значения, используй функциональное обновление:

```jsx
// Не нужно добавлять count в зависимости
useEffect(() => {
  const timer = setInterval(() => {
    setCount((prev) => prev + 1)
  }, 1000)

  return () => clearInterval(timer)
}, [])
```

### 3. Мемоизируй объекты и функции в зависимостях

Если объект или функция создаётся при каждом рендере, используй `useMemo` или `useCallback`:

```jsx
const user = useMemo(() => ({ id: userId, name: userName }), [userId, userName])

useEffect(() => {
  fetchUserData(user)
}, [user])
```

---

## Вопросы на собеседовании

### 1. Что такое cleanup функция в useEffect?

Функция, которая выполняется перед следующим эффектом или при размонтировании компонента. Используется для очистки ресурсов (таймеры, подписки, запросы) и предотвращения утечек памяти.

### 2. Что произойдёт, если не указать зависимости?

Эффект будет выполняться при каждом рендере, что обычно является антипаттерном и может привести к проблемам производительности и бесконечным циклам.

### 3. Что такое stale closure в useEffect?

Проблема, когда значение в замыкании устарело из-за отсутствия в зависимостях. Решается функциональным обновлением или добавлением в зависимости.

### 4. Почему возникает бесконечный цикл в useEffect?

Когда эффект обновляет значение, которое находится в зависимостях, что вызывает новый эффект, который снова обновляет значение, и так далее.

### 5. Как отменить запрос в useEffect?

Использовать `AbortController` и вызвать `abort()` в cleanup функции. Это предотвращает обновление состояния в размонтированном компоненте.
