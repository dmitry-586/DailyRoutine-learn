# Глава 44. Состояние: useState и useReducer

Управление состоянием — основа React-приложений. `useState` и `useReducer` — два основных способа управления состоянием в функциональных компонентах. Но важно не просто знать синтаксис, а понимать, **когда какой инструмент использовать**.

---

## 44.1. useState: для простого состояния

`useState` — это инструмент для простого состояния. Если у тебя есть значение, которое может быть включено или выключено, число, строка, булево значение — `useState` идеален.

```jsx
const [count, setCount] = useState(0)
const [isOpen, setIsOpen] = useState(false)
const [name, setName] = useState('')
```

`useState` возвращает массив из двух элементов: текущее значение и функцию для обновления. React запоминает значение между рендерами, поэтому ты можешь использовать его как обычную переменную, но с важным отличием: обновление состояния вызывает повторный рендер компонента.

### Функциональное обновление: защита от батчинга

Когда новое значение зависит от предыдущего, нужно использовать **функциональное обновление**:

```jsx
// Проблема: count может быть устаревшим при батчинге
setCount(count + 1)
setCount(count + 1) // не сработает как ожидается

// Правильно: гарантирует актуальное значение
setCount((prev) => prev + 1)
setCount((prev) => prev + 1) // теперь работает корректно
```

React может батчить (группировать) обновления состояния для производительности. При батчинге несколько вызовов `setCount(count + 1)` будут использовать одно и то же значение `count`. Функциональное обновление всегда получает актуальное значение из предыдущего обновления, поэтому оно безопасно.

### Ленивая инициализация

Если начальное значение дорого вычислять, можно передать функцию:

```jsx
// Плохо: вычисляется при каждом рендере
const [data, setData] = useState(expensiveCalculation())

// Хорошо: вычисляется только один раз при первом рендере
const [data, setData] = useState(() => expensiveCalculation())
```

Это особенно важно, когда нужно прочитать значение из localStorage или выполнить сложные вычисления — они выполнятся только один раз, а не при каждом рендере.

---

## 44.2. Неизменяемость: религия React

В React мы **никогда не правим старый объект, мы всегда создаём новый**. Это не просто «хорошая практика», это основа того, как React отслеживает изменения.

React сравнивает ссылки на объекты, а не их содержимое. Если ссылка не изменилась, React считает, что состояние не изменилось, и может пропустить обновление. Это может привести к багам и неожиданному поведению.

```jsx
const [user, setUser] = useState({ name: 'John', age: 30 })

// Плохо: мутация — React не заметит изменение
user.age = 31
setUser(user) // ссылка та же, React не обновит

// Хорошо: создание нового объекта
setUser({ ...user, age: 31 }) // новая ссылка, React обновит

// Для вложенных объектов
setUser({ 
  ...user, 
  profile: { ...user.profile, email: 'new@email.com' } 
})
```

Это правило работает для всех структур данных: объектов, массивов, вложенных структур. Всегда создавай новые, никогда не мутируй старые.

---

## 44.3. useReducer: когда логика превращается в запутанный клубок

Если состояние простое (вкл/выкл, число, строка) — используй `useState`. Но если логика обновления превращается в запутанный клубок из условий, вложенных проверок и множества переходов — переходи к `useReducer`.

`useReducer` выносит правила игры за пределы компонента. Вся логика обновления состояния живёт в одной функции — reducer, которая принимает текущее состояние и действие, и возвращает новое состояние.

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 }
    case 'decrement':
      return { count: state.count - 1 }
    case 'reset':
      return { count: 0 }
    case 'set':
      return { count: action.payload }
    default:
      return state
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 })

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  )
}
```

### Когда использовать useReducer

**useReducer подходит для:**

- сложной логики обновления состояния (много условий, вложенные объекты);
- состояния с множеством переходов (формы, многошаговые процессы);
- когда логику обновления нужно вынести из компонента для тестирования;
- подготовки к миграции на Redux (похожий паттерн).

**useState подходит для:**

- простого состояния (число, строка, булево значение);
- независимых значений состояния;
- когда логика обновления простая.

### Преимущества useReducer

- **Централизованная логика** — вся логика обновления в одном месте (reducer).
- **Предсказуемые обновления** — все изменения проходят через reducer.
- **Легче тестировать** — reducer — чистая функция, её можно тестировать отдельно.
- **Поддержка сложных действий** — можно передавать дополнительные данные в `action`.

### Пример: форма с валидацией

Вот где `useReducer` действительно сияет — сложные формы с множеством полей и правил:

```jsx
function formReducer(state, action) {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        fields: {
          ...state.fields,
          [action.field]: action.value,
        },
      }
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error,
        },
      }
    case 'RESET':
      return initialState
    default:
      return state
  }
}

function Form() {
  const [state, dispatch] = useReducer(formReducer, initialState)

  const handleChange = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value })
    // валидация...
  }

  return <form>{/* поля формы */}</form>
}
```

Вся логика формы в одном месте, её легко тестировать и поддерживать.

---

## 44.4. Правило выбора инструмента

Выбор между `useState` и `useReducer` — это не про то, какой инструмент «лучше». Это про то, какой подходит твоей задаче.

**Используй `useState`, если:**
- состояние простое (одно значение или простой объект);
- логика обновления простая (установить значение, инкремент, переключение);
- нет множества связанных переходов состояния.

**Используй `useReducer`, если:**
- логика обновления сложная (много условий, вложенные объекты);
- состояние имеет множество переходов (формы, многошаговые процессы);
- нужно вынести логику из компонента для тестирования;
- планируется миграция на Redux.

Правило простое: если логика обновления превращается в запутанный клубок из условий — переходи к `useReducer`. Если всё ещё просто — оставайся на `useState`.

---

## 44.5. Типичные ошибки

### 1. Мутация состояния

```jsx
// Плохо
const [items, setItems] = useState([1, 2, 3])
items.push(4)
setItems(items)

// Хорошо
setItems([...items, 4])
```

### 2. Забытое функциональное обновление

```jsx
// Проблема при батчинге
setCount(count + 1)
setCount(count + 1)

// Правильно
setCount((prev) => prev + 1)
setCount((prev) => prev + 1)
```

### 3. Неправильная инициализация

```jsx
// Плохо: вычисляется при каждом рендере
const [data, setData] = useState(expensiveCalculation())

// Хорошо: вычисляется один раз
const [data, setData] = useState(() => expensiveCalculation())
```

---

## Вопросы на собеседовании

### 1. В чём разница между useState и useReducer?

`useState` для простого состояния, `useReducer` для сложного состояния с множеством переходов. `useReducer` централизует логику обновления в reducer, что делает код более предсказуемым и тестируемым.

### 2. Когда использовать функциональное обновление?

Когда новое значение зависит от предыдущего, особенно при батчинге обновлений. Функциональное обновление всегда получает актуальное значение из предыдущего обновления.

### 3. Почему нужно создавать новые объекты/массивы?

React сравнивает ссылки, а не содержимое. Если ссылка не изменилась, React не заметит изменение. Это может привести к пропуску обновлений и багам. Неизменяемость — это основа того, как React отслеживает изменения.

### 4. Зачем нужна ленивая инициализация?

Чтобы дорогие вычисления выполнялись только один раз при первом рендере, а не при каждом. Это особенно важно для чтения из localStorage или выполнения сложных вычислений.

### 5. Когда использовать useReducer вместо useState?

Для сложного состояния с множеством переходов, когда логику обновления нужно вынести из компонента. Если логика обновления превращается в запутанный клубок из условий — переходи к `useReducer`.
