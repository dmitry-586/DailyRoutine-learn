# Глава 15. Тестирование

Тестирование — это не «дополнительная опция», а часть инженерной культуры. На уровне Middle и выше от фронтенд-разработчика ожидают понимание зачем, что и как тестировать, а не только умение написать тест.

На собеседованиях по тестированию проверяют:

- архитектурное мышление
- умение выбирать уровень теста
- понимание trade-off'ов

---

## 15.1. Виды тестов: Unit, Integration, E2E

### Unit-тесты

Тестируют одну функцию или модуль в изоляции.

```javascript
function sum(a, b) {
  return a + b
}

expect(sum(2, 3)).toBe(5)
```

**Характеристики:**

- быстрые
- дешёвые
- легко писать
- изолированы от внешних зависимостей

⚠️ Не ловят ошибки интеграции. Тестируют только логику в изоляции.

### Integration-тесты

Тестируют взаимодействие модулей.

**Пример:**

- компонент + API
- форма + валидация
- несколько компонентов вместе

**Характеристики:**

- медленнее unit-тестов
- проверяют взаимодействие
- требуют моков/стабов

### E2E (End-to-End)

Тестируют пользовательский сценарий целиком.

**Пример:**

- открыть страницу
- ввести данные
- нажать кнопку
- получить результат

Самые дорогие, но самые надёжные. Проверяют реальное поведение приложения.

### Пирамида тестирования

```
        E2E (мало)
    Integration (средне)
Unit Unit Unit (много)
```

Принцип: много быстрых unit-тестов, меньше integration, минимум E2E.

---

## 15.2. Jest: тестирование логики

Jest — стандарт де-факто для unit-тестов во фронтенде.

### Базовый тест

```javascript
test('sum works', () => {
  expect(sum(1, 2)).toBe(3)
})

describe('Math utils', () => {
  test('sum adds numbers', () => {
    expect(sum(2, 3)).toBe(5)
  })

  test('sum handles negatives', () => {
    expect(sum(-1, 1)).toBe(0)
  })
})
```

### Matchers

- toBe — строгое сравнение (===)
- toEqual — глубокое сравнение объектов
- toContain — проверка наличия в массиве
- toThrow — проверка выброса ошибки
- toHaveBeenCalled — проверка вызова функции
- toMatch — сравнение с регулярным выражением

### Mock-функции

```javascript
const fn = jest.fn()
fn(1)
expect(fn).toHaveBeenCalledWith(1)
expect(fn).toHaveBeenCalledTimes(1)
```

### Mock модулей

```javascript
jest.mock('./api')
const api = require('./api')

api.fetchData = jest.fn().mockResolvedValue({ data: 'test' })
```

Используется для изоляции тестов от внешних зависимостей.

---

## 15.3. Testing Library: тестирование компонентов

Testing Library тестирует не реализацию, а поведение.

**Принцип:** «Тестируй так, как пользуется пользователь»

### Пример (React)

```javascript
import { render, screen } from '@testing-library/react'
import Button from './Button'

test('renders button with text', () => {
  render(<Button>Save</Button>)
  const button = screen.getByRole('button', { name: /save/i })
  expect(button).toBeInTheDocument()
})
```

### Основные селекторы (в порядке предпочтения)

1. getByRole — по роли элемента (предпочтительно)
2. getByLabelText — по label
3. getByText — по тексту
4. getByPlaceholderText — по placeholder
5. getByTestId — крайний случай (когда нет других способов)

⚠️ getByTestId — крайний случай. Используйте только если нет семантических способов.

### Почему не shallow?

Shallow-тесты (Enzyme):

- знают о внутренней структуре
- ломаются при рефакторинге
- тестируют реализацию, а не поведение

Testing Library поощряет тестирование через доступность и семантику.

### Тестирование событий

```javascript
import { fireEvent } from '@testing-library/react'

test('calls onClick when clicked', () => {
  const handleClick = jest.fn()
  render(<Button onClick={handleClick}>Click me</Button>)
  fireEvent.click(screen.getByRole('button'))
  expect(handleClick).toHaveBeenCalledTimes(1)
})
```

### Асинхронные тесты

```javascript
test('loads data', async () => {
  render(<DataComponent />)

  await waitFor(() => {
    expect(screen.getByText('Loaded')).toBeInTheDocument()
  })
})
```

---

## 15.4. Cypress и Playwright

Инструменты для E2E-тестирования.

### Cypress

- работает внутри браузера
- удобен для дебага
- проще старт
- хорошая документация

```javascript
cy.visit('/')
cy.get('button').click()
cy.contains('Success').should('be.visible')
```

**Особенности:**

- работает в реальном браузере
- может тестировать сетевые запросы
- удобный UI для отладки

### Playwright

- multi-browser (Chromium, Firefox, WebKit)
- быстрее
- лучше для CI
- поддерживает мобильные устройства

```javascript
await page.goto('/')
await page.click('button')
await expect(page.locator('text=Success')).toBeVisible()
```

### Cypress vs Playwright

**Простота:**

- Cypress: выше
- Playwright: ниже

**CI/CD:**

- Cypress: средне
- Playwright: отлично

**Multi-browser:**

- Cypress: нет
- Playwright: да

**Mobile:**

- Cypress: ограничено
- Playwright: хорошо

**Скорость:**

- Cypress: медленнее
- Playwright: быстрее

**Отладка:**

- Cypress: отлично
- Playwright: хорошо

**Когда использовать Cypress:**

- быстрый старт
- отладка важнее скорости
- один браузер достаточен

**Когда использовать Playwright:**

- нужна поддержка нескольких браузеров
- важна скорость в CI
- нужна поддержка мобильных устройств

---

## 15.5. Mocks, Stubs, Spies

### Mock

Полностью заменяет зависимость фиктивной реализацией.

```javascript
jest.mock('./api', () => ({
  fetchData: jest.fn(),
}))
```

### Stub

Возвращает заранее определённые данные.

```javascript
const api = {
  fetchData: jest.fn().mockResolvedValue({ data: 'test' }),
}
```

### Spy

Следит за вызовами реальной функции, не заменяя её.

```javascript
jest.spyOn(api, 'fetchData')
api.fetchData()
expect(api.fetchData).toHaveBeenCalled()
```

**Когда что использовать:**

- Mock — когда нужно полностью изолировать тест
- Stub — когда нужны предсказуемые данные
- Spy — когда нужно проверить вызов, но сохранить реальное поведение

---

## 15.6. Частые ошибки в тестировании

- Тестируют реализацию вместо поведения
- Слишком много E2E-тестов (должно быть мало)
- Отсутствие тестовых данных (fixtures)
- Flaky-тесты (нестабильные, падают случайно)
- Тестирование внутренних деталей компонента
- Игнорирование edge cases
- Отсутствие cleanup после тестов

### Flaky-тесты

Тесты, которые иногда проходят, иногда падают. Причины:

- таймеры без моков
- асинхронные операции без ожидания
- глобальное состояние
- зависимости от времени/даты

Решение: использовать моки, правильные ожидания, изоляцию тестов.

---

## Вопросы на собеседовании

### 1. Разница между unit, integration и E2E?

- Unit — одна функция/модуль в изоляции (быстро, дешево)
- Integration — взаимодействие модулей (медленнее)
- E2E — полный пользовательский сценарий (медленно, дорого, но надёжно)

### 2. Что такое пирамида тестирования?

Много unit-тестов (основание), меньше integration, минимум E2E (вершина).

### 3. Зачем нужны mock'и?

Изоляция тестов от внешних зависимостей, предсказуемость, скорость.

### 4. Чем Testing Library отличается от Enzyme?

Testing Library тестирует поведение через доступность. Enzyme тестирует реализацию через shallow rendering.

### 5. Когда не стоит писать unit-тесты?

Для тривиального кода без логики, для UI без поведения, когда тест дороже поддержки.

### 6. Cypress vs Playwright?

Cypress проще, лучше для отладки. Playwright быстрее, поддерживает несколько браузеров, лучше для CI.

### 7. Что такое flaky-тесты?

Нестабильные тесты, которые падают случайно. Проблема для CI/CD.

### 8. Почему E2E-тесты дорогие?

Требуют полного окружения, медленные, сложнее поддерживать, могут быть нестабильными.

### 9. Что такое test coverage?

Процент кода, покрытого тестами. Важная метрика, но не самоцель.

### 10. Как организовать тесты в проекте?

Рядом с кодом (`__tests__`) или в отдельной папке (tests/), группировать по фичам.

---

## Key Takeaways

- Пирамида тестирования: много unit, меньше integration, минимум E2E
- Jest — стандарт для unit-тестов
- Testing Library тестирует поведение, а не реализацию
- Cypress и Playwright — инструменты для E2E
- Mocks изолируют тесты от зависимостей
- Flaky-тесты — проблема, которую нужно решать
- Тестирование — часть инженерной культуры, не опция
- Выбор уровня теста зависит от того, что нужно проверить

---

В следующей части мы перейдём к строгой типизации: разберёмся, как TypeScript помогает ловить ошибки ещё до запуска кода и почему без него всё сложнее удерживать большие фронтенд‑проекты под контролем.
