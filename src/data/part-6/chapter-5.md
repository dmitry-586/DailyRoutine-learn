# Глава 24. Практикум по React и архитектуре

Эта глава — **чистая практика**. Здесь нет новых концепций, только задачи и сценарии, которые помогают закрепить материал глав 18–21:

- основы React: компоненты, props, состояние;
- хуки: useState, useEffect, useMemo, useCallback;
- управление состоянием: Context, Redux, TanStack Query;
- архитектурные паттерны;
- SSR и современный React-стек.

Рекомендуемый формат работы:

1. Прочитай условие, **предскажи результат** или набросай решение в голове.
2. Запиши решение в редакторе.
3. Запусти код и проверь результат.
4. Если результат отличается — разберись, **на каком шаге твоё понимание React расходится с реальным поведением**.

---

## 24.1. Основы React: компоненты и состояние

### Задание 1: Понимание Virtual DOM

Напиши компонент, который выводит список элементов. Добавь кнопку для добавления нового элемента. Объясни:

- сколько раз перерендерится компонент при добавлении элемента;
- какие части DOM реально обновятся;
- как `key` помогает React определить, что изменилось.

### Задание 2: Условный рендеринг

Создай компонент `UserProfile`, который:

- показывает форму входа, если пользователь не авторизован;
- показывает профиль пользователя, если авторизован;
- использует тернарный оператор для условного рендеринга.

### Задание 3: Список с ключами

Создай компонент списка задач с возможностью удаления. Сначала используй индекс как `key`, затем замени на ID. Объясни, почему второй вариант лучше.

### Задание 4: Контролируемый vs неконтролируемый

Создай два варианта формы входа:

1. Контролируемый — значения в `useState`.
2. Неконтролируемый — значения через `ref`.

Объясни, в каких случаях какой вариант предпочтительнее.

### Задание 5: Исправление ошибок

Найди и исправь ошибки в коде:

```jsx
function App() {
  const [data, setData] = useState(null)

  fetch('/api/data')
    .then((res) => res.json())
    .then(setData)

  return <div>{data.name}</div>
}
```

Объясни, почему код не работает и как его исправить.

---

## 24.2. Хуки и управление состоянием

### Задание 6: Исправление useEffect

Найди и исправь ошибки в коде:

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then(setUser)
  }, [])

  return <div>{user.name}</div>
}
```

### Задание 7: Счётчик с интервалом

Создай компонент счётчика, который автоматически увеличивается каждую секунду. Добавь кнопки для запуска и остановки. Убедись, что интервал правильно очищается.

### Задание 8: Кастомный хук useLocalStorage

Создай кастомный хук `useLocalStorage`, который:

- сохраняет значение в localStorage;
- синхронизируется между вкладками;
- возвращает значение и функцию для обновления.

### Задание 9: Оптимизация с useMemo и useCallback

Дан компонент:

```jsx
function ExpensiveList({ items, onItemClick }) {
  const sorted = items.sort((a, b) => a.price - b.price)

  return (
    <ul>
      {sorted.map((item) => (
        <ListItem key={item.id} item={item} onClick={onItemClick} />
      ))}
    </ul>
  )
}
```

Оптимизируй его с помощью `useMemo` и `useCallback`. Объясни, почему это помогает.

### Задание 10: Форма с useReducer

Создай форму входа с валидацией, используя `useReducer` для управления состоянием. Форма должна иметь поля: email, password, и кнопку отправки.

---

## 24.3. Архитектура и state management

### Задание 11: Выбор state manager

Опиши, какой state manager ты бы выбрал для следующих сценариев и почему:

1. Небольшое приложение с формой входа и профилем пользователя.
2. Большое e-commerce приложение с корзиной, каталогом, фильтрами.
3. Дашборд с реальным временем (WebSocket) и множеством виджетов.

**Решение должно включать:**

- обоснование выбора;
- описание trade-off'ов;
- альтернативные варианты и почему они не подходят.

### Задание 12: Redux Toolkit slice

Создай Redux Toolkit slice для управления корзиной покупок:

- добавление товара;
- удаление товара;
- изменение количества;
- очистка корзины.

**Требования:**

- используй `createSlice`;
- добавь типизацию (TypeScript);
- создай компонент для отображения корзины.

### Задание 13: TanStack Query с мутациями

Создай компонент списка пользователей с TanStack Query:

- загрузка списка;
- создание нового пользователя (мутация);
- обновление пользователя (мутация);
- удаление пользователя (мутация);
- инвалидация кэша после мутаций.

**Требования:**

- используй фабрику ключей;
- создай кастомные хуки для запросов;
- добавь оптимистичные обновления для обновления пользователя.

### Задание 14: Compound Components

Создай компонент `Accordion` используя паттерн Compound Components:

```jsx
<Accordion>
  <Accordion.Item>
    <Accordion.Header>Title 1</Accordion.Header>
    <Accordion.Panel>Content 1</Accordion.Panel>
  </Accordion.Item>
  <Accordion.Item>
    <Accordion.Header>Title 2</Accordion.Header>
    <Accordion.Panel>Content 2</Accordion.Panel>
  </Accordion.Item>
</Accordion>
```

**Требования:**

- используй Context для передачи состояния;
- только один элемент может быть открыт одновременно;
- добавь анимацию открытия/закрытия.

### Задание 15: Архитектурное решение

Дан проект с следующими требованиями:

- список товаров с фильтрацией;
- корзина покупок;
- профиль пользователя;
- история заказов;
- уведомления в реальном времени.

Опиши архитектуру: какие инструменты используешь, где хранишь состояние, как организуешь код. Объясни свои решения.

**Решение должно включать:**

- выбор state manager'ов для разных типов состояния;
- структуру папок;
- описание потоков данных;
- обоснование каждого решения.

### Задание 16: Миграция с Context на Redux

Дан компонент, использующий Context:

```jsx
const CartContext = createContext()

function CartProvider({ children }) {
  const [items, setItems] = useState([])

  const addItem = (item) => {
    setItems([...items, item])
  }

  return (
    <CartContext.Provider value={{ items, addItem }}>
      {children}
    </CartContext.Provider>
  )
}
```

Мигрируй его на Redux Toolkit. Объясни, почему миграция оправдана или нет.

---

## 24.4. SSR и современный React-стек

### Задание 17: Проблемы SPA

Опиши проблемы классического SPA на примере конкретного приложения (например, интернет-магазина). Объясни, как SSR решает каждую проблему.

**Решение должно включать:**

- описание каждой проблемы с конкретными примерами;
- объяснение, как SSR решает проблему;
- сравнение метрик (TTFB, FCP, TTI) до и после SSR.

### Задание 18: Hydration error

Дан код с hydration error:

```tsx
function Component() {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  return <div>{mounted ? <ClientOnly /> : <ServerOnly />}</div>
}
```

Исправь код так, чтобы избежать hydration error. Объясни, почему возникает ошибка и как твоё решение её исправляет.

**Требования:**

- код должен работать без hydration errors;
- объяснение должно включать, почему React требует совпадения HTML;
- покажи несколько способов решения проблемы.

### Задание 19: Выбор типа рендеринга

Для следующих страниц выбери тип рендеринга (SSR, SSG, ISR, CSR) и объясни свой выбор:

1. Главная страница интернет-магазина с каталогом товаров.
2. Страница товара с динамическим ID.
3. Личный кабинет пользователя.
4. Блог со статьями.
5. Форма обратной связи.

**Решение должно включать:**

- обоснование выбора для каждой страницы;
- описание trade-off'ов;
- альтернативные варианты и почему они не подходят.

### Задание 20: Server vs Client Components

Создай структуру Next.js App Router для страницы продукта:

- Server Component для загрузки данных о продукте;
- Client Component для корзины покупок;
- Server Component для списка похожих товаров;
- Client Component для отзывов с возможностью добавления.

Объясни, почему ты выбрал Server или Client для каждого компонента.

**Требования:**

- код должен быть рабочим;
- объяснение для каждого компонента;
- покажи, как компоненты взаимодействуют друг с другом.

### Задание 21: Оптимизация бандла

Дан большой компонент `HeavyComponent`, который используется только на одной странице. Оптимизируй загрузку с помощью dynamic import и Suspense. Объясни, как это влияет на размер начального бандла.

**Требования:**

- покажи код до и после оптимизации;
- объясни, как работает dynamic import;
- опиши, как это влияет на метрики производительности.

### Задание 22: ISR с revalidation

Создай страницу блога с использованием ISR:

- страницы генерируются на этапе билда;
- обновляются каждые 60 секунд;
- поддерживают on-demand revalidation через API route.

**Требования:**

- используй `generateStaticParams` для генерации страниц;
- настрой `revalidate` для периодического обновления;
- создай API route для on-demand revalidation.

---

## Как использовать этот практикум дальше

- Возвращайся к этим задачам через 1–2 недели и реши их **ещё раз** без подсказок.
- Если какая‑то задача вызывает трудности — вернись к соответствующей главе (18–21) и перечитай именно тот раздел, который связан с проблемой.
- Придумай к каждому блоку **ещё по 1–2 своих варианта задач**:
  - дополнительный пример на хуки;
  - ещё один кейс с state management;
  - свой сценарий SSR/SSG.

Цель этого раздела — не зазубрить синтаксис, а натренировать **правильное понимание React**: понимать, _почему_ компоненты ведут себя именно так, и как использовать React для построения надёжных интерфейсов.

---

> **Разбор решений** ко всем заданиям находится в следующей главе.
