# Глава 21. Основы React

React — это не фреймворк «для UI», а библиотека для декларативного описания интерфейсов, основанная на идее, что **UI — это функция от состояния**.

На собеседованиях по React в первую очередь проверяют:

- понимание модели рендеринга и жизненного цикла компонентов;
- отличие Virtual DOM от реального DOM и зачем это нужно;
- осознание того, почему React устроен именно так и какие проблемы он решает;
- умение объяснить разницу между рендером и обновлением DOM.

Если эти вещи не разобраны до конца, дальше (хуки, контекст, оптимизация, SSR) будет постоянно «подвисать» ощущение магии.

---

## 20.1. Virtual DOM и Fiber: как React обновляет интерфейс

### Что такое Virtual DOM

**Virtual DOM** — это объектное представление реального DOM в памяти JavaScript.

Когда ты пишешь JSX:

```jsx
const element = <h1 className='title'>Hello</h1>
```

Под капотом это компилируется в вызов `React.createElement`:

```javascript
React.createElement('h1', { className: 'title' }, 'Hello')
```

Который возвращает обычный JavaScript-объект:

```javascript
{
  type: "h1",
  props: {
    className: "title",
    children: "Hello"
  }
}
```

Это и есть Virtual DOM элемент — легковесное представление того, как должен выглядеть реальный DOM.

### Зачем нужен Virtual DOM

Прямые операции с DOM **дорогие**. Каждое изменение:

- вызывает пересчёт стилей (reflow);
- может вызвать перерисовку (repaint);
- может затронуть другие элементы (каскадные обновления).

React решает это через **алгоритм reconciliation**:

1. **Строит Virtual DOM** — создаёт объектное представление желаемого состояния UI.
2. **Сравнивает с предыдущей версией** (diffing) — находит минимальный набор изменений.
3. **Минимально обновляет реальный DOM** — применяет только найденные различия.

Это позволяет React эффективно обновлять только изменённые части интерфейса, избегая лишних операций с DOM.

### Пример: почему Virtual DOM эффективнее

Представь, что у тебя есть список из 1000 элементов, и изменился только один:

**Без Virtual DOM (наивный подход):**

- нужно вручную найти, какой элемент изменился;
- обновить его в DOM;
- убедиться, что не сломались другие элементы.

**С Virtual DOM:**

- React сравнивает два дерева объектов в памяти (быстро);
- находит, что изменился только один элемент;
- обновляет только этот элемент в реальном DOM.

### Fiber Architecture

**Fiber** — это внутренняя архитектура React, которая пришла на смену старому стековому алгоритму в React 16.

**Что она даёт:**

- **приоритеты обновлений** — React может отложить менее важные обновления (например, анимации) и сначала обработать критичные (ввод пользователя);
- **прерываемый рендеринг** — React может «поставить на паузу» рендер сложного компонента, чтобы обработать более важную задачу;
- **concurrent features** — основа для Suspense, `startTransition`, `useDeferredValue` и других современных возможностей.

Проще говоря: React может ставить рендер «на паузу», чтобы интерфейс оставался отзывчивым. Это основа для всех concurrent features.

**Важно понимать:**

- Fiber — это не то, что ты используешь напрямую в коде;
- это внутренняя реализация, которая делает React быстрее и отзывчивее;
- на собеседованиях важно показать, что ты понимаешь, **зачем** это нужно, а не зубришь детали реализации.

---

## 20.2. JSX и элементы: синтаксический сахар над JavaScript

### JSX ≠ HTML

JSX выглядит как HTML, но это **синтаксический сахар** над `React.createElement`.

```jsx
<div className='box' />
```

Компилируется в:

```javascript
React.createElement('div', { className: 'box' })
```

**Ключевые отличия от HTML:**

- `className`, а не `class` (потому что `class` — зарезервированное слово в JavaScript);
- `htmlFor`, а не `for` (по той же причине);
- самозакрывающиеся теги обязательны (`<div />`, а не `<div></div>`);
- атрибуты в camelCase (`onClick`, `onChange`, а не `onclick`, `onchange`).

### Выражения в JSX

В JSX можно вставлять JavaScript-выражения через фигурные скобки:

```jsx
const title = "Hello"
const count = 5

<h1>{title.toUpperCase()}</h1>
{count > 0 && <span>{count}</span>}
```

**Важно:** внутри `{}` должно быть **выражение**, а не **инструкция**.

```jsx
{/* ✅ Выражение */}
{count + 1}
{title.toUpperCase()}
{isOpen ? <Modal /> : null}

{/* ❌ Инструкция — не сработает */}
{if (isOpen) { return <Modal /> }}
{for (let i = 0; i < 10; i++) { ... }}
```

### Условный рендеринг

React не имеет специального синтаксиса для условий, поэтому используются стандартные JavaScript-конструкции:

**Логическое И (`&&`):**

```jsx
{
  isOpen && <Modal />
}
```

**Тернарный оператор (`? :`):**

```jsx
{
  isLoading ? <Spinner /> : <Content />
}
```

**Условное присваивание:**

```jsx
let content = null
if (isLoading) {
  content = <Spinner />
} else {
  content = <Content />
}

return <div>{content}</div>
```

### Списки и ключи

При рендеринге списков React требует уникальный `key` для каждого элемента:

```jsx
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' }
]

<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

**⚠️ `key` нужен React, а не вам.**

`key` помогает React:

- отслеживать, какие элементы изменились, добавились или удалились;
- эффективно обновлять только изменённые элементы;
- сохранять состояние компонентов при изменении порядка элементов.

**Правила для `key`:**

- должен быть **уникальным** среди siblings (братьев и сестёр);
- должен быть **стабильным** (не меняться между рендерами);
- лучше использовать **ID из данных**, а не индекс массива.

**Почему индекс — плохой `key`:**

```jsx
// ❌ Плохо: индекс меняется при удалении/добавлении элементов
{
  items.map((item, index) => <li key={index}>{item.name}</li>)
}

// ✅ Хорошо: ID стабилен
{
  items.map((item) => <li key={item.id}>{item.name}</li>)
}
```

Если использовать индекс как `key`, React может неправильно сопоставить элементы после изменений, что приведёт к багам с состоянием и производительностью.

---

## 20.3. Компоненты и пропсы: строительные блоки React

### Функциональный компонент

Современный React использует **функциональные компоненты** (классовые компоненты устарели):

```jsx
function Button({ title, onClick }) {
  return <button onClick={onClick}>{title}</button>
}
```

Или с arrow function:

```jsx
const Button = ({ title, onClick }) => {
  return <button onClick={onClick}>{title}</button>
}
```

**Компонент — это функция**, которая:

- принимает объект `props` (или деструктурированные пропсы);
- возвращает JSX (или `null`).

### Props — только для чтения

**Props должны быть иммутабельными.** Компонент не должен изменять свои пропсы:

```jsx
function UserCard({ user }) {
  // ❌ Антипаттерн: изменение props
  user.name = 'New Name'

  // ✅ Правильно: используй props как есть
  return <div>{user.name}</div>
}
```

**Почему это важно:**

- Props приходят от родителя — изменение их внутри компонента создаёт неожиданные побочные эффекты;
- React полагается на иммутабельность для эффективного сравнения и обновления;
- это нарушает принцип однонаправленного потока данных.

Если нужно изменить данные — делай это в родительском компоненте через состояние.

### Композиция вместо наследования

React поощряет **композицию**, а не наследование. Компоненты можно комбинировать для создания сложных интерфейсов:

```jsx
function Card({ children }) {
  return <div className='card'>{children}</div>
}

function Button({ title }) {
  return <button>{title}</button>
}

// Использование
;<Card>
  <h2>Title</h2>
  <p>Content</p>
  <Button title='Click me' />
</Card>
```

**Преимущества композиции:**

- гибкость — можно комбинировать компоненты разными способами;
- переиспользование — один компонент можно использовать в разных контекстах;
- простота — нет сложной иерархии наследования.

### Children prop

`children` — это специальный проп, который содержит всё, что передано между открывающим и закрывающим тегами компонента:

```jsx
function Card({ children }) {
  return <div className='card'>{children}</div>
}

// Использование
;<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>
```

Здесь `children` будет массивом из двух элементов: `<h2>` и `<p>`.

`children` может быть:

- одним элементом;
- массивом элементов;
- строкой или числом;
- `null` или `undefined`.

---

## 20.4. Отрисовка и reconciliation: что происходит при изменении состояния

### Процесс рендера

Когда изменяется состояние компонента, React запускает процесс обновления:

1. **Изменилось состояние** — вызван `setState` или обновлён проп.
2. **Компонент перерендерился** — вызвалась функция компонента заново.
3. **React сравнил деревья** (diffing) — сравнение нового Virtual DOM с предыдущим.
4. **Применил минимальные изменения в DOM** — обновление только изменённых узлов.

### Важно понимать: рендер ≠ обновление DOM

**Рендер** — это вызов функции компонента. React может вызывать компонент много раз, даже если DOM не изменился.

**Обновление DOM** — это физическое изменение в браузере. React обновляет DOM только при необходимости.

```jsx
function Counter({ count }) {
  console.log('Рендер компонента')

  return <div>{count}</div>
}

// Если count не изменился, компонент всё равно может перерендериться,
// но React не будет обновлять DOM, если результат JSX идентичен
```

### Частая ошибка: побочные эффекты в теле компонента

```jsx
function App() {
  fetch('/api') // ❌ Выполнится при каждом рендере!
  return <div>Content</div>
}
```

**Проблема:**

- компонент может рендериться много раз;
- `fetch` будет вызываться при каждом рендере;
- это приведёт к лишним запросам, багам и проблемам производительности.

**Правильное решение:**

```jsx
function App() {
  useEffect(() => {
    fetch('/api') // ✅ Выполнится только при монтировании
  }, [])

  return <div>Content</div>
}
```

Побочные эффекты (запросы, подписки, таймеры) должны быть в `useEffect`, а не в теле компонента.

### Контролируемые и неконтролируемые компоненты

**Контролируемые компоненты:**

React контролирует значение через состояние:

```jsx
function Input() {
  const [value, setValue] = useState('')

  return <input value={value} onChange={(e) => setValue(e.target.value)} />
}
```

**Преимущества:**

- полный контроль над значением;
- валидация в реальном времени;
- синхронизация с другими компонентами.

**Неконтролируемые компоненты:**

DOM хранит состояние:

```jsx
function Input() {
  const inputRef = useRef(null)

  const handleSubmit = () => {
    console.log(inputRef.current.value)
  }

  return <input ref={inputRef} defaultValue='initial' />
}
```

**Преимущества:**

- меньше ререндеров (значение не в состоянии);
- проще для простых форм;
- может быть быстрее для больших форм.

**Когда что использовать:**

- **Контролируемые** — когда нужен контроль, валидация, синхронизация;
- **Неконтролируемые** — для простых форм, когда производительность важна, или при работе с большими формами.

---

## 20.5. Практические примеры

### Пример 1: Простой счётчик

```jsx
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  )
}
```

**Что происходит:**

1. При клике вызывается `setCount(count + 1)`.
2. React помечает компонент для обновления.
3. Компонент перерендеривается с новым значением `count`.
4. React сравнивает новый JSX с предыдущим.
5. Обновляется только текст внутри `<p>`.

### Пример 2: Список с фильтрацией

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', done: false },
    { id: 2, text: 'Build app', done: false },
  ])
  const [filter, setFilter] = useState('all')

  const filteredTodos = todos.filter((todo) => {
    if (filter === 'active') return !todo.done
    if (filter === 'done') return todo.done
    return true
  })

  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('done')}>Done</button>
      </div>
      <ul>
        {filteredTodos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  )
}
```

**Ключевые моменты:**

- `key={todo.id}` — стабильный идентификатор для каждого элемента;
- фильтрация происходит при каждом рендере (вычисляемое значение);
- изменение `filter` вызывает перерендер и пересчёт `filteredTodos`.

---

## 20.6. Мини‑самопроверка по главе

Проверь, что ты можешь **без IDE и Google**:

- объяснить, что такое Virtual DOM и зачем он нужен, привести пример ситуации, где он помогает;
- описать на словах, как работает алгоритм reconciliation и почему это эффективнее прямых операций с DOM;
- объяснить, что такое Fiber и какие проблемы он решает (не детали реализации, а концептуально);
- показать разницу между JSX и HTML, объяснить, почему `className` вместо `class`;
- объяснить, зачем нужен `key` в списках и почему индекс — плохой выбор;
- описать процесс рендера: что происходит при изменении состояния от вызова `setState` до обновления DOM;
- объяснить разницу между рендером и обновлением DOM;
- показать пример неправильного использования побочных эффектов в теле компонента и исправить его;
- объяснить разницу между контролируемыми и неконтролируемыми компонентами и когда что использовать;
- объяснить, почему props должны быть иммутабельными и что произойдёт, если их изменять.

Если это даётся уверенно — фундамент по React у тебя уже на уровне, достаточном для комфортного входа в темы хуков, контекста, оптимизации и SSR, которые идут дальше.

---

В следующей главе мы разберём хуки — механизм, который позволил React отказаться от классов и сделать логику компонентов компонуемой и переиспользуемой.
