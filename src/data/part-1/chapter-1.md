# Глава 1. Как работает Интернет

Интернет кажется магией: ты вводишь в адресной строке "google.com" — и через долю секунды видишь страницу. На самом деле внутри происходит цепочка процессов, в которой задействованы десятки машин, протоколов и уровней. Если эту цепочку разложить по шагам, весь фронтенд становится куда логичнее: рендеринг, производительность, ошибки сети, кэш, CORS, WebSockets — всё это перестаёт быть набором «фич» и начинает складываться в цельную картину.

Для фронтенд-разработчика важно понимать это достаточно глубоко, чтобы не относиться к сети как к «чёрному ящику», который либо «работает», либо «сломался». Это база для осмысленных решений в архитектуре и для взрослого разговора с бэкенд-разработчиками и DevOps.

- грамотно объяснять сетевые проблемы
- понимать задержки доставки данных
- диагностировать производительность
- понимать ограничения браузера
- уверенно отвечать на собеседованиях уровня Middle+

---

## 1.1. Архитектура сети

Когда разработчик открывает браузер и вводит URL — кажется, что «страница просто загружается». На самом деле за этим стоит сложная, многоуровневая архитектура:

- физические сети (оптика, медные кабели, беспроводные сети)
- провайдеры и магистральные маршрутизаторы
- протоколы передачи данных
- система адресации (IP)
- система доменных имён (DNS)
- стек TCP/IP
- протоколы прикладного уровня (HTTP, TLS, WebSocket и др.)

### Как устроен Интернет

Интернет — это не «глобальный сервер», а сеть сетей. Тысячи автономных систем (AS — Autonomous Systems) соединены между собой через протокол BGP.

Про автономные системы можно думать так: это крупные «острова» сети — сеть провайдера, сеть крупной компании, сеть дата-центров. Каждый такой «остров» управляется своей организацией и договаривается с другими островами, по каким маршрутам передавать трафик. Этими договорённостями и занимается BGP — протокол, который по сути является «системой навигации» всего Интернета.

**Условная модель:**

Ваш компьютер → Домашний роутер → Провайдер (ISP) → Магистральные маршрутизаторы → Дата-центр / Сервер / CDN

Каждый переход — это hop. Можно буквально представить: пакет данных как путешественник, который переезжает из одного города в другой через цепочку пересадок. Чем больше пересадок (hop), тем выше задержка (latency) и тем чувствительнее это для реального пользователя — особенно в играх, видеозвонках и интерактивных веб‑приложениях.

---

## 1.2. DNS, IP, TCP/UDP

Когда пользователь вводит `https://example.com`, запускается цепочка сетевых операций.

### DNS — система доменных имён

DNS — это «телефонный справочник Интернета». Он превращает доменное имя в IP-адрес.

Важно понимать: браузер _никогда_ не работает напрямую с доменным именем. Для него существует только IP‑адрес. Домен — это человеческо‑читаемая оболочка вокруг сложных чисел. Поэтому любой запрос к новому домену почти всегда начинается с DNS‑разрешения.

**Процесс DNS-lookups:**

1. Браузер проверяет локальный кэш
2. Система (OS) проверяет свой кэш
3. Обращение к DNS-серверу провайдера
4. Если нет записи — запрос к корневому серверу
5. Дальше — к серверу зоны (.com)
6. Потом — к авторитетному серверу домена
7. Возвращается IP-адрес

Обычно на DNS уходит 20–120 мс, и это заметная часть пути запроса. В метриках это отражается в TTFB (Time To First Byte): даже если сервер очень быстрый, медленный DNS уже делает сайт субъективно «тяжёлым».

### IP — адресация в сети

IP-адрес — это «номер квартиры» в огромном доме Интернета.

**Примеры:**

- IPv4: `192.168.0.1`
- IPv6: `2001:db8::ff00:42:8329`

IPv6 решает проблему нехватки адресов и уменьшает количество hop.

На практике для фронтенд-разработчика важно не столько уметь читать IPv6‑адреса, сколько понимать: один и тот же домен может иметь несколько IP‑адресов (IPv4 и IPv6), а реальный сервер может быть за CDN или балансировщиком нагрузки. Поэтому «IP сервера» — это почти всегда не одна машина, а целый слой инфраструктуры.

### TCP — надёжный транспорт

TCP обеспечивает:

- гарантированную доставку
- контроль последовательности
- контроль потерь
- повторную отправку пакетов

Это похоже на отправку посылки с квитанцией о получении: пока получатель не подтвердит, что всё дошло, отправитель считает передачу незавершённой и при необходимости шлёт повторно. Для приложений, где важна целостность данных (интернет‑банк, оформление заказа, API), это критично.

#### Трёхстороннее рукопожатие (3‑way handshake)

До того как первый байт вашего HTTP‑запроса отправится на сервер, участники должны «поздороваться» и согласовать начальные номера последовательности (sequence numbers).

Упрощённо это выглядит так:

1. **Клиент → Сервер: SYN**  
   Клиент говорит: «Хочу открыть соединение, мой стартовый номер X».
2. **Сервер → Клиент: SYN‑ACK**  
   Сервер отвечает: «Ок, принимаю твой X, мой стартовый номер Y».
3. **Клиент → Сервер: ACK**  
   Клиент подтверждает: «Принял твой Y, поехали передавать данные».

Только **после** третьего шага в канал пойдут полезные данные (HTTP‑запрос). Каждый сегмент получает номер, и получатель подтверждает успешное получение **ACK‑пакетами**. Если подтверждение не пришло — пакет будет отправлен заново.

**Последствия для фронтенда:**

- первое соединение к домену всегда дороже (DNS + TCP + часто ещё TLS);
- на мобильных или высоколатентных сетях один 3‑way handshake легко стоит 100–200 мс;
- поэтому так важны **keep‑alive** и протоколы, уменьшающие количество handshake (HTTP/2, HTTP/3, TLS 1.3).

### UDP — быстрый, но безгарантийный транспорт

UDP — простой и быстрый протокол **без установления соединения и без гарантий доставки**.

Характеристики:

- нет рукопожатия: пакет можно отправить сразу;
- нет гарантии, что пакет дойдёт;
- нет гарантии порядка (пакеты могут прийти вперемешку);
- нет автоматической повторной отправки.

Можно думать о UDP как о «почтовых открытках без уведомления о вручении»: быстро и дёшево, но часть из них может потеряться по дороге, а некоторые придут не в том порядке, в котором вы их отправляли.

**Где это полезно:**

- стриминг видео и аудио (важнее текущий кадр, чем идеальная доставка всех предыдущих);
- WebRTC (видеозвонки, созвоны в браузере);
- онлайн‑игры (важнее актуальное положение игрока, чем точная доставка всех старых позиций);
- DNS (маленькие независимые запросы/ответы).

Многие современные протоколы, в том числе **QUIC (HTTP/3)**, строят **свою надёжность поверх UDP**: они реализуют повторную отправку, контроль порядка и шифрование на уровне протокола, но избегают классического TCP‑рукопожатия и его задержек.

---

## 1.3. HTTP/1.1 vs HTTP/2 vs HTTP/3

### HTTP/1.1

- последовательные запросы
- head-of-line blocking
- нужно много TCP-соединений
- нагрузки на сервер больше

Браузер открывает до 6 соединений на домен. Каждое соединение может обрабатывать только один запрос за раз. На медленных сетях это катастрофа.

### HTTP/2

Решает ключевые проблемы:

- мультиплексирование (несколько запросов в одном TCP)
- сервер пушит данные (Server Push)
- бинарный протокол
- сжатие заголовков (HPACK)

**Проблема:** TCP всё ещё медленный при потерях.

### HTTP/3 (QUIC)

- работает поверх UDP
- каждый HTTP-поток — независимый
- потери не блокируют остальные запросы
- 0-RTT для повторных подключений (после первого handshake)
- меньше задержек в мобильных сетях

Сегодня HTTP/3 даёт лучшую стабильность и скорость, особенно на мобильных.

---

## 1.4. HTTPS и TLS Handshake

`HTTPS = HTTP + TLS (шифрование)`

**Процесс установки защищённого соединения:**

1. Клиент отправляет список поддерживаемых алгоритмов
2. Сервер выбирает алгоритм и отправляет сертификат
3. Клиент проверяет сертификат (trusted CA)
4. Обмениваются ключами
5. Устанавливается шифрованный канал

**Проблема:** это обычно добавляет 1 RTT (round-trip time)

В HTTP/3 это оптимизировано.

---

## 1.5. Цикл запрос–ответ

Упрощённая цепочка:

1. Ввод URL
2. DNS запрос
3. Установление TCP/TLS
4. Отправка HTTP-запроса
5. Сервер формирует ответ
6. Клиент получает данные
7. Рендер страницы

Интервьюеры любят спрашивать: «Что происходит от момента, когда вы нажимаете Enter?»

---

## 1.6. Методы HTTP и идемпотентность

### Методы

- **GET** — без побочных эффектов
- **POST** — создаёт данные
- **PUT** — заменяет
- **PATCH** — частично обновляет
- **DELETE** — удаляет

### Идемпотентность

Идемпотентный запрос можно повторить без изменения результата.

- GET — да
- PUT — да
- DELETE — обычно да
- POST — нет

На собеседованиях любят задавать вопрос про PUT vs PATCH.

---

## 1.7. Коды состояния HTTP

**Группы:**

- 1xx — информационные
- 2xx — успех
- 3xx — редиректы
- 4xx — ошибка клиента
- 5xx — ошибка сервера

**Важно знать:**

- `200 OK`
- `201 Created`
- `301/302 Redirect`
- `304 Not Modified` (не скачивай, у тебя есть свежая копия)
- `400 Bad Request`
- `401/403 Authorization`
- `404 Not Found`
- `429 Too Many Requests` (лимиты запросов)
- `500 Internal Error`
- `503 Service Unavailable`

---

## 1.8. REST, SOAP, GraphQL, gRPC

**REST**

REST — архитектурный стиль поверх HTTP, где всё крутится вокруг **ресурсов**.

- URL описывает _ресурс_: `/users`, `/users/1`, `/orders/42/items`.
- HTTP‑методы описывают _действие_: GET, POST, PUT, PATCH, DELETE.
- Статусы HTTP описывают результат (`200`, `201`, `400`, `404`, `500`…).

**Пример:**

- `GET /api/users` — получить список пользователей;
- `GET /api/users/1` — получить пользователя с id=1;
- `POST /api/users` — создать нового пользователя;
- `PATCH /api/users/1` — частично обновить пользователя;
- `DELETE /api/users/1` — удалить пользователя.

Плюсы для фронтенда:

- простой, читаемый контракт;
- легко дебажить через браузер/Insomnia/Postman;
- хорошо ложится на HTTP‑инфраструктуру (кеши, прокси, CDN).

Минусы:

- возможна **перегрузка/недогрузка данных** (overfetching/underfetching): один эндпоинт отдаёт слишком много или слишком мало;
- сложнее, когда нужен очень гибкий выбор полей и связей.

**SOAP**

SOAP — «старый корпоративный тяжеловес»:

- формат сообщений — XML;
- строгие контракты через WSDL;
- сложная, но формальная типизация;
- много расширений (транзакции, безопасность).

Где всё ещё встречается:

- банки и крупные корпорации;
- государственные системы;
- старые интеграции B2B.

Фронтендеру важно:

- уметь работать через **backend‑gateway** (часто SOAP ↔ REST/GraphQL преобразуется на бэкенде);
- понимать, что «давайте просто добавим поле в ответ» в мире SOAP может значить изменение схем, контрактов и согласований.

**GraphQL**

GraphQL — это **запросный язык к данным** и сервер, который умеет эти запросы выполнять.

Ключевые идеи:

- один endpoint, например `/graphql`;
- клиент _декларативно_ описывает, какие поля ему нужны;
- сервер возвращает ровно эти поля — ни больше, ни меньше.

**Пример запроса:**

```graphql
query {
  user(id: "1") {
    id
    name
    posts(limit: 5) {
      id
      title
    }
  }
}
```

Плюсы:

- решает проблему overfetching/underfetching;
- удобен для **фронтенд‑heavy** приложений и сложных UI;
- сильная типизация схемы (SDL), автогенерация TypeScript‑типов;
- удобная интеграция с кэшами на клиенте (Apollo, Relay, URQL).

Минусы:

- сложнее кеширование на уровне CDN (всё идёт через один endpoint);
- сложнее дебаг HTTP‑трафик «глазами» (нужно смотреть в тело запроса);
- оверхед для простых CRUD‑API.

**gRPC**

gRPC — RPC‑фреймворк поверх HTTP/2 (и HTTP/3 в новых версиях) с бинарным протоколом **Protocol Buffers (protobuf)**.

Характеристики:

- очень маленькие и быстрые сообщения;
- чёткая контрактная типизация;
- отличен для общения микросервисов между собой.

Типичный сценарий:

- фронтенд общается с **REST/GraphQL‑шлюзом**;
- этот шлюз уже говорит с внутренними сервисами по gRPC.

На фронтенде gRPC чаще встречается:

- в десктопных/мобильных клиентах;
- в internal‑инструментах;
- при использовании gRPC‑web через proxy (Envoy и др.).

**Что важно для собеседований:**

- REST — «дефолтный» выбор, знать надо очень хорошо;
- SOAP — понимать на уровне «старый XML‑ориентированный корпоративный стандарт»;
- GraphQL — часто спрашивают подробно: схема, запросы, мутации, фрагменты, кеширование;
- gRPC — знать как быстрый бинарный транспорт между сервисами и почему его обычно прячут за REST/GraphQL‑слоем для фронтенда.

---

## 1.9. CORS и Same-Origin Policy

### Same-Origin Policy

`origin = protocol + domain + port`

**Пример:**

- `https://example.com:443`
- `http://example.com:80` → другой origin
- `https://api.example.com` → другой origin

CORS — механизм, позволяющий частично ослаблять это правило.

**Важно:** CORS настраивает сервер, а не браузер. Браузер лишь исполняет политику сервера.

---

## 1.10. WebSockets и SSE

### WebSocket

- двусторонняя связь
- постоянное соединение
- чаты, игровая логика

**Пример:**

```javascript
const ws = new WebSocket('wss://echo.example')
ws.onmessage = (e) => console.log(e.data)
ws.send('Привет')
```

### SSE (Server-Sent Events)

- односторонний поток от сервера к клиенту
- легче, чем WebSocket
- автоматическое переподключение
- дешевле по ресурсам

Как радио: сервер говорит, клиент слушает.

---

## Вопросы на собеседовании

### 1. Опишите, что происходит, когда пользователь вводит URL в браузер

Короткий и хороший ответ:

1. Проверка кэша
2. DNS-резолв
3. TCP-handshake
4. TLS-handshake (если HTTPS)
5. HTTP-запрос → HTML
6. Парсинг HTML → DOM
7. Загрузка CSS/JS
8. Рендеринг

### 2. В чём отличие HTTP/1.1, HTTP/2 и HTTP/3?

- HTTP/1.1 — много соединений, блокировки
- HTTP/2 — одно соединение, мультиплексирование
- HTTP/3 — QUIC/UDP, меньше задержек, устойчивость при потере пакетов

### 3. Что такое DNS и зачем он нужен?

DNS — система доменных имён, превращающая доменное имя в IP-адрес. Это «телефонный справочник Интернета».

### 4. Чем TCP отличается от UDP?

TCP — надёжный протокол с гарантией доставки, но с задержками из-за handshake. UDP — быстрый, без гарантий, используется для стриминга и игр.

### 5. Что такое TLS Handshake?

Процесс установки защищённого соединения, включающий обмен сертификатами и ключами. Обычно добавляет 1 RTT к первому запросу.

### 6. Что такое идемпотентность?

Свойство запроса, позволяющее повторять его без изменения результата. GET, PUT, DELETE — идемпотентны, POST — нет.

### 7. Что такое CORS?

Cross-Origin Resource Sharing — механизм, позволяющий ослаблять Same-Origin Policy. Настраивается на сервере.

### 8. Чем WebSocket отличается от SSE?

- WebSocket — двустороннее общение
- SSE — только сервер → клиент
- SSE проще, WS мощнее

---

## Key Takeaways

- Интернет — это набор уровней: DNS, TCP, TLS, HTTP.
- Самые дорогие операции — DNS и handshakes.
- HTTP/2 и HTTP/3 радикально ускоряют загрузку.
- HTTPS обязателен — это не роскошь.
- CORS — серверная политика, браузер лишь её исполняет.
- WebSocket — для диалога, SSE — для трансляций.
- Понимание сетевого стека — важный навык middle/senior разработчика.

---

Дальше мы переключимся с сети на сам браузер: разберём, из каких процессов он состоит, как они общаются друг с другом и что именно происходит «под капотом» после того, как запрос уже выполнился и данные пришли.
