# Глава 1. Как работает Интернет

Интернет кажется магией: ты вводишь в адресной строке "google.com" — и через долю секунды видишь страницу. На самом деле внутри происходит цепочка процессов, в которой задействованы десятки машин, протоколов и уровней. Если эту цепочку разложить по шагам, весь фронтенд становится куда логичнее: рендеринг, производительность, ошибки сети, кэш, CORS, WebSockets — всё это перестаёт быть набором «фич» и начинает складываться в цельную картину.

Для фронтенд-разработчика важно понимать это достаточно глубоко, чтобы не относиться к сети как к «чёрному ящику», который либо «работает», либо «сломался». Это база для осмысленных решений в архитектуре и для взрослого разговора с бэкенд-разработчиками и DevOps.

- грамотно объяснять сетевые проблемы
- понимать задержки доставки данных
- диагностировать производительность
- понимать ограничения браузера
- уверенно отвечать на собеседованиях уровня Middle+

---

## 1.1. Архитектура сети

Когда разработчик открывает браузер и вводит URL — кажется, что «страница просто загружается». На самом деле за этим стоит сложная, многоуровневая архитектура:

- физические сети (оптика, медные кабели, беспроводные сети)
- провайдеры и магистральные маршрутизаторы
- протоколы передачи данных
- система адресации (IP)
- система доменных имён (DNS)
- стек TCP/IP
- протоколы прикладного уровня (HTTP, TLS, WebSocket и др.)

### Как устроен Интернет

Интернет — это не «глобальный сервер», а сеть сетей. Тысячи автономных систем (AS — Autonomous Systems) соединены между собой через протокол BGP.

Про автономные системы можно думать так: это крупные «острова» сети — сеть провайдера, сеть крупной компании, сеть дата-центров. Каждый такой «остров» управляется своей организацией и договаривается с другими островами, по каким маршрутам передавать трафик. Этими договорённостями и занимается BGP — протокол, который по сути является «системой навигации» всего Интернета.

**Условная модель:**

Ваш компьютер → Домашний роутер → Провайдер (ISP) → Магистральные маршрутизаторы → Дата-центр / Сервер / CDN

Каждый переход — это hop. Можно буквально представить: пакет данных как путешественник, который переезжает из одного города в другой через цепочку пересадок. Чем больше пересадок (hop), тем выше задержка (latency) и тем чувствительнее это для реального пользователя — особенно в играх, видеозвонках и интерактивных веб‑приложениях.

---

## 1.2. DNS, IP, TCP/UDP

Когда пользователь вводит `https://example.com`, запускается цепочка сетевых операций.

### DNS — система доменных имён

DNS — это «телефонный справочник Интернета». Он превращает доменное имя в IP-адрес.

Важно понимать: браузер _никогда_ не работает напрямую с доменным именем. Для него существует только IP‑адрес. Домен — это человеческо‑читаемая оболочка вокруг сложных чисел. Поэтому любой запрос к новому домену почти всегда начинается с DNS‑разрешения.

**Процесс DNS-lookups:**

1. Браузер проверяет локальный кэш
2. Система (OS) проверяет свой кэш
3. Обращение к DNS-серверу провайдера
4. Если нет записи — запрос к корневому серверу
5. Дальше — к серверу зоны (.com)
6. Потом — к авторитетному серверу домена
7. Возвращается IP-адрес

Обычно на DNS уходит 20–120 мс, и это заметная часть пути запроса. В метриках это отражается в TTFB (Time To First Byte): даже если сервер очень быстрый, медленный DNS уже делает сайт субъективно «тяжёлым».

### IP — адресация в сети

IP-адрес — это «номер квартиры» в огромном доме Интернета.

**Примеры:**

- IPv4: `192.168.0.1`
- IPv6: `2001:db8::ff00:42:8329`

IPv6 решает проблему нехватки адресов и уменьшает количество hop.

На практике для фронтенд-разработчика важно не столько уметь читать IPv6‑адреса, сколько понимать: один и тот же домен может иметь несколько IP‑адресов (IPv4 и IPv6), а реальный сервер может быть за CDN или балансировщиком нагрузки. Поэтому «IP сервера» — это почти всегда не одна машина, а целый слой инфраструктуры.

### TCP — надёжный транспорт

TCP обеспечивает:

- гарантированную доставку
- контроль последовательности
- контроль потерь
- повторную отправку пакетов

Это похоже на отправку посылки с квитанцией о получении: пока получатель не подтвердит, что всё дошло, отправитель считает передачу незавершённой и при необходимости шлёт повторно. Для приложений, где важна целостность данных (интернет‑банк, оформление заказа, API), это критично.

#### Трёхстороннее рукопожатие (3‑way handshake)

До того как первый байт вашего HTTP‑запроса отправится на сервер, участники должны «поздороваться» и согласовать начальные номера последовательности (sequence numbers).

Упрощённо это выглядит так:

1. **Клиент → Сервер: SYN**  
   Клиент говорит: «Хочу открыть соединение, мой стартовый номер X».
2. **Сервер → Клиент: SYN‑ACK**  
   Сервер отвечает: «Ок, принимаю твой X, мой стартовый номер Y».
3. **Клиент → Сервер: ACK**  
   Клиент подтверждает: «Принял твой Y, поехали передавать данные».

Только **после** третьего шага в канал пойдут полезные данные (HTTP‑запрос). Каждый сегмент получает номер, и получатель подтверждает успешное получение **ACK‑пакетами**. Если подтверждение не пришло — пакет будет отправлен заново.

**Последствия для фронтенда:**

- первое соединение к домену всегда дороже (DNS + TCP + часто ещё TLS);
- на мобильных или высоколатентных сетях один 3‑way handshake легко стоит 100–200 мс;
- поэтому так важны **keep‑alive** и протоколы, уменьшающие количество handshake (HTTP/2, HTTP/3, TLS 1.3).

### UDP — быстрый, но безгарантийный транспорт

UDP — простой и быстрый протокол **без установления соединения и без гарантий доставки**.

Характеристики:

- нет рукопожатия: пакет можно отправить сразу;
- нет гарантии, что пакет дойдёт;
- нет гарантии порядка (пакеты могут прийти вперемешку);
- нет автоматической повторной отправки.

Можно думать о UDP как о «почтовых открытках без уведомления о вручении»: быстро и дёшево, но часть из них может потеряться по дороге, а некоторые придут не в том порядке, в котором вы их отправляли.

**Где это полезно:**

- стриминг видео и аудио (важнее текущий кадр, чем идеальная доставка всех предыдущих);
- WebRTC (видеозвонки, созвоны в браузере);
- онлайн‑игры (важнее актуальное положение игрока, чем точная доставка всех старых позиций);
- DNS (маленькие независимые запросы/ответы).

Многие современные протоколы, в том числе **QUIC (HTTP/3)**, строят **свою надёжность поверх UDP**: они реализуют повторную отправку, контроль порядка и шифрование на уровне протокола, но избегают классического TCP‑рукопожатия и его задержек.

---

## 1.3. HTTP/1.1 vs HTTP/2 vs HTTP/3

### HTTP/1.1

- последовательные запросы
- head-of-line blocking
- нужно много TCP-соединений
- нагрузки на сервер больше

Браузер открывает до 6 соединений на домен. Каждое соединение может обрабатывать только один запрос за раз. На медленных сетях это катастрофа.

### HTTP/2

Решает ключевые проблемы:

- мультиплексирование (несколько запросов в одном TCP)
- сервер пушит данные (Server Push)
- бинарный протокол
- сжатие заголовков (HPACK)

**Проблема:** TCP всё ещё медленный при потерях.

### HTTP/3 (QUIC)

- работает поверх UDP
- каждый HTTP-поток — независимый
- потери не блокируют остальные запросы
- 0-RTT для повторных подключений (после первого handshake)
- меньше задержек в мобильных сетях

Сегодня HTTP/3 даёт лучшую стабильность и скорость, особенно на мобильных.

---

## 1.4. HTTPS и TLS Handshake

`HTTPS = HTTP + TLS (шифрование)`

**Процесс установки защищённого соединения:**

1. Клиент отправляет список поддерживаемых алгоритмов
2. Сервер выбирает алгоритм и отправляет сертификат
3. Клиент проверяет сертификат (trusted CA)
4. Обмениваются ключами
5. Устанавливается шифрованный канал

**Проблема:** это обычно добавляет 1 RTT (round-trip time)

### Что такое RTT (Round-Trip Time)?

**RTT** — это время, которое требуется пакету данных, чтобы дойти от клиента до сервера и вернуться обратно. Это фундаментальная метрика производительности сети.

**Как это работает:**

1. Клиент отправляет пакет → сервер (время: T1)
2. Сервер обрабатывает и отправляет ответ → клиент (время: T2)
3. **RTT = T1 + T2** (общее время туда-обратно)

**Почему это важно:**

- На локальной сети: RTT ≈ 1–5 мс
- В пределах одной страны: RTT ≈ 20–50 мс
- Между континентами: RTT ≈ 100–300 мс
- На мобильных сетях: RTT может быть 200–500 мс

**Влияние на производительность:**

Каждый RTT добавляет задержку. Например, классический TLS handshake требует:

- 1 RTT для TCP handshake
- 1 RTT для TLS handshake
- Итого: минимум 2 RTT до первого байта данных

На высоколатентных сетях (200 мс RTT) это уже 400 мс задержки только на установку соединения, что критично для пользовательского опыта.

**Оптимизации:**

- **TLS 1.3** и **HTTP/3 (QUIC)** поддерживают **0-RTT** для повторных подключений: если клиент уже подключался к серверу, он может сразу отправить данные вместе с первым пакетом, экономя один RTT.
- **HTTP/2** и **HTTP/3** позволяют отправлять несколько запросов параллельно в одном соединении, уменьшая количество RTT для множественных ресурсов.

В HTTP/3 это оптимизировано через QUIC и 0-RTT handshake.

---

## 1.5. Цикл запрос–ответ

Упрощённая цепочка:

1. Ввод URL
2. DNS запрос
3. Установление TCP/TLS
4. Отправка HTTP-запроса
5. Сервер формирует ответ
6. Клиент получает данные
7. Рендер страницы

Интервьюеры любят спрашивать: «Что происходит от момента, когда вы нажимаете Enter?»

---

## 1.6. Методы HTTP и идемпотентность

### Методы

- **GET** — без побочных эффектов, получение данных
- **POST** — создаёт данные, неидемпотентный
- **PUT** — заменяет ресурс целиком (идемпотентный)
- **PATCH** — частично обновляет ресурс
- **DELETE** — удаляет ресурс (идемпотентный)
- **HEAD** — как GET, но без тела ответа (только заголовки)
- **OPTIONS** — запрос информации о поддерживаемых методах и CORS

### HEAD и OPTIONS

**HEAD** — идентичен GET, но сервер возвращает только заголовки без тела ответа. Используется для:

- проверки существования ресурса без загрузки данных
- проверки размера файла (заголовок `Content-Length`)
- проверки актуальности кэша (заголовки `ETag`, `Last-Modified`)
- экономии трафика при проверке статуса

**Пример:**

```http
HEAD /api/users/1 HTTP/1.1
Host: example.com

→ Ответ: только заголовки, без тела
```

**OPTIONS** — запрос информации о возможностях сервера для указанного ресурса. Используется для:

- **CORS preflight** запросов: браузер автоматически отправляет OPTIONS перед «сложными» запросами (POST с кастомными заголовками, PUT, DELETE и т.д.)
- проверки поддерживаемых методов (`Allow: GET, POST, PUT, DELETE`)
- проверки CORS политики (`Access-Control-Allow-*`)

**Пример CORS preflight:**

```http
OPTIONS /api/users HTTP/1.1
Host: api.example.com
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type

→ Ответ:
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type
```

### Идемпотентность

Идемпотентный запрос можно повторить без изменения результата.

- GET — да
- HEAD — да
- PUT — да (полная замена ресурса)
- DELETE — обычно да (повторное удаление не меняет состояние)
- PATCH — обычно нет (частичное обновление может быть неидемпотентным)
- POST — нет
- OPTIONS — да (информационный запрос)

**Важно:** Идемпотентность не означает, что ответ будет одинаковым (например, `DELETE` может вернуть `200 OK` при первом вызове и `404 Not Found` при повторном), но **состояние ресурса** не изменится после первого успешного выполнения.

На собеседованиях любят задавать вопрос про PUT vs PATCH и про идемпотентность методов.

---

## 1.7. Коды состояния HTTP

**Группы:**

- 1xx — информационные
- 2xx — успех
- 3xx — редиректы
- 4xx — ошибка клиента
- 5xx — ошибка сервера

**Важно знать:**

- `200 OK`
- `201 Created`
- `301/302 Redirect`
- `304 Not Modified` (не скачивай, у тебя есть свежая копия)
- `400 Bad Request`
- `401/403 Authorization`
- `404 Not Found`
- `429 Too Many Requests` (лимиты запросов)
- `500 Internal Error`
- `503 Service Unavailable`

---

## 1.8. REST, SOAP, GraphQL, gRPC

**REST**

REST (Representational State Transfer) — архитектурный стиль поверх HTTP, предложенный Роем Филдингом в 2000 году. Всё крутится вокруг **ресурсов** и их представлений.

### REST vs REST API: в чём разница?

Важно понимать различие между **REST** (архитектурный стиль) и **REST API** (конкретная реализация):

**REST** — это набор **принципов и ограничений**, описанных в диссертации Роя Филдинга:

- Абстрактная архитектурная концепция
- Не привязана к конкретной технологии
- Описывает, **как** должна быть организована система
- Фокус на масштабируемости, производительности, простоте

**REST API** — это **конкретная реализация** этих принципов:

- HTTP API, который следует принципам REST
- Конкретные эндпоинты, методы, форматы данных
- Практическая реализация для обмена данными

**Аналогия:**

- REST — это «рецепт» (принципы приготовления блюда)
- REST API — это «готовое блюдо» (конкретная реализация по рецепту)

**На практике:**

Большинство API, которые называют «REST API», на самом деле **не полностью соответствуют** всем принципам REST (особенно HATEOAS). Их правильнее называть:

- **RESTful API** — API, который следует большинству принципов REST, но не всем
- **HTTP API** — просто API поверх HTTP без строгого следования REST

**Примеры:**

✅ **RESTful API** (частично следует принципам):

```http
GET /api/users/1
GET /api/users/1/posts
```

❌ **Не REST** (RPC-стиль):

```http
POST /api/getUser
POST /api/createUser
POST /api/deleteUser
```

**Для фронтенд-разработчика:**

На собеседованиях важно понимать:

- REST — это архитектурный стиль, не протокол
- REST API — это практическая реализация
- Большинство реальных API — это RESTful, а не «чистый» REST
- Важно знать принципы, чтобы понимать, почему API устроен именно так

### Основные принципы REST

1. **Ресурсы и URI**
   - URL описывает _ресурс_: `/users`, `/users/1`, `/orders/42/items`.
   - Ресурсы должны быть существительными, не глаголами.
   - Иерархия через вложенность: `/users/1/posts/5/comments`.

2. **HTTP‑методы как действия**
   - GET — получение (без побочных эффектов)
   - POST — создание нового ресурса
   - PUT — полная замена ресурса (идемпотентный)
   - PATCH — частичное обновление
   - DELETE — удаление (идемпотентный)

3. **Статусы HTTP описывают результат**
   - `200 OK` — успешное получение
   - `201 Created` — ресурс создан
   - `204 No Content` — успешно, но без тела ответа
   - `400 Bad Request` — ошибка клиента
   - `401 Unauthorized` — требуется аутентификация
   - `403 Forbidden` — доступ запрещён
   - `404 Not Found` — ресурс не найден
   - `409 Conflict` — конфликт (например, дубликат)
   - `422 Unprocessable Entity` — валидационная ошибка
   - `500 Internal Server Error` — ошибка сервера

4. **Stateless (без состояния)**
   - Каждый запрос содержит всю необходимую информацию.
   - Сервер не хранит состояние клиента между запросами.
   - Аутентификация через токены (JWT, Bearer), не через сессии.

5. **Кэшируемость (Cacheable)**
   - GET‑запросы должны быть кэшируемыми.
   - Использование заголовков: `Cache-Control`, `ETag`, `Last-Modified`.
   - `304 Not Modified` для экономии трафика.

6. **Единообразный интерфейс (Uniform Interface)**
   - Стандартные HTTP‑методы и статусы.
   - Предсказуемая структура URL.
   - JSON как стандартный формат обмена данными.

7. **Слоистая архитектура (Layered System)**
   - Клиент не знает, общается ли он напрямую с сервером или через прокси/CDN/балансировщик.

### Примеры REST API

**Базовые операции:**

- `GET /api/users` — получить список пользователей (с пагинацией: `?page=1&limit=20`);
- `GET /api/users/1` — получить пользователя с id=1;
- `POST /api/users` — создать нового пользователя (тело: `{ "name": "Иван", "email": "ivan@example.com" }`);
- `PUT /api/users/1` — полностью заменить пользователя (идемпотентный);
- `PATCH /api/users/1` — частично обновить пользователя (тело: `{ "name": "Пётр" }`);
- `DELETE /api/users/1` — удалить пользователя.

**Вложенные ресурсы:**

- `GET /api/users/1/posts` — получить посты пользователя;
- `POST /api/users/1/posts` — создать пост для пользователя;
- `GET /api/users/1/posts/5` — получить конкретный пост.

**Фильтрация и поиск:**

- `GET /api/users?role=admin&status=active` — фильтрация через query‑параметры;
- `GET /api/users?search=ivan&sort=name&order=asc` — поиск и сортировка.

### Версионирование API

**Подходы:**

1. **В URL:** `/api/v1/users`, `/api/v2/users` — явно, но «загрязняет» URL.
2. **В заголовке:** `Accept: application/vnd.api+json;version=2` — чище, но требует настройки.
3. **В поддомене:** `v1.api.example.com` — удобно для микросервисов.

**Рекомендация:** для публичных API — версионирование в URL (`/api/v1/`), для внутренних — можно через заголовки.

### HATEOAS (Hypermedia as the Engine of Application State)

Идеальный REST API должен возвращать не только данные, но и **ссылки на возможные действия**:

```json
{
  "id": 1,
  "name": "Иван",
  "email": "ivan@example.com",
  "_links": {
    "self": { "href": "/api/users/1" },
    "posts": { "href": "/api/users/1/posts" },
    "update": { "href": "/api/users/1", "method": "PATCH" },
    "delete": { "href": "/api/users/1", "method": "DELETE" }
  }
}
```

На практике HATEOAS редко используется полностью, но идея «самодокументируемого API» важна.

### Best Practices для фронтенда

**Структура запросов:**

- Используй правильные HTTP‑методы (не GET для создания).
- Обрабатывай все статусы, не только `200` и `404`.
- Используй правильные заголовки: `Content-Type: application/json`, `Authorization: Bearer <token>`.

**Обработка ошибок:**

```typescript
// Хорошо: структурированные ошибки
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required",
    "fields": { "email": "This field is required" }
  }
}
```

**Пагинация:**

```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

Плюсы для фронтенда:

- простой, читаемый контракт;
- легко дебажить через браузер/Insomnia/Postman;
- хорошо ложится на HTTP‑инфраструктуру (кеши, прокси, CDN);
- предсказуемая структура URL;
- стандартизированные методы и статусы упрощают разработку.

Минусы:

- возможна **перегрузка/недогрузка данных** (overfetching/underfetching): один эндпоинт отдаёт слишком много или слишком мало;
- сложнее, когда нужен очень гибкий выбор полей и связей;
- множественные запросы для связанных данных (проблема N+1);
- нет стандарта на структуру ошибок и пагинацию (каждый API делает по‑своему).

**SOAP**

SOAP — «старый корпоративный тяжеловес»:

- формат сообщений — XML;
- строгие контракты через WSDL;
- сложная, но формальная типизация;
- много расширений (транзакции, безопасность).

Где всё ещё встречается:

- банки и крупные корпорации;
- государственные системы;
- старые интеграции B2B.

Фронтендеру важно:

- уметь работать через **backend‑gateway** (часто SOAP ↔ REST/GraphQL преобразуется на бэкенде);
- понимать, что «давайте просто добавим поле в ответ» в мире SOAP может значить изменение схем, контрактов и согласований.

**GraphQL**

GraphQL — это **запросный язык к данным** и сервер, который умеет эти запросы выполнять.

Ключевые идеи:

- один endpoint, например `/graphql`;
- клиент _декларативно_ описывает, какие поля ему нужны;
- сервер возвращает ровно эти поля — ни больше, ни меньше.

**Пример запроса:**

```graphql
query {
  user(id: "1") {
    id
    name
    posts(limit: 5) {
      id
      title
    }
  }
}
```

Плюсы:

- решает проблему overfetching/underfetching;
- удобен для **фронтенд‑heavy** приложений и сложных UI;
- сильная типизация схемы (SDL), автогенерация TypeScript‑типов;
- удобная интеграция с кэшами на клиенте (Apollo, Relay, URQL).

Минусы:

- сложнее кеширование на уровне CDN (всё идёт через один endpoint);
- сложнее дебаг HTTP‑трафик «глазами» (нужно смотреть в тело запроса);
- оверхед для простых CRUD‑API.

**gRPC**

gRPC — RPC‑фреймворк поверх HTTP/2 (и HTTP/3 в новых версиях) с бинарным протоколом **Protocol Buffers (protobuf)**.

Характеристики:

- очень маленькие и быстрые сообщения;
- чёткая контрактная типизация;
- отличен для общения микросервисов между собой.

Типичный сценарий:

- фронтенд общается с **REST/GraphQL‑шлюзом**;
- этот шлюз уже говорит с внутренними сервисами по gRPC.

На фронтенде gRPC чаще встречается:

- в десктопных/мобильных клиентах;
- в internal‑инструментах;
- при использовании gRPC‑web через proxy (Envoy и др.).

**Что важно для собеседований:**

- REST — «дефолтный» выбор, знать надо очень хорошо;
- SOAP — понимать на уровне «старый XML‑ориентированный корпоративный стандарт»;
- GraphQL — часто спрашивают подробно: схема, запросы, мутации, фрагменты, кеширование;
- gRPC — знать как быстрый бинарный транспорт между сервисами и почему его обычно прячут за REST/GraphQL‑слоем для фронтенда.

---

## 1.9. CORS и Same-Origin Policy

### Same-Origin Policy

`origin = protocol + domain + port`

**Пример:**

- `https://example.com:443`
- `http://example.com:80` → другой origin
- `https://api.example.com` → другой origin

CORS — механизм, позволяющий частично ослаблять это правило.

**Важно:** CORS настраивает сервер, а не браузер. Браузер лишь исполняет политику сервера.

---

## 1.10. WebSockets и SSE

### WebSocket

- двусторонняя связь
- постоянное соединение
- чаты, игровая логика

**Пример:**

```javascript
const ws = new WebSocket('wss://echo.example')
ws.onmessage = (e) => console.log(e.data)
ws.send('Привет')
```

### SSE (Server-Sent Events)

- односторонний поток от сервера к клиенту
- легче, чем WebSocket
- автоматическое переподключение
- дешевле по ресурсам

Как радио: сервер говорит, клиент слушает.

---

## Вопросы на собеседовании

### 1. Опишите, что происходит, когда пользователь вводит URL в браузер

Короткий и хороший ответ:

1. Проверка кэша
2. DNS-резолв
3. TCP-handshake
4. TLS-handshake (если HTTPS)
5. HTTP-запрос → HTML
6. Парсинг HTML → DOM
7. Загрузка CSS/JS
8. Рендеринг

### 2. В чём отличие HTTP/1.1, HTTP/2 и HTTP/3?

- HTTP/1.1 — много соединений, блокировки
- HTTP/2 — одно соединение, мультиплексирование
- HTTP/3 — QUIC/UDP, меньше задержек, устойчивость при потере пакетов

### 3. Что такое DNS и зачем он нужен?

DNS — система доменных имён, превращающая доменное имя в IP-адрес. Это «телефонный справочник Интернета».

### 4. Чем TCP отличается от UDP?

TCP — надёжный протокол с гарантией доставки, но с задержками из-за handshake. UDP — быстрый, без гарантий, используется для стриминга и игр.

### 5. Что такое TLS Handshake?

Процесс установки защищённого соединения, включающий обмен сертификатами и ключами. Обычно добавляет 1 RTT к первому запросу.

### 6. Что такое идемпотентность?

Свойство запроса, позволяющее повторять его без изменения результата. GET, PUT, DELETE — идемпотентны, POST — нет.

### 7. Что такое CORS?

Cross-Origin Resource Sharing — механизм, позволяющий ослаблять Same-Origin Policy. Настраивается на сервере.

### 8. Чем WebSocket отличается от SSE?

- WebSocket — двустороннее общение
- SSE — только сервер → клиент
- SSE проще, WS мощнее

---

## Key Takeaways

- Интернет — это набор уровней: DNS, TCP, TLS, HTTP.
- Самые дорогие операции — DNS и handshakes.
- HTTP/2 и HTTP/3 радикально ускоряют загрузку.
- HTTPS обязателен — это не роскошь.
- CORS — серверная политика, браузер лишь её исполняет.
- WebSocket — для диалога, SSE — для трансляций.
- Понимание сетевого стека — важный навык middle/senior разработчика.

---

Дальше мы переключимся с сети на сам браузер: разберём, из каких процессов он состоит, как они общаются друг с другом и что именно происходит «под капотом» после того, как запрос уже выполнился и данные пришли.
