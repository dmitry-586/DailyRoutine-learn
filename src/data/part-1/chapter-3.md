# Глава 3. Рендеринг: путь от HTML до пикселей

Это одна из центральных глав всей книги. Она объясняет то, что на собеседованиях спрашивают постоянно — от Junior до Senior уровня.

Попробуй представить: ты открываешь сайт, и буквально за миллисекунды перед тобой появляется целый интерфейс — кнопки, картинки, тексты, анимации. Но браузер — это не художник, который рисует страницу кистью. Он — инженер, который строит страницу по плану.

Процесс превращения HTML в картинку можно сравнить с работой архитектурного бюро:

1. Получить проект (HTML)
2. Составить список материалов (CSS)
3. Построить структуру здания (DOM)
4. Применить стиль и внешний вид (CSSOM)
5. Собрать модель здания (Render Tree)
6. Разложить элементы по местам (Layout)
7. Покрасить и отделать стены (Paint)
8. Собрать слои в финальный кадр (Composite)

Это и есть Critical Rendering Path.

Понимание рендеринга даёт вам:

- способность оптимизировать интерфейсы
- умение объяснять performance-проблемы
- уверенность при работе с layout, стилями и JavaScript
- знание того, почему интерфейсы «дергаются»
- умение писать быструю анимацию
- понимание, как реально работает браузер

---

## 3.1. Парсинг HTML и построение DOM

Фронтенд-разработчики часто думают о HTML как о «тексте». Но для браузера HTML — это инструкции.

Когда сетевой процесс приносит HTML, рендерер начинает читать его посимвольно, как книгу. И по ходу чтения строит DOM-дерево:

- `<html>` становится корнем
- `<body>`, `<head>` — детьми
- каждый тег становится узлом
- текстовые узлы тоже входят в DOM

**Этапы обработки HTML:**

1. HTML поступает в Renderer Process потоково
2. Парсер считывает текст посимвольно
3. Строится токенизация (открывающий тег, атрибуты, текст)
4. На основе токенов формируются узлы
5. Узлы образуют DOM (Document Object Model)

DOM — это не HTML. HTML — строка текста. DOM — структура данных в памяти.

Аналогия: Когда ты читаешь книгу, у тебя в голове появляется «карта» событий и персонажей. DOM — это такая же карта, только для браузера.

### Блокирующие моменты при загрузке HTML

HTML-парсинг может быть остановлен по нескольким причинам:

- встречен `<script>` без атрибута defer
- встречен `<link rel="stylesheet">`
- встречены синхронные операции, влияющие на рендеринг

Вот типичный пример блокировки:

```html
<script src="main.js"></script>
```

Парсер останавливается, пока:

1. JS-файл загружается
2. выполняется

Поэтому используют:

```html
<script src="main.js" defer></script>
```

или

```html
<script src="main.js" async></script>
```

**Частый вопрос на собеседовании:**

Чем defer отличается от async?

- async — скачивается параллельно, выполняется сразу после загрузки
- defer — скачивается параллельно, выполняется после полного парсинга HTML

---

## 3.2. CSSOM и блокирующие ресурсы

CSS-файлы — блокирующие.

**Почему?**

Представь, что ты делаешь версию макета для разработчика: пока дизайнер не определился с шрифтами, отступами и сеткой, смысла «выводить макет в прод» особо нет — всё равно придётся переделывать. Браузер думает так же: он не может корректно построить render tree, пока не знает, какие стили применяются.

Поэтому:

```html
<link rel="stylesheet" href="styles.css" />
```

останавливает рендеринг до загрузки и парсинга CSS.

CSSOM (CSS Object Model) строится аналогично DOM, но из CSS-правил.

**Пример:**

```css
body {
  font-size: 16px;
}

#title {
  color: red;
}
```

Станет структурой наподобие:

- body: font-size: 16px
- #title: color: red

CSSOM важен по двум причинам:

1. Без CSSOM браузер не может начать рендеринг. Это причина, почему CSS блокирует отображение: сначала нужно понять, _как_ всё должно выглядеть, и только потом рисовать.
2. Если использовать сложные селекторы (div ul li span:first-child), CSSOM пересчёт становится дорогим. Каждое изменение структуры DOM заставляет браузер снова пробегать дерево стилей и решать, какие правила подходят под какой элемент. На маленьких страницах это незаметно, на реальных админках и дэшбордах — уже ощутимо.

**Почему CSS блокирует рендеринг?**

Потому что изменение CSS влияет на layout и внешний вид, и браузеру нужно гарантировать корректность. Если бы он сначала нарисовал страницу без стилей, а потом понял, что размеры и расположение совсем другие, пришлось бы делать двойную работу.

Кроме того, JS может зависеть от стилей: `div.offsetWidth` и похожие вызовы читают уже рассчитанные размеры. Поэтому браузер останавливает выполнение, пока не будет уверен, что текущие CSS‑правила учтены.

Поэтому порядок важен:

- сначала DOM
- затем CSSOM
- потом Render Tree

---

## 3.3. Render Tree и вычисление Layout

После DOM и CSSOM браузер создаёт Render Tree: Render Tree = DOM-узлы, которые видимы, + вычисленные стили.

**Важно понимать:** Render Tree ≠ DOM

**Пример:**

```html
<div style="display: none;">Hello</div>
```

Этот элемент есть в DOM. Но его нет в Render Tree, потому что он не отображается.

**Не попадают в Render Tree:**

- display: none
- head
- script

После Render Tree вычисляется Layout (reflow):

- width
- height
- position
- шрифты
- box-model
- размер и положение каждого элемента

Layout — дорогая операция.

Для браузера это один из самых затратных этапов: ему нужно пересчитать геометрию очень большого количества узлов. В сложных интерфейсах с таблицами, лентами, дашбордами это легко превращается в заметные фризы при прокрутке или обновлении данных.

Работу layout можно сравнить с расстановкой мебели в квартире:

1. Определить размеры комнаты (viewport)
2. Понять размеры мебели (элементов)
3. Расставить так, чтобы всё поместилось и не перекрылось

**Важный момент**

Layout может быть:

- частичным
- полным
- рекурсивным

И он может запускаться снова и снова при:

- изменении размеров окна
- добавлении элементов
- изменении содержимого
- изменении стилей (особенно размеров)

Это называется reflow.

---

## 3.4. Paint, Composite и GPU-ускорение

После Layout идет:

**Paint (рисование)** — браузер красит элементы пиксель за пикселем

После layout у браузера есть «скелет» страницы — он знает, где и что стоит. Теперь пора всё визуально нарисовать.

Paint — это:

- цвет фона
- цвет текста
- бордеры
- тени
- изображения
- outline

Это самый «ручной» этап. Браузер превращает каждый визуальный элемент в набор команд:

- нарисовать прямоугольник
- залить цветом
- провести линию
- вставить текст
- наложить тень

Painter проходит по дереву и рисует битмапы.

**Composite (компоновка слоёв)**

Современные браузеры отображают страницу не как один большой холст. Они разбивают её на слои.

Например:

- элемент с position: fixed — почти всегда отдельный слой
- элемент с transform — отдельный слой
- элемент с will-change: opacity — отдельный слой
- canvas
- видео
- анимации

GPU-процесс потом берет все слои и композитит их — совмещает.

Это похоже на Photoshop:

- слой с фоном
- слой с картинками
- слой с текстом
- слой с анимациями

GPU смешивает эти слои в один кадр. GPU композитит их 60 раз в секунду (или 120 на ProMotion дисплеях).

Это позволяет анимировать элементы без reflow и repaint.

**Практический принцип:**

Анимируйте только opacity и transform. Другие свойства вызывают reflow или repaint.

---

## 3.5. Reflow vs Repaint

Это важнейшая тема для оптимизации интерфейсов.

### Reflow (Layout)

Когда браузер пересчитывает расположение элементов.

На практике это означает: любая операция, которая может изменить размер или положение хотя бы одного блока, потенциально затрагивает всю цепочку соседей и родителей. Поэтому один неосторожный стиль, добавленный в корень, может вызвать пересчёт _всей_ страницы.

**Вызывают:**

- изменение размера окна
- изменение стилей layout-а (width, height, margin, padding, position, font-size)
- изменение DOM
- clientWidth / offsetTop / getBoundingClientRect
- добавление/удаление узлов

Браузер должен пересчитать layout, иногда — всей страницы. Это дорого.

### Repaint (Paint)

Перерисовка визуальных деталей без изменения layout.

**Вызывают:**

- color
- background
- border-color
- visibility

Расположение не меняется → layout не запускается. Дороже, чем просто смена opacity, но дешевле layout.

Полезно мыслить так: **reflow = переосмыслить, где что стоит; repaint = перерисовать то, что уже стоит на месте**. Чем реже вы заставляете браузер «думать заново» о расположении элементов, тем плавнее ощущается интерфейс.

### Composite-only

Если меняется только opacity, transform — браузер трогает только GPU-композицию. Это самый дешёвый тип изменения.

**Как избежать?**

- минимизировать DOM-операции
- использовать DocumentFragment
- применять transform вместо left/top
- группировать изменения (reflow batching)
- избегать запроса layout-свойств в цикле

---

## 3.6. JavaScript и рендеринг

JavaScript блокирует рендеринг, если:

По умолчанию движок JS и рендеринг страницы делят один и тот же поток. Пока выполняется тяжёлый синхронный скрипт, браузер не может ни пересчитать layout, ни отрисовать новый кадр. Именно поэтому «невинный» цикл или тяжёлая функция могут ощущаться как зависший интерфейс.

- выполняется синхронно
- меняет layout
- вставляет новые DOM-узлы
- вызывает тяжёлые операции (offsetHeight, getBoundingClientRect)

**Пример:**

```javascript
const height = element.offsetHeight // вызывает reflow
element.style.height = height + 10 + 'px' // ещё один reflow
```

Это называется layout thrashing.

### Проблемы производительности: layout thrashing

Layout thrashing — это когда код вызывает чередование reflow и repaint.

Это выглядит так: код то читает layout‑свойства (заставляя браузер всё посчитать), то сразу же пишет новые стили (заставляя его пересчитывать всё заново) — и так десятки или сотни раз подряд.

**Пример плохого кода:**

```javascript
for (let i = 0; i < 1000; i++) {
  element.style.left = i + 'px'
  console.log(element.offsetLeft) // провоцирует reflow
}
```

Браузер:

1. меняет стиль
2. пересчитывает layout
3. печатает
4. снова …

**Используйте:**

1. промежуточные переменные
2. batching через rAF
3. read → write порядок

---

## 3.7. requestAnimationFrame и оптимизация анимаций

Для плавных анимаций браузер использует render loop — цикл, который рисует новые кадры.

Можно думать об этом как о сердцебиении интерфейса: на каждом «ударе» браузер имеет шанс обновить картинку. Если вы пытаетесь анимировать что‑то вне этого цикла (через голый setInterval), вы почти наверняка будете промахиваться мимо реального ритма экрана.

Анимации по таймеру:

```javascript
setInterval(() => { ... }, 16);
```

работают плохо — они не синхронизированы с частотой обновления монитора.

### requestAnimationFrame (rAF)

Даёт оптимальное время для рендера кадра. Браузер вызывает rAF перед следующим кадром, обычно 60 FPS.

Это означает:

- обновление в момент, когда GPU готов
- идеальная синхронизация
- лучший FPS
- отсутствует рваная анимация

**Используйте rAF для:**

- анимаций
- параллакса
- canvas
- плавного UI

Timers (setTimeout, setInterval) этим не обладают.

---

## 3.8. Почему важен Critical Rendering Path

CRP — это набор шагов, которые браузер должен пройти, прежде чем пользователь увидит хоть что-то.

С точки зрения пользователя важен не только «общий» TTFB, а то, **когда на экране появляется первый осмысленный контент**. Именно на это влияет длина Critical Rendering Path: чем меньше блокирующих ресурсов и тяжёлых операций до первого рендера, тем «живее» ощущается приложение.

Фактически: Чем короче CRP — тем быстрее сайт кажется пользователю.

**Укоротить CRP можно:**

- уменьшив CSS (так как он блокирует рендеринг)
- используя preload
- уменьшая количество JavaScript, блокирующего парсинг
- избегая больших layout-операций
- уменьшая количество уровней вложенности DOM

### События жизненного цикла страницы

**DOMContentLoaded**

Срабатывает, когда DOM готов, но CSS и картинки могут ещё грузиться.

**load**

Срабатывает, когда всё загружено — CSS, картинки, iframe.

**visibilitychange**

Позволяет оптимизировать поведение, когда вкладка скрыта.

**Где это спрашивают?**

На собеседованиях Middle/Senior любят спросить:

- "Когда выполнить скрипт?"
- "В чём разница между DOMContentLoaded и load?"
- "Почему JS влияет на рендеринг?"

### Оптимизация рендеринга: золотые правила

1. Анимируй только transform + opacity
2. Используй will-change умеренно
3. Минимизируй глубину DOM
4. Не вычитывай layout-свойства в цикле
5. Избегай больших таблиц и теней
6. Разгружай heavy JS в Web Workers

---

## Вопросы на собеседовании

### 1. Опишите полностью pipeline рендеринга страницы

Ответ:

- браузер парсит HTML → DOM
- парсит CSS → CSSOM
- объединяет → Render Tree
- делает layout
- делает paint
- делает composite

CRP важен, потому что он определяет скорость появления контента.

### 2. Что такое DOM, CSSOM и Render Tree?

- DOM — дерево объектов, представляющих HTML-структуру
- CSSOM — дерево стилей из CSS-правил
- Render Tree — объединение видимых DOM-узлов с вычисленными стилями

### 3. Почему `<script>` блокирует рендеринг?

Потому что JS может изменить DOM и CSSOM, поэтому браузер должен дождаться выполнения скрипта перед продолжением парсинга.

### 4. Что такое reflow и repaint?

- reflow (layout) — пересчёт расположения элементов (дорого)
- repaint — перерисовка визуальных деталей без изменения layout (дешевле)

### 5. Какие CSS-свойства вызывают Layout?

width, height, margin, padding, position, font-size и другие, влияющие на размеры и расположение.

### 6. Что делает requestAnimationFrame?

Синхронизирует обновления с частотой обновления экрана, даёт оптимальное время для рендера кадра.

### 7. Как работает GPU-композитинг?

Браузер разбивает страницу на слои, GPU смешивает их в один кадр 60 раз в секунду. Это позволяет анимировать без reflow/repaint.

### 8. Как избежать layout thrashing?

- группировать чтения layout-свойств
- использовать промежуточные переменные
- применять batching через rAF
- следовать порядку: read → write

### 9. В чём разница между visibilitychange и load?

- visibilitychange — когда вкладка скрыта/показана
- load — когда все ресурсы загружены

### 10. Какие элементы не входят в Render Tree?

`display: none`, `head`, `script` и другие невидимые элементы.

---

## Key Takeaways

- Браузер превращает HTML в пиксели через цепочку DOM → CSSOM → Render Tree → Layout → Paint → Composite
- CSS блокирует рендеринг до тех пор, пока не построен CSSOM
- JavaScript может замедлять рендеринг, блокируя парсинг HTML
- Reflow — самая дорогая операция; избегай её в циклах
- Самые дешёвые анимации — те, что используют только transform и opacity
- Оптимизация CRP — ключ к быстрой загрузке сайта
- requestAnimationFrame синхронизирует анимации с частотой обновления экрана

---

Дальше мы переключимся от внутренних механизмов рендеринга к тому, как мы описываем сами интерфейсы: поговорим о семантике HTML, доступности, правильных тегах и паттернах, которые делают ваши страницы понятными не только браузеру, но и людям, поисковым роботам и ассистивным технологиям.
