# Глава 10. Фундамент JavaScript: как язык устроен под капотом

Эта глава — про «скелет» языка. Не про синтаксис, а про то, **как JavaScript реально работает**:

- какие есть типы данных и чем они отличаются;
- как и когда происходят неявные преобразования типов;
- что такое область видимости, hoisting и TDZ;
- в чём разница `var / let / const` и разных видов функций;
- что такое Execution Context, Lexical Environment и как устроен стек вызовов.

Если эти вещи не разобраны до конца, дальше (замыкания, `this`, асинхронность, React) будет постоянно «подвисать» ощущение магии.

---

## 8.1. Типы данных в JavaScript: примитивы и объекты

В JavaScript 8 встроенных типов данных:

**Примитивные типы (передаются по значению):**

1. `number`
2. `string`
3. `boolean`
4. `null`
5. `undefined`
6. `symbol`
7. `bigint`

**Ссылочный тип:**

8. `object` — всё остальное: объекты, массивы, функции, `Map`, `Set`, `Date` и т.п.

### Почему разделение на примитивы и объекты так важно

От этого зависит:

- **как передаётся значение** в функцию и при присваивании;
- **как ведёт себя `===` и `==`;**
- **как устроена память:** что лежит в стеке, а что — в куче (heap).

### Примитивы: копия значения

```javascript
let a = 10
let b = a

b = 20

console.log(a) // 10 — a не изменился
console.log(b) // 20
```

`a` и `b` — два независимых значения.

### Объекты: ссылка на одну и ту же область памяти

```javascript
const obj1 = { x: 1 }
const obj2 = obj1

obj2.x = 2

console.log(obj1.x) // 2 — изменился исходный объект
console.log(obj2.x) // 2
```

`obj1` и `obj2` указывают **на один и тот же объект**.

### Иммутабельность примитивов

Примитивы нельзя «изменить по месту» — только заменить новым значением:

```javascript
let str = 'hi'
str[0] = 'H' // попытка ничего не изменит

str = 'Hi' // создана новая строка
```

**Ключевая мысль:**

- примитивы ведут себя как «значения в коробках»;
- объекты — как «бирки с адресом», по которому лежат данные.

---

## 8.2. Приведение типов (Type Coercion)

JavaScript часто сам пытается «договориться» о типах между собой. Это называется **приведение типов** (coercion) и бывает:

- **явным** — когда ты сам вызываешь `Number()`, `String()`, `Boolean()`;
- **неявным** — когда это делает движок за тебя при операциях `+`, `-`, сравнении и т.п.

### Явное приведение

```javascript
Number('42') // 42
String(42) // '42'
Boolean(1) // true
Boolean('') // false
```

### Неявное приведение: странные, но логичные правила

```javascript
'5' + 2   // '52'      — строка + число → строка
'5' - 2   // 3         — минус всегда приводит к number
[] + []   // ''        — оба приводятся к строке
{} + []   // '[object Object]' — объект → строка
```

За этим стоят формальные правила спецификации (ECMAScript), а не «рандом». На собеседованиях важно **объяснять логику, а не зубрить частные случаи**.

### Truthy / Falsy значения

В условных конструкциях (`if`, `while`, `?:`) значение сначала приводится к `boolean`.

**Falsy-знаений всего 8:**

- `false`
- `0`
- `-0`
- `0n` (BigInt)
- `''` (пустая строка)
- `null`
- `undefined`
- `NaN`

Всё остальное — **truthy**.

### Сравнение `==` и `===`

- `===` — **строгое сравнение**: сначала проверяется тип, потом значение, без приведения типов.
- `==` — **нестрогое сравнение**: пытается привести значения к общему типу.

```javascript
0 == false      // true
'' == 0         // true
null == undefined // true
[] == 0         // true

0 === false     // false
'' === 0        // false
null === undefined // false
[] === 0        // false
```

**Практическое правило:**

- в прикладном коде почти всегда используй `===`;
- `== null` иногда используют осознанно для проверки сразу на `null` **или** `undefined`.

---

## 8.3. Область видимости, hoisting и TDZ

**Область видимости (scope)** — ответ на вопрос: «Где эта переменная доступна в коде?»

Основные виды областей видимости в современном JS:

1. **глобальная** (global scope);
2. **функция** (function scope);
3. **блок** `{ ... }` (block scope).

### `var`: function scope

```javascript
if (true) {
  var x = 10
}

console.log(x) // 10 — переменная всё ещё доступна
```

`var` **игнорирует блоки** — живёт на уровне функции или глобально.

### `let` / `const`: block scope

```javascript
if (true) {
  let y = 20
  const z = 30
}

console.log(y) // ReferenceError
console.log(z) // ReferenceError
```

`let` и `const` живут **строго внутри блока** `{ ... }`.

### Hoisting: поднятие объявлений

Движок JavaScript **сначала** проходит файл, «регистрирует» объявления, а уже потом выполняет код. Это и называется hoisting.

#### `var` и hoisting

```javascript
console.log(a) // undefined, но не ошибка
var a = 5
```

Под капотом это похоже на:

```javascript
var a
console.log(a)
a = 5
```

#### `let` / `const` и TDZ

`let` и `const` тоже поднимаются, но попадают в **Temporal Dead Zone (TDZ)**: участок кода **от начала области до строки объявления**, где переменную **нельзя использовать**.

```javascript
console.log(b) // ReferenceError — TDZ
let b = 10
```

### Hoisting функций

**Function Declaration** поднимаются целиком:

```javascript
say() // 'Hello'

function say() {
  console.log('Hello')
}
```

**Function Expression** — нет:

```javascript
say() // TypeError: say is not a function

const say = function () {
  console.log('Hello')
}
```

**Интервью-вопрос:**

> Объясните разницу hoisting для `var`, `let/const` и функций.

Ответ должен включать: scope, TDZ и различие declaration / expression.

---

## 8.4. `var`, `let`, `const`: когда и что использовать

Сравним в таблице:

**`var`**

- область видимости: **функция**;
- hoisting: да, значение по умолчанию `undefined`;
- можно переобъявлять в той же области;
- нет TDZ.

**`let`**

- область видимости: **блок**;
- hoisting: да, но с TDZ (нельзя использовать до строки объявления);
- переобъявление в одной области запрещено;
- можно менять значение.

**`const`**

- область видимости: **блок**;
- hoisting: да, но с TDZ;
- переобъявление и переназначение запрещены;
- **но** внутреннее состояние объекта / массива менять можно:

```javascript
const obj = { x: 1 }
obj.x = 2 // ок
// obj = {}   // ошибка
```

**Современное практическое правило:**

- по умолчанию используй `const`;
- переходи на `let`, когда значение действительно должно меняться;
- `var` в новом коде не используй **никогда**, кроме как в учебных целях.

---

## 8.5. Виды функций и их особенности

В JavaScript есть несколько способов объявить функцию. Они ведут себя по-разному с точки зрения hoisting, `this` и использования.

### Function Declaration

```javascript
function sum(a, b) {
  return a + b
}
```

- поднимается целиком (можно вызывать до объявления);
- удобно для «главных» функций модуля.

### Function Expression

```javascript
const sum = function (a, b) {
  return a + b
}
```

- сначала создаётся переменная, потом в неё кладут функцию;
- поднимается только объявление переменной (`const sum`), но не значение;
- популярно для коллбеков и когда важен порядок определения.

### Arrow Function

```javascript
const sum = (a, b) => a + b
```

- **не имеет собственного `this` и `arguments`**;
- нельзя вызывать через `new` (не конструктор);
- идеально подходит для коротких функций и коллбеков.

### Named Function Expression

```javascript
const factorial = function fact(n) {
  if (n === 0) return 1
  return n * fact(n - 1)
}
```

- имя `fact` доступно только внутри самой функции;
- удобно для рекурсии и отладки (имя видно в стеке вызовов).

**Что важно запомнить к этой главе:**

- **как разные виды функций ведут себя при hoisting**;
- **что у стрелки нет собственного `this` и `arguments`**;
- **что стрелки не используют как методы объектов и конструкторы**.

Подробно про `this`, стрелки и контекст мы поговорим в следующей главе.

---

## 8.6. Execution Context и Lexical Environment по‑человечески

Когда движок JS выполняет код, он создаёт **контексты выполнения** (Execution Context):

- **глобальный контекст** (при загрузке файла);
- **контекст функции** (при вызове любой функции);
- (в ES-модулях — ещё и контекст модуля).

Каждый контекст включает в себя:

- **Lexical Environment** — где хранятся переменные и ссылки наружу;
- **Variable Environment** (исторически выделяется отдельно, в упрощении можно считать частью LE);
- **связку `this`**.

### Lexical Environment: цепочка видимости

При создании функции движок «приклеивает» к ней ссылку на окружение, в котором она была объявлена.

```javascript
function outer() {
  const x = 10

  function inner() {
    console.log(x)
  }

  return inner
}

const fn = outer()
fn() // 10
```

`inner` продолжает «видеть» `x`, потому что хранит ссылку на **Lexical Environment** функции `outer`, даже после её завершения. Это и есть основа замыканий (разберём позже).

**JS — лексически скоупированный язык:** область видимости определяется **по месту записи в коде**, а не по месту вызова.

---

## 8.7. Стек вызовов и память: зачем это знать фронтендеру

JavaScript — **однопоточный** язык: в каждый момент времени выполняется только один фрагмент кода. Управляет этим **стек вызовов** (Call Stack).

### Пример стека вызовов

```javascript
function a() {
  b()
}

function b() {
  c()
}

function c() {
  console.log('Hi')
}

a()
```

Последовательность в стеке:

1. глобальный контекст;
2. вызов `a` → контекст `a` на вершине стека;
3. `a` вызывает `b` → сверху новый контекст `b`;
4. `b` вызывает `c` → сверху контекст `c`;
5. `c` завершилась → её контекст снимается со стека;
6. завершается `b`, потом `a`, потом глобальный код.

### Stack vs Heap

Упрощённо:

- **stack** — для примитивов и ссылок на объекты;
- **heap (куча)** — для самих объектов.

Отсюда:

- копируя примитив, ты получаешь **новое значение**;
- копируя объект, ты копируешь **ссылку** на область в куче.

### Сборщик мусора (Garbage Collector)

Современные движки (V8 и др.) используют модификации алгоритма **mark-and-sweep**:

1. находят «корневые» объекты (глобальный контекст, текущий стек вызовов и т.п.);
2. обходят по ссылкам всё, что достижимо;
3. всё недостижимое помечается как мусор и удаляется.

Практический вывод:

- объекты и замыкания могут «жить» в памяти дольше, чем ты ожидаешь;
- удержание больших структур в замыканиях или глобале может привести к утечкам.

---

## 8.8. Мини‑самопроверка по главе

Проверь, что ты можешь **без IDE и Google**:

- перечислить все примитивные типы JS и объяснить разницу «по значению / по ссылке» на простых примерах;
- предсказать результат для выражений с приведением типов: `'5' + 2`, `'5' - 2`, `[] == 0`, `null == undefined` и объяснить, почему так;
- объяснить на словах, чем отличается область видимости `var` от `let/const`, и что такое TDZ;
- рассказать, как ведут себя Function Declaration и Function Expression при hoisting;
- нарисовать упрощённую картинку: глобальный контекст → вызов функции → стек вызовов и где в этой схеме лежат примитивы и объекты;
- объяснить, что такое Lexical Environment и почему функция «помнит» переменные из внешней функции.

Если это даётся уверенно — фундамент по языку у тебя уже на уровне, достаточном для комфортного входа в темы `this`, замыканий, прототипов и асинхронности, которые идут дальше.
