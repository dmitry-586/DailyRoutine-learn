# Глава 35. Итоговый чек-лист

Эта глава — не просто список требований к уровням, а инструмент самодиагностики.
Идея в том, чтобы честно посмотреть на свои навыки после прочтения книги, увидеть пробелы и составить понятный план развития,
а не закрыть книгу с ощущением «ну, вроде всё понятно».

Чек-лист не претендует на универсальный стандарт рынка, но задаёт **реалистичные ожидания** от Junior и Middle во фронтенде,
если опираться на современные стеки (React, TypeScript, Node.js, экосистема вокруг).

---

## 32.1. Что должен знать Junior (и как это проверить)

Junior — это разработчик, который:

- уверенно владеет базой,
- умеет учиться,
- может выполнять задачи под присмотром и не ломать проект.

**HTML, CSS, JavaScript основы**

- Понимание семантической вёрстки (заголовки, списки, формы, доступность).
- Базовые layout‑ы: Flexbox, Grid на уровне типичных макетов.
- Базовый JS: переменные, функции, условия, циклы, работа с массивами и объектами.

Проверка для себя:

- можешь ли ты **с нуля** вёрсткой и простым JS реализовать лендинг с формой и валидацией без фреймворков;
- можешь ли объяснить разницу между `let` / `const`, `==` / `===`, `map` / `forEach`.

**React основы (компоненты, props, state)**

- Функциональные компоненты и `props`.
- Локальное состояние через `useState`.
- Простейшая композиция компонентов (Layout, Header, List, Item).

Проверка:

- можешь ли ты собрать небольшое приложение ToDo/списка задач с фильтрацией и сохранением в localStorage;
- можешь ли объяснить, когда стоит поднимать состояние выше по дереву.

**Работа с DOM и асинхронностью**

- Понимание `addEventListener`, базовой работы с формами и событиями.
- Базовое понимание `Promise`, `async/await`, `fetch`.

Проверка:

- можешь ли ты написать функцию, которая загружает данные с API, обрабатывает ошибки и показывает состояние загрузки;
- можешь ли объяснить, чем `then` отличается от `async/await`, и где может «потеряться» ошибка.

**Инструменты**

- Git на уровне ветвление, коммиты, pull‑request.
- Браузерные DevTools: вкладки Elements, Network, Console.

Проверка:

- можешь ли ты найти причину ошибки в консоли и посмотреть, почему запрос вернул 500/404;
- можешь ли ты сделать понятный PR с описанием изменений.

---

## 32.2. Что должен знать Middle

Middle — это разработчик, которому можно доверить фичу «под ключ»:
от обсуждения требований до релиза, без тотального контроля.

**Глубокая механика JavaScript**

- `this`, контекст, замыкания, область видимости.
- прототипное наследование, `class` как синтаксический сахар.
- Event Loop, micro/macro‑tasks на уровне, достаточном для объяснения поведения промисов и таймеров.

Проверка:

- можешь ли объяснить, почему `this` в обработчике события отличается от `this` в стрелочной функции;
- можешь ли предсказать порядок логов в цепочке `setTimeout` + `Promise`.

**Современный React**

- Хуки: `useEffect`, `useMemo`, `useCallback`, `useRef` и их типичные ошибки.
- Управление состоянием: Context, Redux/Zustand/MobX или другие паттерны.
- Разделение на контейнеры/презентеры, грамотная декомпозиция компонентов.

Проверка:

- умеешь ли ты объяснить, почему компонент рендерится лишний раз и как это исправить;
- можешь ли вынести бизнес‑логику из компонента в хук/слой сервисов.

**Производительность и оптимизация**

- базовое понимание Core Web Vitals и причин деградации;
- умение использовать Code Splitting, `React.lazy`, динамические импорты;
- осознанное использование `memo`, `useMemo`, `useCallback`.

Проверка:

- можешь ли ты, посмотрев на bundle‑report, предложить конкретные шаги по уменьшению бандла;
- знаешь ли, когда **не надо** оптимизировать и почему ранняя оптимизация вредна.

**TypeScript**

- уверенное владение базой типов: интерфейсы, generics, union/intersection, `Pick`, `Omit` и т.п.;
- типизация компонентов и кастомных хуков;
- работа с типами API и моделями домена.

Проверка:

- можешь ли ты типизировать сложный объект ответа API так, чтобы IDE реально помогала;
- умеешь ли ты исправлять неочевидные ошибки типов, а не просто ставить `any`.

**Тестирование и архитектура**

- unit‑/component‑тесты (Jest, Testing Library или аналог);
- базовое понимание архитектуры: слои, ответственность модулей, работа с фичами;
- умение разбирать и улучшать чужой код, а не только писать новый.

Проверка:

- можешь ли ты покрыть неочевидный баг тестом, прежде чем фиксить его;
- можешь ли объяснить, почему текущее разбиение по папкам усложняет поддержку, и предложить лучшее.

---

## 32.3. Типичные ошибки кандидатов (и как их избежать)

**Непонимание Event Loop и асинхронности**

- Симптом: уверенность «я всё знаю про промисы», но неумение объяснить порядок выполнения.
- Решение: руками писать и прогонять маленькие примеры, смотреть DevTools, читать специфику Node vs браузер.

**Ошибки в `useEffect` (зависимости и утечки)**

- Симптом: бесконечные циклы рендера или «случайные» запросы.
- Решение: отработать несколько типовых паттернов (`effect` для запроса, для подписки, для синхронизации) и понимать, что именно попадает в зависимости.

**Незнание основ браузера (рендеринг, сеть)**

- Симптом: попытка оптимизировать React без понимания, что проблема в шрифтах или огромных изображениях.
- Решение: вернуться к главам про сеть, рендеринг и производительность, потренироваться с Lighthouse/WebPageTest.

**Игнорирование производительности и UX**

- Симптом: «зато работает», без учёта времени загрузки, ресайза, слабых устройств.
- Решение: при проектировании фичи сразу думать о размере бандла, количестве запросов и поведении на мобильных.

**Отсутствие понимания типизации**

- Симптом: повсюду `any`, `as unknown as`, отключённый строгий режим.
- Решение: постепенно ужесточать TypeScript‑конфиг и осознанно разбирать ошибки типов.

---

## 32.4. Как использовать этот чек-лист

1. Пройдись по главам книги и выпиши ключевые темы (сеть, браузер, React, TS, архитектура, производительность, безопасность, Node, собеседования).
2. В каждой теме честно отметь свой уровень: «знаю теорию», «делал в проектах», «могу объяснить и обучить другого».
3. Составь **короткий план на 4–6 недель**: не всё сразу, а 1–2 направления, которые сильнее всего подтянут общий уровень.
4. Привяжи план к реальным действиям: пет‑проект, задачи на работе, вклад в opensource, подготовка к собеседованиям.
5. Возвращайся к чек-листу каждые несколько месяцев, чтобы увидеть прогресс и обновить приоритеты.

Это не экзамен, который нужно «сдать», а инструмент, который помогает не теряться в бесконечном «надо всё выучить».

---

## 32.5. Key Takeaways

- **Junior** — уверенная база (HTML/CSS/JS, React‑основы, DevTools, Git) и способность быстро учиться под присмотром.
- **Middle** — глубокое понимание механики JS/React, типизации, архитектуры и производительности, способность вести фичи «под ключ».
- Ошибки в Event Loop, `useEffect`, производительности и типизации — самые частые причины отказа на Middle‑уровне.
- Чек-лист — это повод для честного разговора с собой и основа для реального плана развития, а не «страшный стандарт».
- Практика на реальных проектах и умение объяснять свои решения важнее, чем формальное покрытие всех пунктов.

---

На этом учебный путь в рамках книги заканчивается, но профессиональное развитие — нет: дальше самое важное — применять всё это на реальных проектах, регулярно пересматривать свои подходы и возвращаться к фундаменту, когда возникают новые вопросы.
