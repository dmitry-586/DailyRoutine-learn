# Глава 8. Препроцессоры и инструменты CSS

Эта глава посвящена инструментам, которые превращают CSS из «ручного ремесла» в управляемую инженерную систему.

CSS — мощный язык, но у него долгие годы не было важных возможностей: переменных, вложенности, миксинов, модульности. Разработчики решали это с помощью препроцессоров вроде SASS/SCSS и инструментов вроде PostCSS.

Сегодня эти технологии по-прежнему применяются — но их роль изменилась.

На реальных проектах «чистый CSS» почти никогда не используется в одиночку — вокруг него всегда есть экосистема.

На собеседованиях эту тему используют, чтобы проверить:

- работали ли вы с продакшн-сборками
- понимаете ли разницу между compile-time и runtime
- знаете ли, как оптимизировать CSS под продакшн

Эта глава объясняет:

1. Зачем нужны препроцессоры (если есть современные CSS-фичи)
2. Что такое SCSS и чем он отличается от SASS
3. Что делает PostCSS и почему без него не обходится продакшен
4. Как уменьшать CSS и ускорять загрузку сайта

---

## 7.1. Препроцессоры (SASS/SCSS): зачем они нужны

Препроцессор — это надстройка над CSS, которая:

- добавляет новые синтаксические возможности
- компилирует удобный код в обычный CSS
- помогает поддерживать большие проекты

В отличие от CSS-in-JS, SASS не внедряет стили во время работы приложения. Он работает до сборки: SCSS → CSS.

SASS — самый популярный CSS-препроцессор. SCSS — его синтаксис, максимально близкий к CSS.

### SCSS vs SASS: в чём разница

Есть два синтаксиса:

**SASS — старый, без фигурных скобок:**

```sass
.card
  padding: 10px
  border: 1px solid #ccc
```

**SCSS — современный, с фигурными скобками:**

```scss
.card {
  padding: 10px;
  border: 1px solid #ccc;
}
```

SCSS полностью совместим с CSS. Поэтому он стал де-факто стандартом.

---

## 7.2. Основные возможности SCSS

### Переменные

До появления CSS Variables они выглядели так:

```scss
$primary: #3b82f6;
$spacing: 16px;

button {
  padding: $spacing;
  background: $primary;
}
```

Важно понимать: SCSS-переменные существуют только на этапе сборки. В runtime они исчезают.

Сегодня SCSS-переменные уступают кастомным, но используются в неподвижных константах:

- брейкпоинты
- размеры сетки
- длительности анимаций

### Вложенность

```scss
.card {
  padding: 20px;

  &__title {
    font-size: 20px;
  }
}
```

Но важно помнить: лишняя вложенность → плохой CSS.

На собеседованиях это частый вопрос: «Почему глубокая вложенность SCSS — анти-паттерн?»

Потому что она порождает длинные и тяжёлые селекторы.

### Миксины

Миксины похожи на функции.

```scss
@mixin center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.box {
  @include center;
}
```

Миксины отлично подходят для:

- повторяющихся паттернов
- медиавыражений
- многострочных конструкций

⚠️ Миксины дублируют код. Использовать осторожно.

### Наследование (@extend)

Осторожно: часто переносит лишние стили.

```scss
.button {
  padding: 10px;
}

.buy-button {
  @extend .button;
  background: green;
}
```

### Функции SCSS

```scss
@function pxToRem($px) {
  @return $px / 16 * 1rem;
}
```

Это мощный инструмент, но помни: современный CSS уже имеет calc(), clamp(), min(), max(), и часть задач можно решать без препроцессоров.

### @use и @forward

Современный подход вместо @import:

```scss
@use 'colors';
@use 'mixins';
```

Изолирует пространство имён и предотвращает конфликты.

⚠️ @import считается плохой практикой из-за глобальной области видимости.

---

## 7.3. Less

Less похож на SCSS, но:

- менее строг
- чаще используется в старых проектах
- меньше возможностей

**Пример:**

```less
@primary: blue;

.button {
  color: @primary;
}
```

На новых проектах Less встречается реже.

---

## 7.4. PostCSS: сердце современного CSS-пайплайна

Если SASS — это язык, то PostCSS — платформа плагинов.

Он может:

- добавлять автопрефиксы
- минифицировать
- преобразовывать современные синтаксические возможности
- анализировать контент
- удалять неиспользуемый CSS

Сам по себе PostCSS ничего не делает — всё решают плагины.

Он не заменяет SASS. Они работают вместе в больших проектах.

### Самые важные плагины PostCSS

**Autoprefixer — стандарт де-факто**

Он добавляет вендорные префиксы:

```css
display: flex;
```

превращается в:

```css
display: -webkit-box;
display: -ms-flexbox;
display: flex;
```

**Вопрос на собеседовании:**

Почему нельзя писать префиксы вручную?

**Ответ:**

- спецификация меняется
- браузеры обновляются
- огромное количество нюансов

**postcss-preset-env**

Позволяет использовать современный CSS прямо сейчас. Конвертирует в более старый синтаксис, если нужно.

**PostCSS Import**

Позволяет использовать @import без блокировки выполнения.

**cssnano**

Минификация CSS для продакшна. Удаляет пробелы, комментарии, сокращает объявления.

**PurgeCSS / LightningCSS / UnCSS — удаление неиспользуемых стилей**

Именно они позволяют уменьшить стили на 70–90%.

Работает так:

- анализирует HTML/JSX
- ищет, какие классы реально используются
- удаляет всё остальное

⚠️ Динамические классы нужно явно указывать.

---

## 7.5. Оптимизация CSS в реальных проектах

Оптимизация — это не «прикол», а обязательный этап производительности.

### Critical CSS

Это CSS, который нужен для рендера первого экрана. Встраивается прямо в HTML:

```html
<style>
  header {
    display: flex;
  }
</style>
```

Остальной CSS загружается асинхронно.

**Идея:**

- стили для первого экрана — inline
- остальное — загружается позже

**Пример:**

```html
<style>
  /* critical css */
</style>
<link rel="preload" href="styles.css" as="style" />
```

### Минификация + объединение файлов

Современные бандлеры делают это автоматически, но понимать принцип важно:

- меньше веса
- меньше HTTP-запросов
- быстрее загрузка

**Минификация и сжатие:**

- удаление пробелов
- сокращение имён
- gzip / brotli

### Splitting (разделение CSS по страницам)

Особенно важно для SPA:

- компонент открывается — подгружается его CSS
- не нужно грузить 300 KB стилей сразу

### Avoid large DOM & heavy selectors

Современные браузеры быстрые, но тяжелые селекторы всё ещё вредят:

**Плохо:**

`.app .container ul li a span {}`

**Хорошо:**

`.nav-link {}`

### Используйте современные единицы

**Вместо:**

- px → rem, em
- фиксированные размеры → auto/minmax
- жесткие брейкпоинты → clamp

---

## 7.6. Где препроцессоры всё ещё нужны

Несмотря на развитие CSS, SASS остаётся полезным:

- дизайн-системы
- большие UI-библиотеки
- проекты со старым кодом
- крупные корпоративные решения

SCSS остаётся удобным из-за:

- миксинов
- функций
- вложенности
- структурирования

Но тренд рынка идёт в сторону:

- CSS Modules
- CSS Variables
- PostCSS
- design tokens

### Compile-time vs Runtime — важный вопрос

**Compile-time инструменты:**

- SCSS
- PostCSS

**Runtime инструменты:**

- CSS variables
- CSS-in-JS

На собеседованиях часто спрашивают разницу.

---

## Вопросы на собеседовании

### 1. Чем SCSS отличается от CSS-переменных?

CSS Variables — динамические, runtime, участвуют в каскаде. SCSS переменные — статические, compile-time, подставляются при сборке. Они решают разные задачи: SASS — архитектура на уровне сборки, CSS Variables — темизация и runtime управление.

### 2. Почему @import считается плохой практикой?

Глобальная область видимости, конфликты имён, проблемы с порядком загрузки.

### 3. В чём разница между @use и @import?

@use изолирует пространство имён и предотвращает конфликты. @import — устаревший подход.

### 4. Что делает PostCSS?

Платформа для трансформации CSS через плагины: автопрефиксы, минификация, удаление неиспользуемого кода.

### 5. Зачем нужен Autoprefixer?

Добавляет вендорные префиксы автоматически. Нельзя писать вручную из-за постоянных изменений спецификации.

### 6. Как работает PurgeCSS?

Анализирует HTML/JSX, находит используемые классы, удаляет неиспользуемые стили. Уменьшает CSS на 70–90%.

### 7. Что такое Critical CSS?

Минимальный CSS, который нужен для рендера above-the-fold контента. Встраивается inline в HTML.

### 8. Почему нельзя злоупотреблять миксинами?

Миксины дублируют код, увеличивают размер финального CSS.

### 9. Compile-time vs runtime — в чём разница?

Compile-time — обработка на этапе сборки (SCSS, PostCSS). Runtime — обработка во время выполнения (CSS Variables, CSS-in-JS).

---

## Key Takeaways

- SCSS остаётся полезным инструментом для архитектуры стилей
- PostCSS — универсальный процессор, обязательный в продакшене
- Autoprefixer и минификация — минимум для любого проекта
- PurgeCSS сильно уменьшает размер CSS
- Critical CSS ускоряет загрузку первого экрана
- Современная экосистема делает стили предсказуемыми и модульными
- Compile-time инструменты работают до сборки, runtime — во время выполнения
- Тренд идёт в сторону CSS Modules и CSS Variables вместо препроцессоров

---

В следующей части мы переключимся с языка стилей на язык логики — JavaScript: разберём фундаментальные понятия, без которых сложно уверенно говорить о замыканиях, асинхронности, архитектуре и, в итоге, о сложных фронтенд‑приложениях.
