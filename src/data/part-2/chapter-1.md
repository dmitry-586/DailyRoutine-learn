# Глава 6. Основы CSS

Эта глава формирует базу для профессиональной работы с вёрсткой. Даже Senior-фронтендеры регулярно попадают в ловушки из-за неправильного понимания потоков, специфичности и механики layout.

Если HTML — это скелет, то CSS — это материалы и геометрия: размеры, цвета, сетки, отступы, размещение элементов. Проблема новичков и даже мидлов в том, что CSS кажется магией: почему-то блок прыгает, почему-то не центрируется, почему-то Grid не работает так, как в примере.

На самом деле CSS — это строгая система, и если понять её фундамент, то верстка становится предсказуемой, как математика.

CSS — это язык вычисления стилей, а не просто набор свойств. Браузер постоянно вычисляет:

- где находится элемент
- сколько он занимает
- какие правила к нему применяются
- как он реагирует на изменения структуры

Чтобы писать оптимальный и предсказуемый код, нужно глубоко понимать эти механизмы.

---

## 5.1. Бокс-модель и поток документа

Каждый элемент в CSS — это прямоугольная коробка (box). Абсолютно каждый: div, span, button, img, даже текстовые строки.

**Состав box-модели:**

margin → border → padding → content

**Итого размер элемента:**

`width + padding + border + margin`

**Почему это важно?**

Потому что 80% «непонятных» багов верстки происходят из-за того, что разработчик не учитывает, что padding/border расширяют коробку.

### box-sizing

**По умолчанию:**

`box-sizing: content-box;`

Т.е. width задаёт только content, padding и border прибавляются.

**Современная практика:**

```css
* {
  box-sizing: border-box;
}
```

Это делает расчёты проще и верстку предсказуемей. Поэтому почти все проекты начинают с этого.

border-box: width включает padding и border.

`width = content + padding + border`

Это уменьшает количество сюрпризов.

---

## 5.2. Специфичность, наследование, каскад

CSS = Cascading Style Sheets.

**Каскад — набор правил:**

Если несколько селекторов претендуют на один элемент, применяется тот, что:

1. выигрывает по специфичности
2. если равны — тот, что ниже по порядку (позже в файле)
3. если есть !important — оно побеждает всё, но использовать его нужно осторожно

### Специфичность

**inline-style** — вес 1000

**#id** — вес 100

**.class, [attr], pseudo-class** — вес 10

**tag, pseudo-element** — вес 1

**Пример:**

`#header .menu li a { ... }`

Вес = 100 + 10 + 1 + 1 = 112

### Наследование

**Некоторые свойства наследуются автоматически:**

- font-size
- color
- line-height

**Другие никогда не наследуются:**

- padding
- margin
- border
- background

### Приоритеты

1. user-agent stylesheet (браузер)
2. ваш CSS
3. inline-стили
4. !important

---

## 5.3. Display: как элемент ведёт себя по умолчанию

CSS не только про внешность. Это язык для управления поведением элементов.

### `display: block`

**Характеристики:**

- занимает всю строку
- начинается с новой строки
- можно задавать width/height
- можно задавать margin-top / bottom

Примеры: div, section, p.

### `display: inline`

**Характеристики:**

- не начинает новую строку
- игнорирует width/height
- реагирует только на горизонтальные margin/padding

Примеры: span, a.

### inline-block

Середина между inline и block:

- стоит в строке
- можно задавать размеры

### `display: none`

Полностью исключает элемент из рендера, layout и событий. С точки зрения браузера такой элемент не существует.

---

## 5.4. Позиционирование

Понимание позиционирования — ключ к грамотной вёрстке. Позиционирование — не магия, а строгая иерархия контекстов.

**Типы:**

1. **static** — по умолчанию. Элемент следует нормальному потоку документа.
2. **relative** — смещение относительно собственных координат. Сохраняет место в потоке, но позволяет смещать элемент относительно самого себя.
3. **absolute** — относительно ближайшего positioned ancestor. Удаляется из потока. Контекст позиционирования ищется вверх по дереву: первый элемент с position отличным от static. Если такого нет → relative к viewport.
4. **fixed** — относительно viewport. Фиксируется относительно viewport. Не зависит от прокрутки. Используется для шапок, кнопок «вверх», модальных оверлеев. Недостаток: внутри скролл-контейнеров fixed игнорирует родительский scroll.
5. **sticky** — гибрид relative и fixed. Одна из самых полезных фишек современного CSS. Элемент ведёт себя так: пока внутри родителя → relative, когда достигает указанной позиции → fixed.

**Пример:**

```css
header {
  position: sticky;
  top: 0;
}
```

---

## 5.5. Flexbox: полное руководство

Flexbox — идеальный инструмент для одномерных раскладок. Это система, ориентированная на одну ось: горизонтальную или вертикальную. Его задача — распределять пространство.

**Основные свойства контейнера:**

```css
display: flex;
flex-direction: row | column | row-reverse | column-reverse;
justify-content: center | space-between | space-around | space-evenly |
  flex-start | flex-end;
align-items: center | flex-start | flex-end | stretch;
flex-wrap: wrap;
```

**Основные свойства элемента:**

- flex-grow: 0 | 1 | … — делит свободное пространство
- flex-shrink: 1 | 0 — определяет, как элемент сжимается
- flex-basis: auto | ... — базовая ширина (или высота в column-направлении)
- align-self: … — переопределяет align-items для конкретного элемента
- order: … — порядок отображения

**Как это работает?**

Flexbox сначала распределяет пространство по одной оси (основной), затем по другой (вторичной).

**Примеры:**

**Равномерное распределение:**

```css
.container {
  display: flex;
  justify-content: space-between;
}
```

**Центрирование:**

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

**Когда использовать Flexbox:**

- меню и навигация
- header/footer
- горизонтальные списки
- простые карточки
- центровка

---

## 5.6. CSS Grid: современная раскладка

Grid — это двумерный инструмент: строки + колонки. Если Flex — линейка, то Grid — арочная система строительства.

**Пример базовой сетки:**

```css
.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 20px;
}
```

fr — это «фракция свободного пространства».

gap — современная замена margin'ам между элементами. Работает и в Flexbox!

### Выравнивание в Grid

Grid даёт больше возможностей:

- align-items
- justify-items
- place-items
- align-content
- justify-content

### Grid Areas:

```css
grid-template-areas:
  'header header'
  'sidebar main'
  'footer footer';
```

**Авторазмещение:**

`grid-auto-flow: dense;`

### Когда Flex, когда Grid?

**Один ряд/колонка** → Flexbox

**Две оси, сетка** → Grid

**Равномерное распределение** → Flex

**Макет страницы** → Grid

**Когда использовать Grid:**

- сложные массовые сетки
- страницы каталога
- галереи
- адаптивные макеты
- формы/панели/таблицы

Grid способен заменить Bootstrap/12-column system без фреймворков.

---

## 5.7. Адаптивная и отзывчивая вёрстка

Адаптивность — не только media queries. Это целый набор инструментов.

### Media queries

**Классический метод:**

```css
@media (max-width: 768px) {
  .sidebar {
    display: none;
  }
}
```

**Частые брейкпоинты:**

- 320 (мобильный минимум)
- 480
- 768 (tablet)
- 1024
- 1280
- 1440
- 1920

Но хороший адаптив строится от контента, а не от устройств.

### Mobile-first стратегия

Современная лучшая практика:

1. Пишем стили для мобильной версии
2. Добавляем более сложные стили для больших экранов через min-width

### Flexbox и Grid делают адаптив проще

**Flex-wrap:**

`flex-wrap: wrap;`

**Grid-автоматизация:**

`grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));`

Это мощнейший приём.

### Fluid typography и современные функции

**Например:**

`font-size: clamp(1rem, 2vw, 2rem);`

Это значит:

- меньше 1rem → не уменьшать
- больше 2rem → не увеличивать
- в пределах — масштабировать от ширины экрана

### Responsive images

Используем srcset:

```html
<img
  src="image-640.jpg"
  srcset="image-640.jpg 640w, image-1280.jpg 1280w"
  sizes="(max-width: 600px) 100vw, 50vw"
/>
```

Браузер сам выбирает правильное изображение.

### Единицы измерения для адаптивности

- % — от родителя
- vw, vh — доли viewport
- rem, em — относительные единицы
- fr — единицы Grid

### Практические примеры

**Пример 1: центрирование блока**

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
```

**Пример 2: адаптивная карточка**

```css
.card {
  padding: 20px;
  background: #fff;
}

@media (min-width: 768px) {
  .card {
    display: grid;
    grid-template-columns: 1fr 2fr;
  }
}
```

**Пример 3: sticky header**

```css
header {
  position: sticky;
  top: 0;
  background: white;
}
```

---

## 5.8. Частые ошибки при работе с CSS

1. Перекрывающиеся margin collapsing
2. Использование float вместо flex/grid
3. Избыточные вложенности (.app .page .wrapper .content…)
4. pixel-perfect попытки (которые ломают адаптивность)
5. Тяжёлые селекторы (ul li a span {})
6. width: 100vw (вызывает горизонтальный скролл)
7. Фиксированные высоты (ломают responsive)

---

## 5.9. Самопроверка

Если после этой главы ты можешь:

- объяснить бокс‑модель и эффект `box-sizing: border-box` без заглядывания в шпаргалку;
- накидать разметку и стили для простого адаптивного layout'а (хедер, контент, сайдбар, футер) только с помощью Flexbox/Grid;
- уверенно выбрать между Flex и Grid под конкретную задачу и аргументировать выбор;
- рассказать, как бы ты починил «прыгающий» интерфейс (layout shift) на мобильных;
- показать на реальном примере, где у тебя в проекте `clamp`, `minmax` или `auto-fit/auto-fill` экономят медиа‑запросы,

то фундамент по современному CSS у тебя уже на уровне уверенного Middle.

---

## Вопросы на собеседовании

### 1. Объясните бокс-модель

content + padding + border + margin. box-sizing изменяет расчёт.

### 2. Что делает box-sizing: border-box?

width включает padding и border, что делает расчёты проще и верстку предсказуемей.

### 3. В чём разница между static / relative / absolute / fixed / sticky?

- static — нормальный поток
- relative — смещение относительно себя, место в потоке сохраняется
- absolute — относительно positioned ancestor, удаляется из потока
- fixed — относительно viewport, не зависит от прокрутки
- sticky — гибрид relative и fixed, прилипает при достижении порога

### 4. Как работает Flexbox?

Одномерная система распределения пространства. Сначала по главной оси, затем по поперечной.

### 5. Как работает Grid?

Двумерная система: строки + колонки. Позволяет создавать сложные макеты.

### 6. В чём разница justify-content и align-items?

- justify-content — выравнивание по главной оси
- align-items — выравнивание по поперечной оси

### 7. Чем Grid отличается от Flexbox?

Flex — одномерная система (одна ось). Grid — двухмерная (строки + колонки).

### 8. Что такое media queries?

Правила CSS, применяемые в зависимости от характеристик устройства (ширина, высота и т.д.).

### 9. Что такое mobile-first?

Стратегия разработки, при которой сначала пишутся стили для мобильных устройств, затем добавляются стили для больших экранов.

### 10. Как работает специфичность?

Система весов селекторов: inline-style (1000) > #id (100) > .class (10) > tag (1).

### 11. Когда grid-template-columns: 1fr 1fr 1fr имеет смысл?

Когда нужно равномерно поделить пространство между тремя колонками.

### 12. Что такое clamp()?

Функция CSS для задания адаптивных, но ограниченных значений.

### 13. Как сделать карточки, которые автоматически перестраиваются в зависимости от ширины контейнера?

Grid с auto-fit/auto-fill:

`grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));`

---

## Key Takeaways

- CSS — строгая система, а не хаос
- Бокс-модель и box-sizing — основа стабильной верстки
- Display определяет поведение, а не внешний вид элемента
- Позиционирование — это слои логики, а не хаотичные абсолюты
- Flexbox идеален для одномерных макетов, Grid — для двухмерных
- Адаптивность — это комбинация: брейкпоинты + fluid + современные единицы
- Grid и Flex делают фреймворки вроде Bootstrap практически ненужными
- Специфичность определяет, какое правило применится при конфликте
- Mobile-first — современная лучшая практика адаптивной вёрстки

---

В следующей главе мы поднимемся на уровень выше и посмотрим, как вокруг базового CSS выстраивается современная экосистема: переменные, каскадные слои, CSS‑модули, CSS‑in‑JS и методологии, которые позволяют держать под контролем стили в больших продакшн‑проектах.
