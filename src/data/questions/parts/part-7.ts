import type { QuizQuestion } from '@/shared/types/quiz.types'

/**
 * Вопросы по Части VII. Архитектура и проектирование
 */
export const part7Questions: QuizQuestion[] = [
  {
    id: 'q-7-1',
    type: 'single',
    question:
      'В приложении нужен один глобальный экземпляр сервиса (например, конфиг или логгер), и вы хотите гарантировать, что второй экземпляр создать нельзя. Какой паттерн описывает эту идею?',
    answers: [
      {
        id: 'a-7-1-4',
        text: 'Паттерн для оптимизации производительности',
        isCorrect: false,
      },
      {
        id: 'a-7-1-2',
        text: 'Паттерн для создания множества экземпляров одного класса',
        isCorrect: false,
      },
      {
        id: 'a-7-1-1',
        text: 'Паттерн, который гарантирует существование только одного экземпляра класса',
        isCorrect: true,
      },
      {
        id: 'a-7-1-3',
        text: 'Паттерн для наследования классов',
        isCorrect: false,
      },
    ],
    explanation:
      'Singleton — это паттерн, который гарантирует существование только одного экземпляра класса и предоставляет глобальную точку доступа к нему.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-2',
    type: 'single',
    question:
      'Есть объект-источник событий, и множество подписчиков должны автоматически получать уведомления при изменении состояния. Как называется этот паттерн проектирования?',
    answers: [
      {
        id: 'a-7-2-4',
        text: 'Паттерн для оптимизации рендеринга',
        isCorrect: false,
      },
      {
        id: 'a-7-2-3',
        text: 'Паттерн для создания наблюдаемых объектов',
        isCorrect: false,
      },
      {
        id: 'a-7-2-1',
        text: 'Паттерн, при котором объект уведомляет подписчиков об изменениях своего состояния',
        isCorrect: true,
      },
      {
        id: 'a-7-2-2',
        text: 'Паттерн для наблюдения за производительностью приложения',
        isCorrect: false,
      },
    ],
    explanation:
      'Observer — это паттерн, при котором объект (Subject) уведомляет список наблюдателей (Observers) об изменениях. React использует похожий паттерн для обновления компонентов.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-3',
    type: 'multiple',
    question:
      'Вы обсуждаете, как структурировать фронтенд-проект и какие “школы” архитектуры вообще встречаются. Какие подходы действительно применяются во фронтенде?',
    answers: [
      {
        id: 'a-7-3-1',
        text: 'MVC (Model-View-Controller)',
        isCorrect: true,
      },
      {
        id: 'a-7-3-4',
        text: 'Clean Architecture',
        isCorrect: true,
      },
      {
        id: 'a-7-3-5',
        text: 'Только один подход для всех проектов',
        isCorrect: false,
      },
      {
        id: 'a-7-3-2',
        text: 'MVVM (Model-View-ViewModel)',
        isCorrect: true,
      },
      {
        id: 'a-7-3-3',
        text: 'Feature-Sliced Design',
        isCorrect: true,
      },
    ],
    explanation:
      'Во фронтенде используются различные архитектурные подходы: MVC, MVVM, FSD, Clean Architecture. Выбор зависит от размера проекта и требований.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-4',
    type: 'single',
    question:
      'В зависимости от входных данных нужно создавать разные объекты, но не хочется распылять `new` и условия по коду. Как называется паттерн, который скрывает детали создания и возвращает нужную реализацию?',
    answers: [
      {
        id: 'a-7-4-2',
        text: 'Паттерн для работы с базами данных',
        isCorrect: false,
      },
      {
        id: 'a-7-4-3',
        text: 'Паттерн для оптимизации производительности',
        isCorrect: false,
      },
      {
        id: 'a-7-4-1',
        text: 'Паттерн, который создаёт объекты без указания конкретного класса',
        isCorrect: true,
      },
      {
        id: 'a-7-4-4',
        text: 'Паттерн для работы с API',
        isCorrect: false,
      },
    ],
    explanation:
      'Factory — паттерн создания объектов через фабричную функцию/класс, скрывающую детали создания. Полезен когда нужно создавать объекты разных типов в зависимости от условий.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-5',
    type: 'single',
    question:
      'У вас есть несколько взаимозаменяемых алгоритмов (например, расчёт скидки), и вы хотите подменять их без `if/else` по всему коду. Как называется паттерн “семейство алгоритмов”?',
    answers: [
      {
        id: 'a-7-5-2',
        text: 'Паттерн для работы с состояниями',
        isCorrect: false,
      },
      {
        id: 'a-7-5-4',
        text: 'Паттерн для работы с формами',
        isCorrect: false,
      },
      {
        id: 'a-7-5-1',
        text: 'Паттерн, который определяет семейство алгоритмов и делает их взаимозаменяемыми',
        isCorrect: true,
      },
      {
        id: 'a-7-5-3',
        text: 'Паттерн для оптимизации',
        isCorrect: false,
      },
    ],
    explanation:
      'Strategy позволяет выбирать алгоритм во время выполнения. Пример: разные стратегии валидации, оплаты, сортировки. Полезен когда есть несколько способов выполнить задачу.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-6',
    type: 'single',
    question:
      'Нужно инкапсулировать детали реализации и открыть наружу только публичный API, спрятав приватные переменные. Какой паттерн в JavaScript исторически использовали для этого (на замыканиях/IIFE)?',
    answers: [
      {
        id: 'a-7-6-2',
        text: 'Паттерн для работы с модулями Node.js',
        isCorrect: false,
      },
      {
        id: 'a-7-6-4',
        text: 'Паттерн для работы с классами',
        isCorrect: false,
      },
      {
        id: 'a-7-6-1',
        text: 'Паттерн для инкапсуляции кода и создания приватной области видимости',
        isCorrect: true,
      },
      {
        id: 'a-7-6-3',
        text: 'Паттерн для оптимизации',
        isCorrect: false,
      },
    ],
    explanation:
      'Module pattern использует замыкания для создания приватной области видимости и публичного API. Пример: IIFE (Immediately Invoked Function Expression). Основа для ES modules.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-7',
    type: 'single',
    question:
      'Что чаще всего является практическим нарушением принципа Single Responsibility в React-коде?',
    answers: [
      {
        id: 'a-7-7-1',
        text: 'Компонент одновременно управляет состоянием, ходит в API, форматирует данные и отвечает за разметку',
        isCorrect: true,
      },
      {
        id: 'a-7-7-4',
        text: 'Компонент вынесен в отдельную папку feature и имеет собственные тесты',
        isCorrect: false,
      },
      {
        id: 'a-7-7-3',
        text: 'Компонент принимает много пропсов, но не содержит бизнес-логики',
        isCorrect: false,
      },
      {
        id: 'a-7-7-2',
        text: 'Компонент использует несколько хуков (useState, useMemo, useEffect)',
        isCorrect: false,
      },
    ],
    explanation:
      'SRP нарушается не количеством хуков, а количеством «причин для изменения». Когда UI, запросы, маппинг DTO→VM и бизнес-правила смешаны в одном компоненте, менять его приходится по любому поводу.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-8',
    type: 'multiple',
    question:
      'Какие решения обычно помогают соблюдать Dependency Inversion во фронтенде?',
    answers: [
      {
        id: 'a-7-8-1',
        text: 'Зависеть от контрактов (интерфейсов/типов) и подставлять реализации через адаптеры',
        isCorrect: true,
      },
      {
        id: 'a-7-8-4',
        text: 'Хранить все зависимости в одном глобальном синглтоне',
        isCorrect: false,
      },
      {
        id: 'a-7-8-3',
        text: 'Писать бизнес-правила (use cases) так, чтобы они не знали о React и маршрутизации',
        isCorrect: true,
      },
      {
        id: 'a-7-8-2',
        text: 'Инкапсулировать работу с сетью в слой api/lib и не импортировать axios/fetch напрямую в UI',
        isCorrect: true,
      },
    ],
    explanation:
      'DIP — про зависимость высокоуровневых модулей от абстракций. На практике это означает: UI/use cases не знают о конкретном HTTP-клиенте и инфраструктуре, а детали подключаются через адаптеры.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-9',
    type: 'single',
    question:
      'Какой из примеров лучше всего иллюстрирует нарушение Liskov Substitution (LSP) на уровне API/типов?',
    answers: [
      {
        id: 'a-7-9-3',
        text: 'Подтип переопределяет метод, сохраняя предусловия и постусловия (контракт не меняется, код с базовым типом продолжает работать)',
        isCorrect: false,
      },
      {
        id: 'a-7-9-2',
        text: 'Подтип добавляет новые методы, не меняя поведение унаследованных: интерфейс расширился, но замена базового типа остаётся корректной',
        isCorrect: false,
      },
      {
        id: 'a-7-9-4',
        text: 'Базовый тип использует generics, а подтип — нет: из‑за этого типы “не сходятся”, и это считается нарушением LSP',
        isCorrect: false,
      },
      {
        id: 'a-7-9-1',
        text: 'Подтип «сужает контракт»: метод базового типа гарантирует результат, а подтип начинает иногда бросать ошибку вместо результата',
        isCorrect: true,
      },
    ],
    explanation:
      'LSP: где ожидается базовый тип, должен корректно работать подтип. Нарушение — когда подтип усиливает предусловия или ослабляет гарантии (контракт) и ломает код, который полагается на поведение базового типа.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-10',
    type: 'single',
    question:
      'Почему Singleton во фронтенде часто считают проблемным решением (особенно в тестах)?',
    answers: [
      {
        id: 'a-7-10-2',
        text: 'Singleton всегда улучшает тестируемость и делает зависимости максимально явными, поэтому его стоит использовать “по умолчанию” в приложении',
        isCorrect: false,
      },
      {
        id: 'a-7-10-3',
        text: 'Singleton гарантирует отсутствие побочных эффектов: глобальный объект “всегда один”, значит его проще контролировать и изолировать',
        isCorrect: false,
      },
      {
        id: 'a-7-10-4',
        text: 'Он не работает в браузере из‑за изоляции вкладок: singleton “не сможет быть одним” для всех пользователей одновременно',
        isCorrect: false,
      },
      {
        id: 'a-7-10-1',
        text: 'Он создаёт глобальное скрытое состояние, усложняет изоляцию тестов и подмену зависимостей (моки/DI), повышая связанность модулей',
        isCorrect: true,
      },
    ],
    explanation:
      'Главный минус Singleton — не «паттерн плохой», а то, что глобальное состояние инициализируется один раз и становится неявной зависимостью. Это ведёт к связанности, сложности моков и проблемам с повторяемостью тестов.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-11',
    type: 'single',
    question:
      'Чем Observer чаще всего отличается от Pub/Sub (Publish–Subscribe) на практике?',
    answers: [
      {
        id: 'a-7-11-1',
        text: 'В Observer наблюдатели подписываются на конкретный субъект, а в Pub/Sub издатель и подписчики обычно развязаны через брокер/шину событий',
        isCorrect: true,
      },
      {
        id: 'a-7-11-4',
        text: 'Observer нельзя реализовать без классов, а Pub/Sub — без функций: это принципиальное отличие их реализаций в JavaScript',
        isCorrect: false,
      },
      {
        id: 'a-7-11-3',
        text: 'Observer и Pub/Sub — одно и то же: различие только в терминологии в разных книгах, на практике архитектура одинаковая',
        isCorrect: false,
      },
      {
        id: 'a-7-11-2',
        text: 'Observer всегда асинхронный, а Pub/Sub всегда синхронный: их главное отличие именно в “таймингах” доставки событий',
        isCorrect: false,
      },
    ],
    explanation:
      'Observer обычно подразумевает прямую связь «subject → observers». Pub/Sub вводит посредника (event bus), что помогает развязать модули, но усложняет трассировку потока и дебаг.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-12',
    type: 'single',
    question:
      'У вас есть сложная SDK-библиотека оплаты с десятками методов. Вы хотите дать команде простой API из 3–4 функций. Какой паттерн наиболее уместен?',
    answers: [
      {
        id: 'a-7-12-1',
        text: 'Facade',
        isCorrect: true,
      },
      {
        id: 'a-7-12-2',
        text: 'Adapter',
        isCorrect: false,
      },
      {
        id: 'a-7-12-3',
        text: 'Strategy',
        isCorrect: false,
      },
      {
        id: 'a-7-12-4',
        text: 'Observer',
        isCorrect: false,
      },
    ],
    explanation:
      'Facade скрывает внутреннюю сложность и предоставляет удобный «фасад» над подсистемой. Adapter больше про согласование несовместимых интерфейсов, а не про упрощение богатого API.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-13',
    type: 'single',
    question:
      'Какая формулировка точнее всего описывает разницу Strategy и State?',
    answers: [
      {
        id: 'a-7-13-3',
        text: 'Strategy нужен для асинхронности (промисы/колбэки), а State — для синхронного кода, поэтому в UI обычно выбирают только Strategy',
        isCorrect: false,
      },
      {
        id: 'a-7-13-2',
        text: 'Strategy работает только с функциями, а State возможен только в OOP через классы и не применим в функциональном стиле',
        isCorrect: false,
      },
      {
        id: 'a-7-13-1',
        text: 'Strategy выбирает алгоритм “извне”, а State меняет поведение в зависимости от внутреннего состояния контекста (и может само переключаться)',
        isCorrect: true,
      },
      {
        id: 'a-7-13-4',
        text: 'State — частный случай Singleton, потому что состояние должно быть “единым” и существовать в одном экземпляре на всё приложение',
        isCorrect: false,
      },
    ],
    explanation:
      'Оба паттерна инкапсулируют поведение, но мотив разный: Strategy — «какой алгоритм применить», State — «как контекст себя ведёт в текущем состоянии» (и состояния могут переключаться).',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-14',
    type: 'multiple',
    question:
      'Вы рассматриваете `new Proxy()` и хотите понять, где он реально полезен. Какие задачи во фронтенде часто решают через Proxy?',
    answers: [
      {
        id: 'a-7-14-1',
        text: 'Ленивая инициализация (lazy) и отложенная загрузка зависимостей',
        isCorrect: true,
      },
      {
        id: 'a-7-14-3',
        text: 'Валидация и нормализация входных данных перед записью',
        isCorrect: true,
      },
      {
        id: 'a-7-14-4',
        text: 'Proxy автоматически ускоряет рендер UI, потому что оптимизирует доступ к свойствам на уровне движка',
        isCorrect: false,
      },
      {
        id: 'a-7-14-2',
        text: 'Логирование/трейсинг доступа к данным и методов',
        isCorrect: true,
      },
    ],
    explanation:
      'Proxy — контроль доступа к объекту. В JS `new Proxy()` часто используют для логирования, валидации, мемоизации/кэширования, lazy-инициализации и разных метапрограммных трюков.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-15',
    type: 'multiple',
    question:
      'Какие признаки чаще всего указывают на архитектурный анти-паттерн “God component”?',
    answers: [
      {
        id: 'a-7-15-1',
        text: 'Компонент содержит много несвязанных обязанностей: данные, бизнес-правила, навигацию, UI и сайд-эффекты',
        isCorrect: true,
      },
      {
        id: 'a-7-15-2',
        text: 'Компонент трудно тестировать изолированно без большого количества моков',
        isCorrect: true,
      },
      {
        id: 'a-7-15-3',
        text: 'Любое небольшое изменение требований приводит к правкам в нескольких местах внутри одного файла',
        isCorrect: true,
      },
      {
        id: 'a-7-15-4',
        text: 'Компонент использует Tailwind и utility-классы',
        isCorrect: false,
      },
    ],
    explanation:
      'God component — это про концентрацию ответственности и связанность, а не про технологию стилей. Симптомы: сложность тестирования, низкая переиспользуемость, высокий “blast radius” изменений.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-16',
    type: 'single',
    question:
      'Какое утверждение точнее всего про MVC/MVP/MVVM в контексте современного React?',
    answers: [
      {
        id: 'a-7-16-3',
        text: 'MVC/MVP/MVVM неприменимы во фронтенде: это паттерны “чисто для бэкенда”, где нет состояния UI и событий браузера',
        isCorrect: false,
      },
      {
        id: 'a-7-16-4',
        text: 'Если в проекте много useEffect, это автоматически означает MVC, а если эффектов мало — значит MVVM (это главный “маркер” архитектуры)',
        isCorrect: false,
      },
      {
        id: 'a-7-16-1',
        text: 'React сам по себе не является полной архитектурой, но часто используют идеи MVVM: “View” + слой состояния/логики (hooks/store) как “ViewModel”',
        isCorrect: true,
      },
      {
        id: 'a-7-16-2',
        text: 'React — строгая реализация MVC: компоненты — это Controller, JSX — Model, а браузер автоматически выступает View без дополнительных слоёв',
        isCorrect: false,
      },
    ],
    explanation:
      'На интервью обычно ожидают, что вы отличаете фреймворк/библиотеку (React) от архитектуры. Реальные приложения строят поверх React: выделяют слой данных, бизнес-логики, презентационный слой и т.д.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-17',
    type: 'multiple',
    question:
      'Какие пункты чаще всего называют практическими преимуществами Redux/Flux-подхода в больших приложениях?',
    answers: [
      {
        id: 'a-7-17-1',
        text: 'Предсказуемый однонаправленный поток данных',
        isCorrect: true,
      },
      {
        id: 'a-7-17-3',
        text: 'Упрощение дебага (включая time-travel в devtools)',
        isCorrect: true,
      },
      {
        id: 'a-7-17-4',
        text: 'Автоматическая оптимизация SEO без SSR',
        isCorrect: false,
      },
      {
        id: 'a-7-17-2',
        text: 'Логируемость и воспроизводимость сценариев (например, через action log)',
        isCorrect: true,
      },
    ],
    explanation:
      'Плюсы Redux — это управляемость и дебажимость. Он не делает SEO “сам по себе”: SEO зависит от SSR/рендеринга, а не от менеджера состояния.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-18',
    type: 'single',
    question:
      'Как CQRS чаще всего проявляется во фронтенде (в терминах практик и слоёв)?',
    answers: [
      {
        id: 'a-7-18-2',
        text: 'CQRS — это правило “использовать только GET и POST”: чтение всегда GET, запись всегда POST, и это и есть вся суть',
        isCorrect: false,
      },
      {
        id: 'a-7-18-1',
        text: 'Разделение “команд” (изменяют состояние) и “запросов” (читают состояние): actions/mutations vs selectors/queries',
        isCorrect: true,
      },
      {
        id: 'a-7-18-4',
        text: 'Переход на микрофронтенды',
        isCorrect: false,
      },
      {
        id: 'a-7-18-3',
        text: 'Запрет на кеширование и мемоизацию',
        isCorrect: false,
      },
    ],
    explanation:
      'CQRS — это архитектурная идея разделения чтения и записи. Во фронтенде это хорошо видно в связке “команды” (reducers/mutations) и “запросы” (selectors/useQuery).',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-19',
    type: 'single',
    question: 'Когда микрофронтенды чаще всего оправданы (а не “модно”)?',
    answers: [
      {
        id: 'a-7-19-2',
        text: 'Когда нужно просто уменьшить bundle size и ускорить загрузку: микрофронтенды — это “продвинутое code splitting”',
        isCorrect: false,
      },
      {
        id: 'a-7-19-3',
        text: 'Когда проект маленький и один разработчик ведёт весь фронтенд: так проще “разделить” код на независимые части без процессов',
        isCorrect: false,
      },
      {
        id: 'a-7-19-4',
        text: 'Когда хочется использовать больше библиотек одновременно (React/Vue/Svelte) в одном продукте без согласования и общих стандартов',
        isCorrect: false,
      },
      {
        id: 'a-7-19-1',
        text: 'Когда несколько больших команд должны релизиться независимо и продукт можно разрезать на относительно автономные домены',
        isCorrect: true,
      },
    ],
    explanation:
      'Microfrontend решает организационные и релизные проблемы, но повышает сложность интеграции, DevOps, наблюдаемости и совместного UX. Ради “оптимизации бандла” обычно достаточно code splitting и правильных границ модулей.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-20',
    type: 'multiple',
    question:
      'Какие проблемы чаще всего появляются при Module Federation / микрофронтендах?',
    answers: [
      {
        id: 'a-7-20-3',
        text: 'Сложность сквозных тестов, мониторинга и дебага цепочек ошибок',
        isCorrect: true,
      },
      {
        id: 'a-7-20-4',
        text: 'Гарантированное упрощение CI/CD и деплоя',
        isCorrect: false,
      },
      {
        id: 'a-7-20-1',
        text: 'Дублирование зависимостей и увеличение общего веса загрузки',
        isCorrect: true,
      },
      {
        id: 'a-7-20-2',
        text: 'Сложности со “shared” версиями (React, router) и конфликтами runtime',
        isCorrect: true,
      },
    ],
    explanation:
      'Микрофронтенды почти всегда усложняют CI/CD и операционку. Главные боли — зависимости, совместимость runtime, сквозные UX-паттерны, ошибки интеграции и наблюдаемость.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-21',
    type: 'single',
    question:
      'Какой аргумент “против” Clean Architecture во фронтенде чаще всего является справедливым?',
    answers: [
      {
        id: 'a-7-21-1',
        text: 'Для небольших проектов оверхед слоёв и абстракций может перевесить пользу, усложняя разработку',
        isCorrect: true,
      },
      {
        id: 'a-7-21-2',
        text: 'Clean Architecture делает тестирование невозможным, потому что добавляет слишком много слоёв и всё становится “непроверяемым”',
        isCorrect: false,
      },
      {
        id: 'a-7-21-4',
        text: 'Clean Architecture применима только к бэкенду: во фронтенде она не работает в принципе',
        isCorrect: false,
      },
      {
        id: 'a-7-21-3',
        text: 'Clean Architecture полностью запрещает любые библиотеки: в проекте нельзя использовать никакие зависимости',
        isCorrect: false,
      },
    ],
    explanation:
      'Clean Architecture даёт тестируемость и независимость от UI, но “цена” — больше слоёв, интерфейсов и дисциплины. На маленьких кодовых базах это может быть избыточно.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-22',
    type: 'multiple',
    question:
      'Какие правила зависимостей обычно считают “здоровыми” в FSD/модульной архитектуре?',
    answers: [
      {
        id: 'a-7-22-1',
        text: 'shared не должен импортировать entities/features/pages (только наоборот)',
        isCorrect: true,
      },
      {
        id: 'a-7-22-2',
        text: 'entities не должны зависеть от features (features строятся поверх entities)',
        isCorrect: true,
      },
      {
        id: 'a-7-22-3',
        text: 'UI-слой должен зависеть от API напрямую, чтобы было меньше абстракций',
        isCorrect: false,
      },
      {
        id: 'a-7-22-4',
        text: 'Чем выше слой (pages/app), тем больше он может “собирать” и композиционировать нижние слои',
        isCorrect: true,
      },
    ],
    explanation:
      'Смысл FSD — контролируемые зависимости и локализация логики. Чем ниже слой, тем он “чище” и переиспользуемее; чем выше — тем больше композиции.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-23',
    type: 'single',
    question:
      'Какой шаг лучше всего соответствует принципам Evolutionary Design (эволюционного дизайна) в большом фронтенде?',
    answers: [
      {
        id: 'a-7-23-3',
        text: 'Полностью отказаться от рефакторинга, чтобы не трогать рабочий код: архитектура должна оставаться неизменной после релиза',
        isCorrect: false,
      },
      {
        id: 'a-7-23-2',
        text: 'Эволюционный дизайн означает “никогда ничего не менять после старта проекта”, чтобы минимизировать риск регрессий и миграций',
        isCorrect: false,
      },
      {
        id: 'a-7-23-1',
        text: 'Сначала ввести минимально нужные границы модулей и правила зависимостей, а затем эволюционно усиливать архитектуру по мере роста требований',
        isCorrect: true,
      },
      {
        id: 'a-7-23-4',
        text: 'Сразу внедрить микрофронтенды, чтобы “наверняка масштабировалось”: лучше перепроектировать заранее, чем менять постепенно',
        isCorrect: false,
      },
    ],
    explanation:
      'Эволюционный дизайн предполагает, что требования меняются. Практика: вводить небольшие, проверяемые улучшения (границы, соглашения, тесты), а не “застывать” в сверхпроектировании.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-24',
    type: 'single',
    question:
      'Какое правило лучше всего снижает связанность между фичами в feature-based архитектуре?',
    answers: [
      {
        id: 'a-7-24-4',
        text: 'Нужно хранить состояние всех фич в одном большом reducer без разделения, чтобы зависимости были “в одном месте” и не расползались',
        isCorrect: false,
      },
      {
        id: 'a-7-24-2',
        text: 'Все фичи должны хранить общие утилиты внутри себя, чтобы не зависеть от shared: дублирование кода лучше связанности',
        isCorrect: false,
      },
      {
        id: 'a-7-24-3',
        text: 'Нужно складывать компоненты всех фич в один общий каталог `components/common`, чтобы “переиспользование” было максимальным',
        isCorrect: false,
      },
      {
        id: 'a-7-24-1',
        text: 'Фичи не должны импортировать внутренности друг друга напрямую — взаимодействие через публичные API/контракты или через слой entities/shared',
        isCorrect: true,
      },
    ],
    explanation:
      'Ключ к масштабированию — не “общая папка”, а ясные границы и зависимости. Если фичи тянут друг друга напрямую, изменения становятся цепными и повышается стоимость поддержки.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
]
