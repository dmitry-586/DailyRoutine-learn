import type { QuizQuestion } from '@/shared/types/quiz.types'

/**
 * Вопросы по Части VII. Архитектура и проектирование
 */
export const part7Questions: QuizQuestion[] = [
  {
    id: 'q-7-1',
    type: 'single',
    question: 'Что такое паттерн Singleton?',
    answers: [
      {
        id: 'a-7-1-1',
        text: 'Паттерн, который гарантирует существование только одного экземпляра класса',
        isCorrect: true,
      },
      {
        id: 'a-7-1-2',
        text: 'Паттерн для создания множества экземпляров одного класса',
        isCorrect: false,
      },
      {
        id: 'a-7-1-3',
        text: 'Паттерн для наследования классов',
        isCorrect: false,
      },
      {
        id: 'a-7-1-4',
        text: 'Паттерн для оптимизации производительности',
        isCorrect: false,
      },
    ],
    explanation:
      'Singleton — это паттерн, который гарантирует существование только одного экземпляра класса и предоставляет глобальную точку доступа к нему.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-2',
    type: 'single',
    question: 'Что такое паттерн Observer?',
    answers: [
      {
        id: 'a-7-2-1',
        text: 'Паттерн, при котором объект уведомляет подписчиков об изменениях своего состояния',
        isCorrect: true,
      },
      {
        id: 'a-7-2-2',
        text: 'Паттерн для наблюдения за производительностью приложения',
        isCorrect: false,
      },
      {
        id: 'a-7-2-3',
        text: 'Паттерн для создания наблюдаемых объектов',
        isCorrect: false,
      },
      {
        id: 'a-7-2-4',
        text: 'Паттерн для оптимизации рендеринга',
        isCorrect: false,
      },
    ],
    explanation:
      'Observer — это паттерн, при котором объект (Subject) уведомляет список наблюдателей (Observers) об изменениях. React использует похожий паттерн для обновления компонентов.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-3',
    type: 'multiple',
    question: 'Какие архитектурные подходы используются во фронтенде?',
    answers: [
      {
        id: 'a-7-3-1',
        text: 'MVC (Model-View-Controller)',
        isCorrect: true,
      },
      {
        id: 'a-7-3-2',
        text: 'MVVM (Model-View-ViewModel)',
        isCorrect: true,
      },
      {
        id: 'a-7-3-3',
        text: 'Feature-Sliced Design',
        isCorrect: true,
      },
      {
        id: 'a-7-3-4',
        text: 'Clean Architecture',
        isCorrect: true,
      },
      {
        id: 'a-7-3-5',
        text: 'Только один подход для всех проектов',
        isCorrect: false,
      },
    ],
    explanation:
      'Во фронтенде используются различные архитектурные подходы: MVC, MVVM, FSD, Clean Architecture. Выбор зависит от размера проекта и требований.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-4',
    type: 'single',
    question: 'Что такое паттерн Factory?',
    answers: [
      {
        id: 'a-7-4-1',
        text: 'Паттерн, который создаёт объекты без указания конкретного класса',
        isCorrect: true,
      },
      {
        id: 'a-7-4-2',
        text: 'Паттерн для работы с базами данных',
        isCorrect: false,
      },
      {
        id: 'a-7-4-3',
        text: 'Паттерн для оптимизации производительности',
        isCorrect: false,
      },
      {
        id: 'a-7-4-4',
        text: 'Паттерн для работы с API',
        isCorrect: false,
      },
    ],
    explanation:
      'Factory — паттерн создания объектов через фабричную функцию/класс, скрывающую детали создания. Полезен когда нужно создавать объекты разных типов в зависимости от условий.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-5',
    type: 'single',
    question: 'Что такое паттерн Strategy?',
    answers: [
      {
        id: 'a-7-5-1',
        text: 'Паттерн, который определяет семейство алгоритмов и делает их взаимозаменяемыми',
        isCorrect: true,
      },
      {
        id: 'a-7-5-2',
        text: 'Паттерн для работы с состояниями',
        isCorrect: false,
      },
      {
        id: 'a-7-5-3',
        text: 'Паттерн для оптимизации',
        isCorrect: false,
      },
      {
        id: 'a-7-5-4',
        text: 'Паттерн для работы с формами',
        isCorrect: false,
      },
    ],
    explanation:
      'Strategy позволяет выбирать алгоритм во время выполнения. Пример: разные стратегии валидации, оплаты, сортировки. Полезен когда есть несколько способов выполнить задачу.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-6',
    type: 'single',
    question: 'Что такое паттерн Module в JavaScript?',
    answers: [
      {
        id: 'a-7-6-1',
        text: 'Паттерн для инкапсуляции кода и создания приватной области видимости',
        isCorrect: true,
      },
      {
        id: 'a-7-6-2',
        text: 'Паттерн для работы с модулями Node.js',
        isCorrect: false,
      },
      {
        id: 'a-7-6-3',
        text: 'Паттерн для оптимизации',
        isCorrect: false,
      },
      {
        id: 'a-7-6-4',
        text: 'Паттерн для работы с классами',
        isCorrect: false,
      },
    ],
    explanation:
      'Module pattern использует замыкания для создания приватной области видимости и публичного API. Пример: IIFE (Immediately Invoked Function Expression). Основа для ES modules.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-7',
    type: 'single',
    question:
      'Что чаще всего является практическим нарушением принципа Single Responsibility в React-коде?',
    answers: [
      {
        id: 'a-7-7-1',
        text: 'Компонент одновременно управляет состоянием, ходит в API, форматирует данные и отвечает за разметку',
        isCorrect: true,
      },
      {
        id: 'a-7-7-2',
        text: 'Компонент использует несколько хуков (useState, useMemo, useEffect)',
        isCorrect: false,
      },
      {
        id: 'a-7-7-3',
        text: 'Компонент принимает много пропсов, но не содержит бизнес-логики',
        isCorrect: false,
      },
      {
        id: 'a-7-7-4',
        text: 'Компонент вынесен в отдельную папку feature и имеет собственные тесты',
        isCorrect: false,
      },
    ],
    explanation:
      'SRP нарушается не количеством хуков, а количеством «причин для изменения». Когда UI, запросы, маппинг DTO→VM и бизнес-правила смешаны в одном компоненте, менять его приходится по любому поводу.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-8',
    type: 'multiple',
    question:
      'Какие решения обычно помогают соблюдать Dependency Inversion во фронтенде?',
    answers: [
      {
        id: 'a-7-8-1',
        text: 'Зависеть от контрактов (интерфейсов/типов) и подставлять реализации через адаптеры',
        isCorrect: true,
      },
      {
        id: 'a-7-8-2',
        text: 'Инкапсулировать работу с сетью в слой api/lib и не импортировать axios/fetch напрямую в UI',
        isCorrect: true,
      },
      {
        id: 'a-7-8-3',
        text: 'Писать бизнес-правила (use cases) так, чтобы они не знали о React и маршрутизации',
        isCorrect: true,
      },
      {
        id: 'a-7-8-4',
        text: 'Хранить все зависимости в одном глобальном синглтоне',
        isCorrect: false,
      },
    ],
    explanation:
      'DIP — про зависимость высокоуровневых модулей от абстракций. На практике это означает: UI/use cases не знают о конкретном HTTP-клиенте и инфраструктуре, а детали подключаются через адаптеры.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-9',
    type: 'single',
    question:
      'Какой из примеров лучше всего иллюстрирует нарушение Liskov Substitution (LSP) на уровне API/типов?',
    answers: [
      {
        id: 'a-7-9-1',
        text: 'Подтип «сужает контракт»: метод базового типа гарантирует результат, а подтип начинает иногда бросать ошибку вместо результата',
        isCorrect: true,
      },
      {
        id: 'a-7-9-2',
        text: 'Подтип добавляет новые методы, не меняя поведение унаследованных',
        isCorrect: false,
      },
      {
        id: 'a-7-9-3',
        text: 'Подтип переопределяет метод, сохраняя предусловия и постусловия',
        isCorrect: false,
      },
      {
        id: 'a-7-9-4',
        text: 'Базовый тип использует generics, а подтип — нет',
        isCorrect: false,
      },
    ],
    explanation:
      'LSP: где ожидается базовый тип, должен корректно работать подтип. Нарушение — когда подтип усиливает предусловия или ослабляет гарантии (контракт) и ломает код, который полагается на поведение базового типа.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-10',
    type: 'single',
    question:
      'Почему Singleton во фронтенде часто считают проблемным решением (особенно в тестах)?',
    answers: [
      {
        id: 'a-7-10-1',
        text: 'Он создаёт глобальное скрытое состояние и усложняет изоляцию тестов/подмену зависимостей',
        isCorrect: true,
      },
      {
        id: 'a-7-10-2',
        text: 'Он может быть удобен для “единого источника правды”, но часто делает зависимости неявными: в тестах и при SSR/изоляции окружений это вызывает трудноотлавливаемые побочные эффекты',
        isCorrect: false,
      },
      {
        id: 'a-7-10-3',
        text: 'Singleton в JS возможен, но его “глобальность” часто приводит к скрытым связям. Лучше явная передача зависимостей/контейнер или фабрика, если нужен контроль жизненного цикла',
        isCorrect: false,
      },
      {
        id: 'a-7-10-4',
        text: 'Он не работает в браузере из-за изоляции вкладок',
        isCorrect: false,
      },
    ],
    explanation:
      'Главный минус Singleton — не «паттерн плохой», а то, что глобальное состояние инициализируется один раз и становится неявной зависимостью. Это ведёт к связанности, сложности моков и проблемам с повторяемостью тестов.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-11',
    type: 'single',
    question:
      'Чем Observer чаще всего отличается от Pub/Sub (Publish–Subscribe) на практике?',
    answers: [
      {
        id: 'a-7-11-1',
        text: 'В Observer наблюдатели подписываются на конкретный субъект, а в Pub/Sub издатель и подписчики обычно развязаны через брокер/шину событий',
        isCorrect: true,
      },
      {
        id: 'a-7-11-2',
        text: 'И Observer, и Pub/Sub могут быть и синхронными, и асинхронными. Ключевое — степень связности (прямая связь vs посредник)',
        isCorrect: false,
      },
      {
        id: 'a-7-11-3',
        text: 'Оба паттерна — общие. В UI часто встречаются оба: Observer ближе к “подписке на конкретный объект”, Pub/Sub — к “шине событий”',
        isCorrect: false,
      },
      {
        id: 'a-7-11-4',
        text: 'Observer нельзя реализовать без классов, а Pub/Sub — без функций',
        isCorrect: false,
      },
    ],
    explanation:
      'Observer обычно подразумевает прямую связь «subject → observers». Pub/Sub вводит посредника (event bus), что помогает развязать модули, но усложняет трассировку потока и дебаг.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-12',
    type: 'single',
    question:
      'У вас есть сложная SDK-библиотека оплаты с десятками методов. Вы хотите дать команде простой API из 3–4 функций. Какой паттерн наиболее уместен?',
    answers: [
      {
        id: 'a-7-12-1',
        text: 'Facade',
        isCorrect: true,
      },
      {
        id: 'a-7-12-2',
        text: 'Adapter',
        isCorrect: false,
      },
      {
        id: 'a-7-12-3',
        text: 'Strategy',
        isCorrect: false,
      },
      {
        id: 'a-7-12-4',
        text: 'Observer',
        isCorrect: false,
      },
    ],
    explanation:
      'Facade скрывает внутреннюю сложность и предоставляет удобный «фасад» над подсистемой. Adapter больше про согласование несовместимых интерфейсов, а не про упрощение богатого API.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-13',
    type: 'single',
    question:
      'Какая формулировка точнее всего описывает разницу Strategy и State?',
    answers: [
      {
        id: 'a-7-13-1',
        text: 'Strategy выбирает алгоритм извне (контекст делегирует поведение), а State меняет поведение в зависимости от внутреннего состояния контекста',
        isCorrect: true,
      },
      {
        id: 'a-7-13-2',
        text: 'Strategy работает только с функциями, State — только с классами',
        isCorrect: false,
      },
      {
        id: 'a-7-13-3',
        text: 'Strategy нужен для асинхронности, State — для синхронного кода',
        isCorrect: false,
      },
      {
        id: 'a-7-13-4',
        text: 'State — это частный случай Singleton',
        isCorrect: false,
      },
    ],
    explanation:
      'Оба паттерна инкапсулируют поведение, но мотив разный: Strategy — «какой алгоритм применить», State — «как контекст себя ведёт в текущем состоянии» (и состояния могут переключаться).',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-14',
    type: 'multiple',
    question: 'Какие задачи во фронтенде часто решают через Proxy?',
    answers: [
      {
        id: 'a-7-14-1',
        text: 'Ленивая инициализация (lazy) и отложенная загрузка зависимостей',
        isCorrect: true,
      },
      {
        id: 'a-7-14-2',
        text: 'Логирование/трейсинг доступа к данным и методов',
        isCorrect: true,
      },
      {
        id: 'a-7-14-3',
        text: 'Валидация и нормализация входных данных перед записью',
        isCorrect: true,
      },
      {
        id: 'a-7-14-4',
        text: 'Proxy может помочь с lazy/трейсингом/валидацией, но “ускорение рендера” не гарантирует: наоборот, лишняя прокси-обёртка может добавить overhead',
        isCorrect: false,
      },
    ],
    explanation:
      'Proxy — контроль доступа к объекту. В JS `new Proxy()` часто используют для логирования, валидации, мемоизации/кэширования, lazy-инициализации и разных метапрограммных трюков.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-15',
    type: 'multiple',
    question:
      'Какие признаки чаще всего указывают на архитектурный анти-паттерн “God component”?',
    answers: [
      {
        id: 'a-7-15-1',
        text: 'Компонент содержит много несвязанных обязанностей: данные, бизнес-правила, навигацию, UI и сайд-эффекты',
        isCorrect: true,
      },
      {
        id: 'a-7-15-2',
        text: 'Компонент трудно тестировать изолированно без большого количества моков',
        isCorrect: true,
      },
      {
        id: 'a-7-15-3',
        text: 'Любое небольшое изменение требований приводит к правкам в нескольких местах внутри одного файла',
        isCorrect: true,
      },
      {
        id: 'a-7-15-4',
        text: 'Компонент использует Tailwind и utility-классы',
        isCorrect: false,
      },
    ],
    explanation:
      'God component — это про концентрацию ответственности и связанность, а не про технологию стилей. Симптомы: сложность тестирования, низкая переиспользуемость, высокий “blast radius” изменений.',
    chapterId: 'chapter-7-1',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-16',
    type: 'single',
    question:
      'Какое утверждение точнее всего про MVC/MVP/MVVM в контексте современного React?',
    answers: [
      {
        id: 'a-7-16-1',
        text: 'React сам по себе не является полной архитектурой, но часто используют идеи MVVM: “View” + слой состояния/логики (hooks/store) как “ViewModel”',
        isCorrect: true,
      },
      {
        id: 'a-7-16-2',
        text: 'В React можно приблизить архитектуру к MV* (например, выделить ViewModel слой в хуках/сторе), но React сам по себе не “навязывает” строгий MVC',
        isCorrect: false,
      },
      {
        id: 'a-7-16-3',
        text: 'MVC/MVP/MVVM неприменимы во фронтенде, потому что они только для бэкенда',
        isCorrect: false,
      },
      {
        id: 'a-7-16-4',
        text: 'useEffect — это инструмент для побочных эффектов, а не “архитектурный переключатель”. Архитектуру определяет разбиение слоёв/границ и зависимости',
        isCorrect: false,
      },
    ],
    explanation:
      'На интервью обычно ожидают, что вы отличаете фреймворк/библиотеку (React) от архитектуры. Реальные приложения строят поверх React: выделяют слой данных, бизнес-логики, презентационный слой и т.д.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-17',
    type: 'multiple',
    question:
      'Какие пункты чаще всего называют практическими преимуществами Redux/Flux-подхода в больших приложениях?',
    answers: [
      {
        id: 'a-7-17-1',
        text: 'Предсказуемый однонаправленный поток данных',
        isCorrect: true,
      },
      {
        id: 'a-7-17-2',
        text: 'Логируемость и воспроизводимость сценариев (например, через action log)',
        isCorrect: true,
      },
      {
        id: 'a-7-17-3',
        text: 'Упрощение дебага (включая time-travel в devtools)',
        isCorrect: true,
      },
      {
        id: 'a-7-17-4',
        text: 'Автоматическая оптимизация SEO без SSR',
        isCorrect: false,
      },
    ],
    explanation:
      'Плюсы Redux — это управляемость и дебажимость. Он не делает SEO “сам по себе”: SEO зависит от SSR/рендеринга, а не от менеджера состояния.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-18',
    type: 'single',
    question:
      'Как CQRS чаще всего проявляется во фронтенде (в терминах практик и слоёв)?',
    answers: [
      {
        id: 'a-7-18-1',
        text: 'Разделение “команд” (изменяют состояние) и “запросов” (читают состояние): actions/mutations vs selectors/queries',
        isCorrect: true,
      },
      {
        id: 'a-7-18-2',
        text: 'CQRS — не про HTTP-методы, а про разделение чтения и записи. В API это может совпадать с GET vs POST/PUT/PATCH, но это не правило и не суть',
        isCorrect: false,
      },
      {
        id: 'a-7-18-3',
        text: 'Запрет на кеширование и мемоизацию',
        isCorrect: false,
      },
      {
        id: 'a-7-18-4',
        text: 'Переход на микрофронтенды',
        isCorrect: false,
      },
    ],
    explanation:
      'CQRS — это архитектурная идея разделения чтения и записи. Во фронтенде это хорошо видно в связке “команды” (reducers/mutations) и “запросы” (selectors/useQuery).',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-19',
    type: 'single',
    question: 'Когда микрофронтенды чаще всего оправданы (а не “модно”)?',
    answers: [
      {
        id: 'a-7-19-1',
        text: 'Когда несколько больших команд должны релизиться независимо и продукт можно разрезать на относительно автономные домены',
        isCorrect: true,
      },
      {
        id: 'a-7-19-2',
        text: 'Когда нужно просто уменьшить bundle size',
        isCorrect: false,
      },
      {
        id: 'a-7-19-3',
        text: 'Когда проект маленький и один разработчик ведёт весь фронтенд',
        isCorrect: false,
      },
      {
        id: 'a-7-19-4',
        text: 'Когда хочется использовать больше библиотек одновременно',
        isCorrect: false,
      },
    ],
    explanation:
      'Microfrontend решает организационные и релизные проблемы, но повышает сложность интеграции, DevOps, наблюдаемости и совместного UX. Ради “оптимизации бандла” обычно достаточно code splitting и правильных границ модулей.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-20',
    type: 'multiple',
    question:
      'Какие проблемы чаще всего появляются при Module Federation / микрофронтендах?',
    answers: [
      {
        id: 'a-7-20-1',
        text: 'Дублирование зависимостей и увеличение общего веса загрузки',
        isCorrect: true,
      },
      {
        id: 'a-7-20-2',
        text: 'Сложности со “shared” версиями (React, router) и конфликтами runtime',
        isCorrect: true,
      },
      {
        id: 'a-7-20-3',
        text: 'Сложность сквозных тестов, мониторинга и дебага цепочек ошибок',
        isCorrect: true,
      },
      {
        id: 'a-7-20-4',
        text: 'Гарантированное упрощение CI/CD и деплоя',
        isCorrect: false,
      },
    ],
    explanation:
      'Микрофронтенды почти всегда усложняют CI/CD и операционку. Главные боли — зависимости, совместимость runtime, сквозные UX-паттерны, ошибки интеграции и наблюдаемость.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-21',
    type: 'single',
    question:
      'Какой аргумент “против” Clean Architecture во фронтенде чаще всего является справедливым?',
    answers: [
      {
        id: 'a-7-21-1',
        text: 'Для небольших проектов оверхед слоёв и абстракций может перевесить пользу, усложняя разработку',
        isCorrect: true,
      },
      {
        id: 'a-7-21-2',
        text: 'Наоборот: одна из целей Clean Architecture — тестируемость доменной логики в изоляции. Проблема скорее в оверхеде/сложности для небольших проектов',
        isCorrect: false,
      },
      {
        id: 'a-7-21-3',
        text: 'Clean Architecture не “запрещает” библиотеки: она требует, чтобы доменная логика не зависела от них напрямую (а адаптеры/инфра — могли зависеть)',
        isCorrect: false,
      },
      {
        id: 'a-7-21-4',
        text: 'Подход применим и в браузере, но его ценность зависит от масштаба: чем больше доменной логики и требований к тестируемости/замене инфраструктуры, тем больше смысл',
        isCorrect: false,
      },
    ],
    explanation:
      'Clean Architecture даёт тестируемость и независимость от UI, но “цена” — больше слоёв, интерфейсов и дисциплины. На маленьких кодовых базах это может быть избыточно.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-22',
    type: 'multiple',
    question:
      'Какие правила зависимостей обычно считают “здоровыми” в FSD/модульной архитектуре?',
    answers: [
      {
        id: 'a-7-22-1',
        text: 'shared не должен импортировать entities/features/pages (только наоборот)',
        isCorrect: true,
      },
      {
        id: 'a-7-22-2',
        text: 'entities не должны зависеть от features (features строятся поверх entities)',
        isCorrect: true,
      },
      {
        id: 'a-7-22-3',
        text: 'UI-слой должен зависеть от API напрямую, чтобы было меньше абстракций',
        isCorrect: false,
      },
      {
        id: 'a-7-22-4',
        text: 'Чем выше слой (pages/app), тем больше он может “собирать” и композиционировать нижние слои',
        isCorrect: true,
      },
    ],
    explanation:
      'Смысл FSD — контролируемые зависимости и локализация логики. Чем ниже слой, тем он “чище” и переиспользуемее; чем выше — тем больше композиции.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
  {
    id: 'q-7-23',
    type: 'single',
    question:
      'Какой шаг лучше всего соответствует принципам Evolutionary Design (эволюционного дизайна) в большом фронтенде?',
    answers: [
      {
        id: 'a-7-23-1',
        text: 'Сначала ввести минимально нужные границы модулей и правила зависимостей, а затем эволюционно усиливать архитектуру по мере роста требований',
        isCorrect: true,
      },
      {
        id: 'a-7-23-2',
        text: 'Эволюционный дизайн — это не “запрет отклонений”, а управляемая адаптация: маленькие изменения, обратная связь, и корректировки границ по мере роста продукта',
        isCorrect: false,
      },
      {
        id: 'a-7-23-3',
        text: 'Полностью отказаться от рефакторинга, чтобы не трогать рабочий код',
        isCorrect: false,
      },
      {
        id: 'a-7-23-4',
        text: 'Сразу внедрить микрофронтенды, чтобы “наверняка масштабировалось”',
        isCorrect: false,
      },
    ],
    explanation:
      'Эволюционный дизайн предполагает, что требования меняются. Практика: вводить небольшие, проверяемые улучшения (границы, соглашения, тесты), а не “застывать” в сверхпроектировании.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'medium',
  },
  {
    id: 'q-7-24',
    type: 'single',
    question:
      'Какое правило лучше всего снижает связанность между фичами в feature-based архитектуре?',
    answers: [
      {
        id: 'a-7-24-1',
        text: 'Фичи не должны импортировать внутренности друг друга напрямую — взаимодействие через публичные API/контракты или через слой entities/shared',
        isCorrect: true,
      },
      {
        id: 'a-7-24-2',
        text: 'Все фичи должны хранить общие утилиты внутри себя, чтобы не зависеть от shared',
        isCorrect: false,
      },
      {
        id: 'a-7-24-3',
        text: 'Нужно складывать компоненты всех фич в один общий каталог components/common',
        isCorrect: false,
      },
      {
        id: 'a-7-24-4',
        text: 'Нужно хранить состояние всех фич в одном большом reducer без разделения',
        isCorrect: false,
      },
    ],
    explanation:
      'Ключ к масштабированию — не “общая папка”, а ясные границы и зависимости. Если фичи тянут друг друга напрямую, изменения становятся цепными и повышается стоимость поддержки.',
    chapterId: 'chapter-7-2',
    partId: 'part-7',
    difficulty: 'hard',
  },
]
