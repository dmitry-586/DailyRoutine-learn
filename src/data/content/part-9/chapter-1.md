# Глава 26. Основы Node.js

Фронтенд-разработчик сегодня — это не только браузер. Node.js нужен для:

- сборки (Webpack, Vite, линтеры, тесты)
- SSR и SSG (Next.js, Remix, Astro)
- BFF (Backend For Frontend) и edge‑функций
- простых API и интеграций

Для фронтенда важно не уметь писать сложный бэкенд, а понимать:

- как крутится ваш код в Node (Event Loop, модули, I/O)
- чем поведение JS в Node отличается от браузера
- как устроены скрипты, зависимости и окружение проекта

Это база, без которой сложно уверенно отвечать на вопросы про сборку, SSR и инфраструктуру на собеседованиях.

---

## 26.1. Event Loop в Node.js

Node.js однопоточен, но неблокирующий. Это возможно благодаря Event Loop.

### Фазы Event Loop

1. timers — setTimeout, setInterval
2. pending callbacks — отложенные колбэки
3. idle, prepare — внутренние операции
4. poll — получение новых I/O событий
5. check — setImmediate
6. close callbacks — закрытие соединений

### Microtasks

- process.nextTick — самый приоритетный
- Promise.then

Выполняются между фазами.

### Сравнение с браузером

**Браузер:**

- Web APIs
- macrotasks
- microtasks

**Node:**

- libuv
- phases
- nextTick / Promise

---

## 26.2. CommonJS vs ES Modules

### CommonJS

```javascript
const fs = require('fs')
```

- синхронная загрузка
- runtime
- используется в старых проектах Node.js

### ES Modules

```javascript
import fs from 'fs'
```

- статический анализ
- tree-shaking
- современный стандарт

### Когда что

- старые проекты — CJS
- новые — ESM

---

## 26.3. npm-скрипты

### package.json

```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  }
}
```

### Lifecycle hooks

- prebuild — перед сборкой
- postinstall — после установки

**Используется для:**

- генерации файлов
- подготовки окружения

---

## 26.4. Лёгкое API: Express / Fastify

### Express

```javascript
app.get('/api', (req, res) => {
  res.json({ ok: true })
})
```

### Fastify

- быстрее
- schema-based валидация
- лучше для production

### Когда фронту нужен Node

- SSR (Next.js, Remix)
- proxy API
- mock сервер
- server actions
- интеграция с внешними API (webhooks, задачи по расписанию)

---

## 26.5. Практические сценарии для фронтенд-разработчика

### 1) Локальная сборка и дев‑окружение

Почти любой современный фронтенд‑проект живёт в Node‑окружении:

- `npm run dev` — старт dev‑сервера (Vite, Next.js, CRA)
- `npm run build` — продакшн‑сборка
- `npm run test` — запуск Jest / Playwright

**Самопроверка:**

- можешь ли ты объяснить, какие именно инструменты стоят за каждым скриптом;
- понимаешь ли, какая версия Node требуется проекту и где это указано (`engines` в `package.json`, `.nvmrc` и т.п.).

### 2) BFF (Backend For Frontend)

Типичный кейс: у фронта есть несколько внешних API, которые неудобны или небезопасны для прямого вызова из браузера.

Node‑слой BFF позволяет:

- объединять несколько запросов в один
- прятать секреты (ключи, токены)
- нормализовать ответы под нужды UI

**Пример сценария:**

- браузер → `/api/profile`
- Node‑BFF ходит в несколько внутренних сервисов
- заранее готовит удобную структуру для React‑компонентов

На собеседованиях часто спрашивают: **«Зачем фронту BFF, если можно ходить напрямую в бэкенд?»**  
Хороший ответ — про удобство API для UI, безопасность и контроль над версионированием.

### 3) SSR / SSG и Next.js

Когда вы используете Next.js, Remix или аналог, вы по факту работаете и с браузером, и с Node сразу:

- серверный рендер (getServerSideProps / server components / loaders)
- генерация статики (SSG)
- API‑роуты внутри того же репозитория

Важно понимать:

- что код «только для сервера» (доступ к файловой системе, секретам);
- что код «только для клиента» (DOM, `window`);
- где нельзя тянуть крупные зависимости, чтобы не раздувать клиентский бандл.

### 4) Скрипты обслуживания и инструменты

Node часто используют для небольших утилит:

- генерация типов из схемы API
- миграции данных
- одноразовые скрипты (парсинг CSV, очистка данных)

Такие вещи редко попадают в собеседование, но сильно повышают ценность разработчика в реальной команде.

---

## Вопросы на собеседовании

### 1. Почему Node однопоточен?

Одна нить выполнения, но неблокирующий I/O через Event Loop и libuv.

### 2. Event Loop в Node и браузере — различия?

Разные фазы, есть process.nextTick, порядок выполнения micro/macro‑tasks отличается.

### 3. process.nextTick vs Promise?

`nextTick` выполняется раньше `Promise.then` в Node.js, между текущим кодом и остальными microtasks.

### 4. CommonJS vs ES Modules?

CommonJS — динамический runtime‑формат (`require`), ES Modules — статический (`import/export`), даёт tree‑shaking и лучше работает с бандлерами.

### 5. Зачем фронту Node?

Сборка, тесты, SSR/SSG, BFF‑слой, dev‑инструменты, утилиты обслуживания.

### 6. Express vs Fastify?

Fastify быстрее и даёт schema‑based валидацию, Express проще для старта и имеет огромную экосистему.

### 7. Что должен уметь Middle по Node?

Понимать Event Loop в общих чертах, различия модульных систем, уметь читать простую Express/Fastify‑конфигурацию и объяснить, как устроены npm‑скрипты и окружение проекта.

---

## Key Takeaways

- Node.js однопоточен, но неблокирующий через Event Loop и libuv.
- Event Loop в Node отличается от браузера (фазы, приоритет `process.nextTick`, поведение microtasks).
- CommonJS и ES Modules — разные модели модулей, важно понимать их для сборки и SSR.
- Node нужен фронтендеру для инструментов, SSR/SSG, BFF и утилит, а не только «настоящего бэкенда».
- Express/Fastify решают задачи лёгкого API и BFF, а понимание их основ достаточно для Middle‑уровня.

---

В финальной части мы переключимся с технологий на подготовку к собеседованиям: разберём типовые форматы, вопросы, ожидания по уровням и то, как упаковать весь пройденный путь во внятную историю для работодателя.
