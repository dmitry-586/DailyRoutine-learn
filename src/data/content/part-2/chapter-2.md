# Глава 6. Современная экосистема CSS

CSS прошёл огромный путь: от простого языка для раскраски HTML до полноценной системы управления стилями, динамическим поведением и архитектурой интерфейсов.

Современный CSS — это уже не только color: red, а целая экосистема инструментов:

- кастомные свойства (CSS Variables)
- каскадные слои (Cascade Layers)
- современные селекторы
- тёмные темы без JS
- CSS-модули
- CSS-in-JS
- методологии вроде БЭМ
- Shadow DOM

В этой главе мы выходим за рамки «чистого CSS» и переходим к тому, как стили пишутся в реальных проектах: с изоляцией, масштабированием, переиспользованием и защитой от конфликтов.

На собеседованиях уровня Middle+ эту главу часто используют, чтобы понять:

- работали ли вы с большими кодовыми базами
- понимаете ли проблемы масштабирования CSS
- умеете ли выбирать инструмент под задачу, а не наоборот

Эта глава объяснит, как всё это работает вместе, чтобы стили были:

1. предсказуемыми
2. поддерживаемыми
3. масштабируемыми
4. удобными в разработке

---

## 6.1. CSS Custom Properties (переменные)

CSS-переменные — это настоящие runtime-переменные, в отличие от препроцессоров.

CSS-переменные выглядят так:

```css
:root {
  --primary-color: #3b82f6;
  --spacing: 16px;
}
```

**Использование:**

```css
.button {
  background: var(--primary-color);
  padding: var(--spacing);
}
```

### Главное отличие custom properties от препроцессорных переменных

**SCSS:**

- подставляются во время сборки
- статичны
- не видны в DevTools как переменные

**CSS custom properties:**

- вычисляются во время работы
- наследуются
- динамически обновляются через JS
- участвуют в каскаде

### Почему CSS-переменные — лучшее решение для темизации

**Темная тема:**

```css
:root {
  --bg: white;
  --text: black;
}

[data-theme='dark'] {
  --bg: black;
  --text: white;
}
```

JS переключает только атрибут:

```javascript
document.body.dataset.theme = 'dark'
```

А CSS сам всё перекрасит. Без перерендера, без миграций, без сложного JS.

**Почему это важно?**

- работают в runtime
- могут переопределяться в DOM
- реагируют на media queries
- удобны для темизации

---

## 6.2. Каскадные слои (CSS Cascade Layers)

Это один из самых больших апдейтов CSS за последние годы.

**Проблема старая:** когда проект растёт, порядок подключения файлов превращается в ад. Ты можешь подключать стили в нужной последовательности, но один маленький CSS от компонента ломает всю страницу.

Cascade Layers решают эту проблему.

**Как это выглядит:**

```css
@layer reset, base, components, utilities;

@layer reset {
  * {
    margin: 0;
    padding: 0;
  }
}

@layer base {
  body {
    font-family: sans-serif;
  }
}

@layer components {
  .btn {
    padding: 8px 12px;
  }
}

@layer overrides {
  .btn {
    padding: 16px;
  }
}
```

Приоритет зависит не от порядка объявления правил, а от порядка слоёв.

**Почему это революция?**

Теперь структура приоритетов стилей:

1. пользовательские стили (user styles)
2. авторские стили (author styles)
3. каскадные слои
4. важность: !important
5. специфичность
6. порядок объявления

Впервые за 25 лет CSS в середину каскада добавили ещё один уровень управления. Это делает большие проекты гораздо проще.

Используется в design-system'ах и UI-библиотеках.

---

## 6.3. Современные селекторы: has(), :is(), :where()

Эти селекторы — суперсила современного CSS.

### :has() — «родительский» селектор

**Пример:** выделить карточку, если внутри есть ошибка.

```css
.card:has(.error) {
  border-color: red;
}
```

CSS вдруг стал реактивным.

**Другой пример:** сделать кнопку активной, если выделен checkbox.

```css
button:has(+ input:checked) {
  opacity: 1;
}
```

### :is() — сокращает длинные селекторы

**Вместо:**

```css
article p,
article span,
article a {
  color: gray;
}
```

**Можно писать:**

```css
article :is(p, span, a) {
  color: gray;
}
```

### :where() — тот же :is(), но со специфичностью 0

Очень полезно при сбросе стилей.

```css
form :where(input, button, select) {
  margin: 0;
}
```

---

## 6.4. CSS Modules

CSS Modules — это расширение сборщика (Webpack, Vite, и др.), а не нативный CSS. Требует поддержки со стороны инструментов сборки.

CSS Modules решают главную проблему CSS — глобальную область видимости.

Это техника, сейчас распространённая в React/Vue/Svelte.

**Пример:**

```css
/* button.module.css */
.primary {
  background: blue;
}
```

**В JS:**

```javascript
import styles from './button.module.css'
;<button className={styles.primary} />
```

**Что происходит под капотом?**

Класс превращается в: `primary__3Gh7s`

Конфликты исчезают. Более того, стили компонентны по определению.

**Плюсы:**

- изоляция
- отсутствие конфликтов
- хорошая интеграция с React/Vue

**Минусы:**

- нельзя динамически формировать селекторы
- не нативный CSS
- требует сборки
- нет динамических runtime-возможностей (как у CSS Variables)

---

## 6.5. Styled-components и CSS-in-JS

CSS-in-JS — подход, при котором стили описываются прямо в JS. Появилась из мира React, но потом распространилась шире.

**Идея простая:** Компонент отвечает сам за свои стили. Стиль — это часть логики UI.

**Самые популярные варианты:**

- styled-components
- Emotion
- JSS
- stitches
- vanilla-extract

**Пример (styled-components):**

```javascript
const Button = styled.button`
  padding: 10px;
  border-radius: 6px;
  background: ${(props) => (props.primary ? 'blue' : 'gray')};
`
```

Это сочетает:

- динамику JS
- читаемость CSS
- возможность темизации

**Плюсы:**

- динамические стили
- theme-поддержка
- колокация кода и стилей

**Минусы:**

- runtime-нагрузка
- сложнее дебажить
- зависит от библиотеки
- проблемы производительности в больших проектах

**Когда CSS-in-JS оправдан?**

- сложная тема
- динамические дизайн-системы
- UI-библиотеки
- стили зависят от props компонента, состояния, бизнес-логики

---

## 6.6. Shadow DOM и Web Components

Shadow DOM — механизм инкапсуляции DOM и CSS. Стили, которые невозможно «сломать».

```javascript
const shadow = element.attachShadow({ mode: 'open' })
```

Стили внутри shadow root не протекают наружу и наоборот.

Shadow DOM изолирует компонент полностью: `<user-profile></user-profile>`

Внутри элемента лежит «теневая» DOM-структура, недоступная из внешнего CSS.

**Web Components включают:**

1. Custom Elements
2. Shadow DOM
3. HTML Templates

**Где используется?**

- design-systems
- микрофронтенды
- библиотечные компоненты
- некоторые UI-библиотеки

**Плюсы:**

- гарантированная изоляция
- отсутствие конфликтов

**Минус:**

- сложнее переопределять стили

---

## 6.7. БЭМ: методология и практика

Методологии нужны только для больших проектов. Если ты работаешь над лендингом — BEM, скорее всего, лишний. Но в продуктовых командах методология даёт структуру.

БЭМ = Блок — Элемент — Модификатор

**Принцип:**

- block
- block\_\_element
- block--modifier

**Пример карточки:**

```html
<div class="card card--featured">
  <h2 class="card__title">Header</h2>
  <button class="button button--primary">Buy</button>
</div>
```

**Принципы:**

- каждый блок независим
- вложенность минимальна
- селекторы простые
- стили предсказуемы

**Плюсы БЭМ:**

- масштабируемость
- читаемость
- легко поддерживать
- идеален для командной разработки

**Минусы:**

- длинные классы
- может казаться громоздким
- многословность
- строгая дисциплина

---

## 6.8. Когда что использовать (практические рекомендации)

**Для продуктового интерфейса на React:**

- style modules или CSS-in-JS
- CSS Custom Properties
- частично — Cascade Layers
- немного БЭМ для стабильных блоков

**Для больших сайтов с множеством страниц:**

- БЭМ
- каскадные слои
- переменные
- минимальный CSS-in-JS

**Для виджетов и микрофронтендов:**

- Shadow DOM
- CSS Variables
- изолированные стили

**Для дизайн-систем:**

- строгий БЭМ
- каскадные слои
- Grid/Flex
- переменные темизации

---

## Вопросы на собеседовании

### 1. Чем CSS-переменные отличаются от SCSS-переменных?

CSS Variables — динамические, runtime, наследуются, участвуют в каскаде. SCSS переменные — статические, compile-time, подставляются при сборке.

### 2. Что такое CSS Modules и зачем они нужны?

Техника изоляции стилей через уникальные имена классов. Решает проблему глобальной области видимости CSS.

### 3. В чём плюсы и минусы CSS-in-JS?

Плюсы: динамические стили, темизация, колокация. Минусы: runtime-нагрузка, сложнее дебажить, проблемы производительности.

### 4. Когда стоит использовать Shadow DOM?

Для виджетов, микрофронтендов, дизайн-систем, когда нужна абсолютная изоляция стилей.

### 5. Чем Web Components отличаются от React-компонентов?

Web Components — нативные браузерные компоненты с Shadow DOM. React-компоненты — виртуальный DOM и библиотека.

### 6. Что такое каскадные слои?

Механизм управления приоритетами стилей через уровни (layers), независимо от порядка подключения.

### 7. Как БЭМ помогает масштабировать CSS?

Структурирует именование, делает селекторы предсказуемыми, упрощает поддержку в команде.

### 8. Почему глобальный CSS — проблема?

Конфликты имён, сложность поддержки, непредсказуемость при масштабировании.

### 9. Что такое :has() и почему это важно?

Родительский селектор, позволяющий изменять стиль элемента в зависимости от содержимого. Революция для CSS.

---

## Key Takeaways

- CSS Custom Properties — стандартный способ темизации
- Cascade Layers дают новый уровень контроля над каскадом
- Grid/Flex теперь поддерживаются всеми браузерами и заменяют фреймворки
- CSS Modules дают изоляцию без runtime
- CSS-in-JS полезен для динамических UI, но требует внимательности к производительности
- БЭМ — надёжная методология для командных проектов
- Shadow DOM даёт абсолютную изоляцию стилей
- Современные селекторы (:has, :is, :where) расширяют возможности CSS

---

**Часть II. CSS: от основ до продвинутых инструментов**
