# Глава 26. Алгоритмические задачи для фронтенда

Алгоритмические задачи для фронтенд‑разработчика — это не соревнование по олимпиадному программированию, а проверка базовой инженерной подготовки:
умеешь ли ты работать с данными, последовательно рассуждать, выбирать подходящие структуры и объяснять свои решения.

Чаще всего от фронтендера не ожидают реализации красно‑чёрных деревьев или собственных хеш-таблиц, но почти всегда проверяют:

- умение аккуратно обходить массивы и объекты
- понимание сложности по времени и памяти хотя бы на интуитивном уровне
- умение писать чистый, читаемый код под задачу
- способность пошагово объяснять, **что** и **почему** ты делаешь

Эта глава поможет структурировать подготовку: какие темы важны, какие типы задач бывают и как к ним подходить на собеседовании.

---

## 26.1. Какие задачи дают фронтендерам

На практике встречаются 3 основных формата:

1. **Классические алгоритмические задачи**
   - работа со строками (реверс, поиск подстроки, палиндромы)
   - работа с массивами (фильтрация, группировка, сортировка, агрегация)
   - простые задачи на стек/очередь/хеш‑таблицу
2. **Прикладные задачи, близкие к реальному фронтенду**
   - нормализация ответа API
   - агрегация данных по ключу
   - подготовка структуры для рендера (например, из списка в дерево)
3. **Мини‑кейсы с DOM и асинхронностью**
   - реализация `debounce` / `throttle`
   - простая очередь запросов
   - управление параллельными промисами

Важно: хорошее собеседование почти всегда даёт задачи, которые **можно** решить за 10–20 минут, если уверенно владеешь базой JS.

---

## 26.2. База, без которой тяжело

**1. Массивы и их методы**

Обязательно нужно уметь использовать и комбинировать:

- `map`, `filter`, `reduce`, `some`, `every`, `find`, `sort`
- `flat`, `flatMap`

Пример типовой задачи:

> Дан массив пользователей, нужно посчитать, сколько активных пользователей из каждой страны.

Подход:

- пройтись по массиву
- отфильтровать по признаку активности
- собрать статистику в объект по ключу `country`

**2. Объекты, `Map` и `Set`**

Во многих задачах выгодно перейти от «поиска по массиву» к хранению данных в хеш‑структуре:

- `Set` — когда важен факт наличия
- `Map` — когда нужен словарь с любыми ключами

Это сразу уменьшает сложность с \(O(n^2)\) до \(O(n)\) в задачах вида «поиск пар», «подсчёт уникальных элементов».

**3. Строки**

Типичные операции:

- разбиение (`split`)
- слияние (`join`)
- обрезка (`trim`)
- поиск подстрок (`includes`, `indexOf`)
- разворот, нормализация регистра

**4. Рекурсия**

Она нужна не ради самой рекурсии, а для задач с иерархиями:

- дерево каталогов
- вложенные комментарии
- преобразование плоского списка в дерево и обратно

---

## 26.3. Структурированный подход к решению

Хороший кандидат не «набрасывается» писать код, а идёт по шагам.

**Шаг 1. Пересказать задачу своими словами**

Проверяем, что вы поняли постановку:

- что на входе?
- что нужно вернуть?
- есть ли ограничения по времени/памяти?
- важен ли порядок элементов?

**Шаг 2. Обсудить наивное решение**

Сначала предложить максимально простое решение, даже если оно не идеально по сложности.

- «Можно пройтись двойным циклом — будет \(O(n^2)\). Для небольших входных данных это допустимо. Потом попробуем улучшить.»

**Шаг 3. Улучшить решение**

Переходим к использованию подходящих структур:

- храним уже встреченные значения в `Set`
- считаем частоты в `Map`
- кешируем промежуточные вычисления

**Шаг 4. Проговорить сложность**

На уровне интуиции достаточно:

- линейная \(O(n)\)
- квадратичная \(O(n^2)\)
- логарифмическая \(O(\log n)\)

**Шаг 5. Пройтись по примерам**

Обязательно прогоните решение:

- на типичном кейсе
- на граничных случаях (пустой массив, один элемент, дубликаты)

---

## 26.4. Типичные паттерны задач

### 1) Поиск и фильтрация

- найти все элементы, удовлетворяющие условию
- найти первый/последний подходящий элемент
- разделить список на группы (например, по статусу)

Обычно решается комбинациями `filter`, `find`, `reduce`.

### 2) Трансформация данных

Примеры:

- «из массива объектов собрать словарь по id»
- «сгруппировать данные по дате»
- «подготовить структуру для дерева навигации»

Почти всегда ключ — аккуратный `reduce` + понимание, какие структуры (объект, `Map`, массив массивов) уместны.

### 3) Работа со строками

- нормализовать ввод пользователя (обрезать пробелы, привести к нижнему регистру)
- посчитать количество вхождений подстроки
- проверить палиндром

Важно уметь решать без лишних аллокаций и с понятной логикой.

### 4) Задачи на пары и комбинации

Типичный пример:

> Есть массив чисел, нужно найти пару, сумма которых равна `target`.

Наивное решение — двойной цикл \(O(n^2)\). Оптимальное — пройти один раз и хранить в `Set` дополнения `target - current`.

### 5) Рекурсивные структуры

Примеры:

- обход дерева в глубину/ширину
- поиск элемента в иерархии
- подсчёт агрегатов (количество потомков, суммарный размер)

---

## 26.5. Асинхронные и фронтенд‑специфичные задачи

Фронтенд‑интервью всё чаще включают задачи, близкие к реальной жизни:

- **`debounce`**: вызывать функцию только после паузы в серии событий (например, после того как пользователь закончил ввод)
- **`throttle`**: ограничить частоту вызова функции (например, при скролле)
- **очередь запросов**: не больше N параллельных запросов, остальные в очереди
- **ретраи**: повторить запрос несколько раз при ошибке сети

Такие задачи проверяют:

- знание `setTimeout`, `Promise`, `async/await`
- понимание очереди микрозадач/макрозадач на базовом уровне
- умение писать аккуратный, управляемый код без утечек и гонок

---

## 26.6. Как тренироваться эффективно

- **Выбирай задачи ближе к фронтенду**, а не абстрактным графам без контекста.
- **Решай вслух**: проговаривай рассуждения, как будто ты уже на собеседовании.
- **Возвращайся к задачам через время** — важно не запомнить решение, а отработать мышление.
- **Пробуй разные реализации**: с `for`, с методами массивов, через `Map`/`Set`.
- **Разбирай чужие решения**, но только после попытки решить самостоятельно.

Важнее всего не количество решённых задач, а умение **объяснить** своё решение спокойно и структурированно.

---

## Вопросы на собеседовании

1. Какие структуры данных вы чаще всего используете во фронтенде и почему?
2. Как вы оцениваете сложность вашего решения?
3. Когда стоит использовать `Map`/`Set`, а не обычные объекты/массивы?
4. Чем наивное решение отличается от оптимизированного в задаче N?
5. Как бы вы реализовали `debounce` или `throttle`?
6. Как подойти к задаче, которую вы не знаете, как решать с первого взгляда?

---

## Key Takeaways

- Алгоритмические задачи для фронтенда — это проверка мышления и владения базовым JS, а не олимпиадное программирование.
- Главное — структурированный подход: понять задачу, предложить простое решение, затем улучшить и прогнать по примерам.
- Умение работать с массивами, объектами, `Map`/`Set`, строками и рекурсией покрывает 80% типичных задач.
- Асинхронность и утилиты уровня `debounce`/`throttle` — частый и очень практичный тип задач.
- Эффективная подготовка — это регулярная практика с проговариванием решений и анализом сложности.

---

Дальше мы поговорим о том, как грамотно рассказывать про свой опыт и проекты: какие истории готовить, как структурировать ответы и как показать работодателю именно тот уровень, на который вы претендуете.
