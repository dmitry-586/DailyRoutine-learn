# Глава 2. Архитектура браузера

Браузер — это не просто «программа для открытия сайтов». Это сложная многопроцессная система, ближе к маленькой операционной системе, чем к «окошку для сайтов». Внутри параллельно и независимо друг от друга работают несколько подсистем, и каждая из них влияет на то, как ведёт себя ваш код и ваш интерфейс:

- загружает данные из сети
- исполняет JavaScript
- рисует интерфейс
- изолирует вкладки друг от друга
- защищает пользователя от вредоносных страниц

Для фронтенд-разработчика понимание его внутренней структуры — это не академическая теория, а практический инструмент. Как только вы начинаете видеть, _в каком именно процессе_ что-то происходит, многие «магические» баги и лаги становятся объяснимыми:

- для оптимизации производительности
- для предотвращения ошибок рендеринга
- для осмысленной работы с потоками, событиями, памятью
- для уверенных ответов на собеседовании Senior/Middle уровня

---

## 2.1. Многопроцессная модель браузеров

Раньше браузеры были однопроцессными: один большой процесс делал буквально всё. Любая утечка памяти или бесконечный цикл на одной вкладке «ронял» весь браузер. Современные движки (Chrome/Blink, Firefox/Gecko, Safari/WebKit) используют многопроцессную архитектуру.

### Основная идея

Браузер разделяет работу на независимые процессы:

- падение вкладки не ломает всю программу
- повышается безопасность (sandboxing)
- повышается производительность (параллелизм)

Браузер — это, по сути, маленькая операционная система: у него есть «ядро» (главный процесс), «пользовательские приложения» (рендереры вкладок), «драйверы» (GPU‑процесс, аудио‑процессы), «системные службы» (сетевой процесс).

### Какие процессы выделяют браузеры

В Chrome обычно есть:

**1. Browser Process (главный процесс)**

Отвечает за:

- управление окнами и вкладками
- сетевой стек
- доступ к диску
- навигацию между страницами

Он не рендерит сайт. Он — администратор, который распределяет задачи другим процессам и принимает «системные» решения: какую вкладку выгрузить из памяти, какую перезагрузить, какие запросы отменить, какие разрешения (камера, микрофон, геолокация) выданы той или иной странице.

**2. Renderer Processes (процессы рендеринга)**

В них происходит:

- парсинг HTML
- выполнение JavaScript (V8 для Chrome, SpiderMonkey для Firefox)
- layout, paint, composite

Каждый такой процесс изолирован в песочнице. В нём исполняется ваш JavaScript.

Для разработчика это означает простую вещь: **весь код приложения живёт именно здесь**. Любые подвисания, долгие циклы, тяжёлые вычисления и утечки памяти происходят внутри renderer‑процесса и напрямую бьют по UX конкретной вкладки, но не всего браузера.

**Почему рендеринг изолирован в отдельном процессе?**

Чтобы вредный скрипт из одной вкладки не мог:

- прочитать память другой вкладки
- получить доступ к файлам
- получить доступ к камере или микрофону
- «уронить» весь браузер

Изоляция страниц — важнейшая часть современной безопасности. Она отвечает на популярный вопрос «почему мой сайт не может просто так прочитать данные другого сайта» и объясняет, почему даже при RCE‑уязвимостях браузер старается ограничить ущерб пределами одного процесса.

**3. GPU Process**

Нужен для:

- аппаратного ускорения
- компоновки слоёв (compositor)
- WebGL
- рендеринга CSS-трансформаций

Это важно понимать для оптимизации:

- transform и opacity рендерятся на GPU
- top/left изменяют layout → CPU → Reflow

Разница в производительности огромная.

**4. Network Service Process**

Полностью отвечает за:

- DNS резолвинг
- HTTP/HTTPS
- кэширование
- сокеты
- работу с cookies

С рендерером взаимодействует через IPC.

**5. Utility Processes**

Отдельные процессы для специфических задач:

- аудио
- видео декодирование
- PPAPI-плагины
- шрифты
- WebAuthn

**Почему так сделано?**

1. Безопасность через sandboxing. Renderer не имеет прямого доступа к файловой системе, только через IPC.
2. Изоляция вкладок. Одна «плохая» страница не тормозит остальные.
3. Скорость. Работа параллелится.

---

## 2.2. Навигация: что происходит при вводе URL

Когда вы нажимаете Enter — запускается строго определённый pipeline, похожий на работу аэропорта:

**Подробная последовательность:**

1. Пользователь вводит URL
2. Браузер определяет, нужно ли создавать новый процесс рендеринга
3. Browser Process вызывает Network Service
4. Выполняется DNS lookup
5. Устанавливается TCP/TLS соединение
6. Отправляется HTTP-запрос
7. Получается ответ с HTML
8. Browser Process создаёт Renderer Process (если нужен)
9. HTML передаётся в Renderer
10. Renderer начинает парсинг:
    - строит DOM
    - строит CSSOM
    - создаёт render tree
    - выполняет JS
11. Renderer отправляет GPU-командам раскладку и слои
12. Страница отображается

**When does navigation commit?**

Начало загрузки ≠ видимая страница. Commit происходит после получения первых байтов HTML.

---

## 2.3. Site Isolation

После уязвимостей Spectre/Meltdown (2018) браузеры усилили безопасность.

Сегодня: каждая вкладка не только в своём процессе — но и каждая вкладка разделена по «сайтам» (origin).

Если в одной вкладке есть iframe с чужим origin — этот iframe рендерится в отдельном процессе.

Это замедляет браузер? Иногда — да. Но даёт огромный скачок безопасности.

---

## 2.4. Предварительные оптимизации загрузки

Браузеры умеют предсказывать, какие ресурсы вам понадобятся.

### DNS Prefetch

```html
<link rel="dns-prefetch" href="//cdn.example.com" />
```

Заранее выполняет DNS-запрос.

### Preconnect

```html
<link rel="preconnect" href="https://fonts.googleapis.com" />
```

Заранее устанавливает TCP/TLS handshake. Это мощная оптимизация для шрифтов.

### Prefetch

```html
<link rel="prefetch" href="/next-page.html" />
```

Загружает данные, которые возможно понадобятся позже. Prefetch не блокирует загрузку основного контента.

### Preload

```html
<link rel="preload" href="/main.css" as="style" />
```

Говорит браузеру: «этот ресурс точно критичен». Без preload браузер узнаёт о CSS только после парсинга HTML.

Отличие prefetch и preload — частый вопрос на собеседовании.

---

## 2.5. Жизненный цикл страницы

**DOMContentLoaded**

- HTML загружен и распарсен
- CSS и картинки могут ещё грузиться
- JS (не async/defer) уже отработал

**load**

- Загружено абсолютно всё, включая картинки
- Страница полностью готова

**visibilitychange**

- Пользователь переключил вкладку
- Важное событие для аналитики и оптимизации

---

## 2.6. IPC (Inter-Process Communication)

Процессы браузера общаются между собой не напрямую, а через IPC.

Это критично для понимания:

- Почему eval() запрещён в некоторых режимах
- Почему расширения работают изолированно
- Почему DOM не доступен в Web Worker

Web Worker — другой процесс, у которого нет доступа к DOM, потому что DOM — это структура, живущая в рендерер-процессе.

---

## Вопросы на собеседовании

### 1. Опишите архитектуру современного браузера

Браузер работает как мини-операционная система с несколькими процессами:

- Browser Process — управляет вкладками и навигацией
- Renderer Processes — парсинг, JS, layout, paint
- GPU Process — композиция слоёв
- Network Process — сетевые запросы

### 2. Что такое Renderer Process и что в нём происходит?

Процесс рендеринга отвечает за DOM, CSSOM, JavaScript и layout. В нём исполняется ваш JavaScript.

### 3. Почему Chrome использует многопроцессную модель?

- стабильность (падение вкладки не ломает браузер)
- безопасность (sandboxing, изоляция)
- производительность (параллелизм)

### 4. Объясните разницу между preconnect, prefetch и preload

- preconnect — заранее устанавливает TCP/TLS соединение
- prefetch — загружает ресурсы на будущее (не блокирует)
- preload — загружает критический ресурс сейчас (блокирует)

### 5. Что происходит после ввода URL в адресную строку?

См. раздел 2.2 — полная последовательность от DNS до рендеринга.

### 6. Как работает sandbox в браузере?

Renderer не имеет прямого доступа к файлам, сети, аппаратуре — только через IPC с главным процессом.

### 7. Какие браузерные процессы отвечают за JS и за GPU?

- JavaScript исполняется в Renderer Process
- GPU-операции выполняются в GPU Process

### 8. Что делает Network Process?

Отвечает за DNS, HTTP/HTTPS, кэширование, сокеты, cookies.

---

## Key Takeaways

- Браузер работает как мини-операционная система с кучей процессов
- Главный процесс управляет вкладками
- Процесс рендеринга отвечает за DOM, CSSOM, JavaScript и layout
- GPU-процесс отвечает за отрисовку и композицию слоёв
- Site Isolation изолирует разные origin в разных процессах ради безопасности
- Preload/prefetch/preconnect помогают управлять приоритетами загрузки
- Веб-страница проходит через события DOMContentLoaded → load → остальные

---

В следующей главе мы опустимся ещё на уровень ниже и подробно проследим путь от HTML до пикселей на экране: разберём DOM, CSSOM, layout, paint, composite и поймём, какие решения в коде делают интерфейс плавным, а какие — мучительно «дёрганым».
