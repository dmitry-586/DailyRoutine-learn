# Глава 26. Архитектуры фронтенда

Если паттерны — это локальные решения, то архитектура — это каркас всего приложения. На уровне Middle+ от разработчика ожидают понимание не только как писать код, но и как организовать систему в целом.

На собеседованиях эту главу используют, чтобы проверить:

- системное мышление
- опыт работы с большими кодовыми базами
- способность принимать архитектурные решения

---

## 26.1. MVC, MVP, MVVM

Эти архитектуры пришли во фронтенд из классического UI-разработки.

### MVC (Model – View – Controller)

**Роли:**

- Model — данные и бизнес-логика
- View — отображение
- Controller — обработка действий пользователя

**Проблемы во фронтенде:**

- сильная связность
- сложно масштабировать
- плохо ложится на React

### MVP (Model – View – Presenter)

**Presenter:**

- получает данные из Model
- подготавливает их для View

View становится максимально «тупой».

### MVVM (Model – View – ViewModel)

**ViewModel:**

- состояние
- логика отображения
- биндинги

**Часто ассоциируется с:**

- Angular
- Vue

### Вывод

React формально не относится ни к одной из этих архитектур, но заимствует идеи MVVM.

---

## 26.2. Flux, Redux, CQRS

### Flux

Архитектура от Facebook.

**Принципы:**

- однонаправленный поток данных
- actions → dispatcher → store → view

### Redux

Упрощённый Flux:

UI → Action → Reducer → Store → UI

**Преимущества:**

- предсказуемость
- логируемость
- time-travel debugging

### CQRS (Command Query Responsibility Segregation)

**Разделение:**

- команд (изменяют состояние)
- запросов (читают состояние)

**Во фронтенде проявляется через:**

- action creators (команды)
- selectors (запросы)

---

## 26.3. Microfrontend и модульная архитектура

Microfrontend — разбиение фронтенда на независимые части.

### Когда это нужно

- большие команды
- независимые релизы
- разные технологические стеки

### Подходы

- Module Federation (Webpack)
- iframe
- Web Components

### Проблемы

- сложность интеграции
- дублирование зависимостей
- рост сложности DevOps

---

## 26.4. Clean Architecture во фронтенде

**Идея:** бизнес-логика не зависит от UI.

### Слои

1. Domain — бизнес-логика
2. Use Cases — сценарии использования
3. Adapters — адаптеры к внешним системам
4. UI — интерфейс

### Преимущества

- тестируемость
- переиспользуемость
- независимость от фреймворка

### Минусы

- оверхед для небольших проектов
- сложность для простых задач

### Кейс-стади

**Задача:** Большое SPA с сложной логикой, большим количеством API, несколькими командами.

**Решение:**

- feature-based структура
- TanStack Query для server state
- Redux Toolkit для глобального состояния
- модульные слои (domain / ui / api)

---

## 26.5. FSD (Feature-Sliced Design)

Feature-Sliced Design (FSD) — архитектурный подход, популярный во фронтенд‑сообществе, особенно вокруг крупных React‑приложений.

### Основная идея

- **делить проект по фичам**, а не по техническим слоям (components, reducers, services…);
- каждая фича изолирует UI, бизнес‑логику и работу с API;
- сверху вниз — слои (app / processes / pages / features / entities / shared).

Вместо:

- `components/`, `store/`, `services/`

получается:

- `features/auth/`,
- `features/cart/`,
- `entities/user/`,
- `shared/ui/Button/` и т.д.

### Что это даёт команде

- проще онбординг: фичи легко найти, зависимости явнее;
- ослабление связей между областями приложения;
- локализация бизнес‑логики рядом с UI‑кейcами;
- меньше «божественных модулей» вида `components/common/` с сотнями файлов.

FSD хорошо сочетается с:

- TanStack Query (server state на уровне feature/entity);
- Redux Toolkit / Zustand для глобальных кусков состояния;
- модульной архитектурой (слои domain/ui/api мапятся на entities/features).

---

## 26.6. Evolutionary / Evolution Design во фронтенде

На практике архитектура фронтенда редко проектируется «идеально» с нуля. **Evolutionary Design** исходит из того, что:

- требования будут меняться;
- команда будет расти;
- стек обновится (React 18 → 19, Next.js 12 → 16 и т.д.).

### Принципы эволюционного дизайна

- начинать с простого (pages + components);
- вводить слои и FSD **по мере боли**, а не «сразу всё»;
- регулярно рефакторить узкие места (god‑components, общие утилиты без границ);
- защищать архитектурные решения линтерами и автоматическими проверками.

Хороший ответ на собеседовании:

- не «я всегда делаю Clean Architecture/FSD»;
- а «мы начали с простой структуры, потом вынесли общие сущности в entities, фичи в features, ввели TanStack Query и Redux только когда количество экранов и сценариев выросло».

Идея: архитектура фронтенда — это **не статичная схема**, а живой артефакт, который развивается вместе с продуктом и командой.

---

## Вопросы на собеседовании

### 1. Чем MVC отличается от MVVM?

MVC — Controller управляет. MVVM — ViewModel связывает через биндинги.

### 2. Можно ли считать React MVC-фреймворком?

Нет, React ближе к MVVM, но не является строгой реализацией.

### 3. Что такое Flux?

Архитектура с однонаправленным потоком данных от Facebook.

### 4. Почему Redux однонаправленный?

Предсказуемость, логируемость, простота отладки.

### 5. Когда оправданы микрофронтенды?

Большие команды, независимые релизы, разные технологические стеки.

### 6. Какие проблемы у microfrontend?

Сложность интеграции, дублирование зависимостей, рост сложности DevOps.

### 7. Что такое Clean Architecture?

Разделение на слои: Domain, Use Cases, Adapters, UI. Бизнес-логика не зависит от UI.

### 8. Когда архитектура — это оверхед?

Для небольших проектов, простых задач, когда сложность не оправдана.

---

## Key Takeaways

- MVC/MVP/MVVM — классические паттерны, адаптированные под фронтенд
- Flux/Redux — однонаправленный поток данных
- Microfrontend — для больших команд и независимых релизов
- Clean Architecture — для сложных проектов с бизнес-логикой
- Архитектура должна соответствовать масштабу проекта
- Feature-based структура — современный подход

---

В следующей части мы переключим фокус на производительность и безопасность: разберём, как измерять и улучшать скорость работы приложения и как защитить его от типичных уязвимостей реального веба.
