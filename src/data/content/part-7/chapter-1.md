# Глава 21. Паттерны проектирования

Паттерны проектирования — это не «классика ради классики», а язык общения между разработчиками. На собеседованиях важно не заученное определение, а понимание:

- какую проблему решает паттерн
- какие есть альтернативы
- какие у него ограничения

---

## 21.1. SOLID-принципы

SOLID — набор принципов объектно-ориентированного проектирования, применимых и во фронтенде.

### S — Single Responsibility

Модуль должен иметь одну причину для изменения.

**Плохо:**

```typescript
class UserService {
  fetchUser() {}
  renderUser() {}
}
```

**Хорошо:**

- сервис для данных
- компонент для UI

### O — Open / Closed

Сущности должны быть открыты для расширения, но закрыты для изменения.

### L — Liskov Substitution

Подтипы должны корректно заменять базовый тип.

### I — Interface Segregation

Много маленьких интерфейсов лучше одного большого.

### D — Dependency Inversion

Зависеть от абстракций, а не от реализаций.

---

## 21.2. Классические паттерны

### Singleton

Гарантирует один экземпляр.

```typescript
class Store {
  private static instance: Store
  static getInstance() {
    if (!Store.instance) {
      Store.instance = new Store()
    }
    return Store.instance
  }
}
```

⚠️ Во фронтенде часто заменяется контекстом React.

### Factory

Создаёт объекты без знания конкретного класса.

```typescript
function createUser(type: 'admin' | 'user') {
  return type === 'admin' ? new Admin() : new User()
}
```

### Observer

Реакция на изменения состояния.

**Пример:**

- EventEmitter
- RxJS
- Redux (через подписки)

### Strategy

Выбор алгоритма во время выполнения.

```javascript
const strategies = {
  asc: (a, b) => a - b,
  desc: (a, b) => b - a,
}
```

### Facade

Простой интерфейс над сложной системой.

### Proxy

Контролирует доступ к объекту.

```javascript
const proxy = new Proxy(target, {
  get(target, prop) {
    return target[prop]
  },
})
```

---

## 21.3. Фронтенд-архитектура модулей

### Feature-based структура

```
/features
  /auth
  /profile
  /cart
```

Каждая фича содержит всё необходимое: компоненты, логику, стили, тесты.

### Layered архитектура

- UI — компоненты
- domain — бизнес-логика
- data — работа с API

### Anti-patterns

- god-components (огромные компоненты)
- бизнес-логика в UI
- тесная связность модулей

---

## Вопросы на собеседовании

### 1. Что такое SOLID?

Набор принципов проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

### 2. Применимы ли паттерны GoF во фронтенде?

Да, но адаптированы под функциональный подход и компонентную модель.

### 3. Singleton — зло?

Во фронтенде часто заменяется Context API. Может быть полезен для глобальных сервисов.

### 4. Observer в React — где?

Redux (подписки), EventEmitter, RxJS, сам React (подписка на изменения).

### 5. Strategy — пример из UI?

Сортировка списков, валидация форм, алгоритмы отображения данных.

### 6. Что такое Facade?

Упрощённый интерфейс над сложной системой. Скрывает сложность.

### 7. Какие архитектурные анти-паттерны знаете?

God components, бизнес-логика в UI, тесная связность, дублирование кода.

---

## Key Takeaways

- SOLID применим во фронтенде, но адаптирован под компонентную модель
- Паттерны решают конкретные проблемы, не использовать везде
- Singleton во фронтенде часто заменяется Context
- Observer — основа реактивности в React/Redux
- Feature-based структура — современный подход к организации кода
- Anti-patterns важнее знать, чем паттерны

---

**Часть VII. Архитектура и проектирование**
