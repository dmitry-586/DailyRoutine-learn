# Глава 25. Паттерны проектирования

Паттерны проектирования — это не «классика ради классики», а язык общения между разработчиками. На собеседованиях важно не заученное определение, а понимание:

- какую проблему решает паттерн
- какие есть альтернативы
- какие у него ограничения

---

## 25.1. SOLID-принципы

SOLID — набор принципов объектно-ориентированного проектирования, применимых и во фронтенде.

### S — Single Responsibility

Модуль должен иметь одну причину для изменения.

**Плохо:**

```typescript
class UserService {
  fetchUser() {}
  renderUser() {}
}
```

**Хорошо:**

- сервис для данных
- компонент для UI

### O — Open / Closed

Сущности должны быть открыты для расширения, но закрыты для изменения.

### L — Liskov Substitution

Подтипы должны корректно заменять базовый тип.

### I — Interface Segregation

Много маленьких интерфейсов лучше одного большого.

### D — Dependency Inversion

Зависеть от абстракций, а не от реализаций.

---

## 25.2. Классические паттерны

### Singleton

Гарантирует один экземпляр.

```typescript
class Store {
  private static instance: Store
  static getInstance() {
    if (!Store.instance) {
      Store.instance = new Store()
    }
    return Store.instance
  }
}
```

⚠️ Во фронтенде часто заменяется контекстом React.

### Factory

Создаёт объекты без знания конкретного класса.

```typescript
function createUser(type: 'admin' | 'user') {
  return type === 'admin' ? new Admin() : new User()
}
```

### Observer

Реакция на изменения состояния.

**Пример:**

- EventEmitter
- RxJS
- Redux (через подписки)

### Strategy

Выбор алгоритма во время выполнения.

```javascript
const strategies = {
  asc: (a, b) => a - b,
  desc: (a, b) => b - a,
}
```

### Facade

Простой интерфейс над сложной системой.

### Proxy

Контролирует доступ к объекту.

```javascript
const proxy = new Proxy(target, {
  get(target, prop) {
    return target[prop]
  },
})
```

---

## 25.3. Фронтенд-архитектура модулей

### Feature-based структура

```
/features
  /auth
  /profile
  /cart
```

Каждая фича содержит всё необходимое: компоненты, логику, стили, тесты.

### Layered архитектура

- UI — компоненты
- domain — бизнес-логика
- data — работа с API

### Anti-patterns

- god-components (огромные компоненты)
- бизнес-логика в UI
- тесная связность модулей

---

## Вопросы на собеседовании

### 1. Что такое SOLID?

Набор принципов проектирования: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

### 2. Применимы ли паттерны GoF во фронтенде?

Да, но адаптированы под функциональный подход и компонентную модель.

### 3. Singleton — зло?

Во фронтенде часто заменяется Context API. Может быть полезен для глобальных сервисов.

### 4. Observer в React — где?

Redux (подписки), EventEmitter, RxJS, сам React (подписка на изменения).

### 5. Strategy — пример из UI?

Сортировка списков, валидация форм, алгоритмы отображения данных.

### 6. Что такое Facade?

Упрощённый интерфейс над сложной системой. Скрывает сложность.

### 7. Какие архитектурные анти-паттерны знаете?

God components, бизнес-логика в UI, тесная связность, дублирование кода.

---

## Key Takeaways

- SOLID применим во фронтенде, но адаптирован под компонентную модель
- Паттерны решают конкретные проблемы, не использовать везде
- Singleton во фронтенде часто заменяется Context
- Observer — основа реактивности в React/Redux
- Feature-based структура — современный подход к организации кода
- Anti-patterns важнее знать, чем паттерны

---

## 25.4. Практические сценарии и самопроверка

**Практические сценарии:**

- можешь ли на реальном примере из своего (или воображаемого) проекта показать «god‑component» и предложить, как его разбить по принципу Single Responsibility;
- можешь ли объяснить, где в твоём текущем стеке уже используются Observer и Strategy (Redux, события, выбор алгоритма сортировки/валидации);
- можешь ли привести пример, когда Singleton/глобальное состояние во фронте реально навредили (тестируемости, SSR, изоляции фич), и как бы ты это сейчас спроектировал иначе.

**Самопроверка:**

Если ты:

- можешь на собеседовании не только дать определение SOLID, но и привязать каждый принцип к конкретным фронтенд‑сценариям;
- отличаешь «паттерн ради паттерна» от реальной пользы (и можешь объяснить, почему, например, не везде нужен Singleton или Factory);
- видишь в коде архитектурные анти‑паттерны (god‑components, бизнес‑логика в UI, жёсткая связность) и умеешь предложить план их постепенного исправления,

то с точки зрения паттернов и базовой архитектуры ты уже мыслишь как уверенный Middle/Strong Middle.

---

В следующей главе мы поговорим о более формальных архитектурных подходах — от Clean Architecture до слоёных и модульных архитектур — и разберём, когда они действительно нужны, а когда избыточны для фронтенда.
