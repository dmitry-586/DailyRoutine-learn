# Глава 19. Архитектура больших приложений

На этом этапе React перестаёт быть «набором компонентов» и становится платформой для построения сложных систем. Главный вызов больших SPA — управление состоянием, зависимостями и потоками данных.

На собеседованиях эту главу используют, чтобы понять:

- мыслишь ли ты архитектурно
- умеешь ли масштабировать приложение
- понимаешь ли trade-off'ы разных подходов

---

## 19.1. Redux Toolkit

Redux Toolkit (RTK) — современный и рекомендуемый способ использования Redux. Redux без RTK сегодня считается устаревшей практикой.

### Ключевые идеи Redux

- единое хранилище (single source of truth)
- иммутабельные обновления
- однонаправленный поток данных

### Проблемы «старого» Redux

- слишком много boilerplate
- ручная иммутабельность
- сложные async-сценарии

RTK решает эти проблемы.

### createSlice

```javascript
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value++
    },
  },
})

export const { increment } = counterSlice.actions
export default counterSlice.reducer
```

Под капотом используется Immer, поэтому мутации выглядят «мутабельными», но остаются иммутабельными.

### Async logic: createAsyncThunk

```javascript
export const fetchUsers = createAsyncThunk('users/fetch', async () => {
  const res = await fetch('/api/users')
  return res.json()
})

// В компоненте
const { data, isLoading } = useSelector((state) => state.users)
dispatch(fetchUsers())
```

### Когда Redux оправдан

- сложные бизнес-процессы
- много источников данных
- глобальное состояние, важное для всего приложения
- нужен time-travel debugging
- большая команда, нужна предсказуемость

### Когда Redux НЕ нужен

- простое локальное состояние
- небольшие приложения
- только server state (используйте TanStack Query)

---

## 19.2. Альтернативные state-менеджеры

### MobX

- реактивность
- минимум boilerplate
- магия под капотом

Плюс: быстро начать

Минус: сложнее отлаживать, менее предсказуемо

### Zustand

```javascript
const useStore = create((set) => ({
  count: 0,
  inc: () => set((state) => ({ count: state.count + 1 })),
}))
```

- минималистичный
- отлично подходит для средних проектов
- простота использования

### Recoil

- атомарное состояние
- экспериментальный
- плотная интеграция с React

### Сравнение

**Redux Toolkit:**

- Когда использовать: сложная логика, большие команды

**MobX:**

- Когда использовать: высокая динамика, быстрое прототипирование

**Zustand:**

- Когда использовать: компактные приложения, средние проекты

**Recoil:**

- Когда использовать: эксперименты, атомарное состояние

---

## 19.3. TanStack Query

TanStack Query (ранее React Query) — это не state manager, а инструмент для server state.

### Server state vs Client state

**Server state:**

- кэшируется
- может устаревать
- синхронизируется с сервером
- нужна обработка loading/error

**Client state:**

- локальное состояние UI
- не синхронизируется с сервером
- управляется через useState/useReducer

### Пример

```javascript
const { data, isLoading, error } = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  staleTime: 5000,
})
```

### Что решает TanStack Query

- кэширование запросов
- автоматический refetch
- loading / error states
- дедупликацию запросов
- оптимистичные обновления
- инвалидацию кэша

### Мутации

```javascript
const mutation = useMutation({
  mutationFn: createUser,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['users'] })
  },
})
```

### Когда использовать

Почти всегда, если есть API. TanStack Query идеален для работы с server state.

### Паттерны TanStack Query (из правил пользователя)

1. Фабрика ключей: Централизуй создание ключей через queryKeys.ts
2. Кастомные хуки: Инкапсулируй каждый запрос в хук useEntityOperation
3. Оптимистичные обновления: onMutate + setQueryData
4. Предзагрузка: prefetchQuery при наведении
5. Селекторы: select в useQuery для подписки только на нужные данные
6. Точечная инвалидация: через predicate, а не всю группу
7. Глобальная обработка ошибок: на уровне QueryClient
8. Бесконечные списки: useInfiniteQuery для пагинации

---

## 19.4. Архитектурные паттерны React

### Render Props

```jsx
<DataProvider>{(data) => <List data={data} />}</DataProvider>
```

Редко используется сегодня, но важно знать для понимания паттернов.

### HOC (Higher-Order Components)

```jsx
const withAuth = (Component) => (props) =>
  isAuth ? <Component {...props} /> : <Login />
```

**Минусы:**

- сложная вложенность
- проблемы с типами
- сложнее отлаживать

Сегодня заменяется хуками.

### Compound Components

```jsx
<Tabs>
  <Tabs.List />
  <Tabs.Panel />
</Tabs>
```

Используется в UI-библиотеках. Позволяет создавать гибкие API компонентов.

### Практические рекомендации

- разделяй server и client state
- не храни всё в Redux
- начинай с простого (useState → Context → Redux)
- архитектура — это эволюция, а не догма
- используй TanStack Query для server state
- локальное состояние — в компонентах
- глобальное состояние — только когда действительно нужно

---

## 19.5. SolidJS: альтернативный взгляд на реактивность

SolidJS — это современный UI‑фреймворк, который по синтаксису очень похож на React (JSX, компоненты), но под капотом использует **сигналы и fine‑grained реактивность**, а не Virtual DOM.

### Ключевые отличия от React

- нет Virtual DOM — Solid не делает diff «деревьев» при каждом рендере;
- используется **граф зависимостей** из сигналов и вычисляемых значений;
- при изменении состояния пересчитываются только те участки, которые на него реально подписаны;
- компоненты вызываются один раз (как фабрики), дальше обновляется только реактивная граф‑сеть.

**Пример на уровне идей:**

В React:

- изменение `setCount` приводит к повторному вызову компонента;
- React сравнивает Virtual DOM и обновляет реальный DOM.

В Solid:

- `createSignal` создаёт реактивное значение;
- компоненты в JSX подписываются на сигналы;
- при изменении сигнала Solid точечно обновляет нужные узлы DOM без повторного вызова компонента.

### Почему Solid часто «быстрее на бумаге»

- меньше работы по сравнению Virtual DOM‑diff;
- нет постоянных пере‑вызовов компонентных функций;
- реактивность ближе к тому, как работают Svelte/Vue.

### Где Solid полезен фронтендеру

- как модель **fine‑grained реактивности**, которую полезно понимать даже работая в React;
- как альтернатива для проектов, где важна максимальная производительность и мелкозернисткий контроль обновлений;
- как источник идей: сигналы уже приходят и в React‑мир (например, React Forget, signals в разных библиотеках).

На собеседовании Solid могут спрашивать:

- как пример **другой реактивной модели**;
- как повод обсудить Virtual DOM vs signals и разные способы обновления UI.

---

## Вопросы на собеседовании

### 1. Когда нужен Redux, а когда нет?

Нужен: сложная логика, много источников данных, большая команда. Не нужен: простое состояние, небольшие приложения.

### 2. Почему Redux Toolkit лучше классического Redux?

Меньше boilerplate, автоматическая иммутабельность через Immer, встроенная поддержка async через createAsyncThunk.

### 3. MobX vs Redux — различия?

MobX — реактивность, меньше кода. Redux — предсказуемость, явные обновления, лучше для больших команд.

### 4. Что такое server state?

Данные, приходящие с сервера: кэшируются, могут устаревать, требуют синхронизации.

### 5. Зачем нужен TanStack Query?

Управление server state: кэширование, refetch, обработка loading/error, дедупликация запросов.

### 6. HOC vs hooks?

Hooks проще, лучше типизация, меньше вложенности. HOC устарели, но важно знать паттерн.

### 7. Что такое compound components?

Паттерн, где компоненты работают вместе через контекст, создавая гибкий API.

### 8. Как избежать глобального состояния?

Локальное состояние в компонентах, Context для темы/языка, TanStack Query для server state, Redux только когда действительно нужно.

---

## Key Takeaways

- Redux Toolkit — современный способ работы с Redux
- Разделяй server state и client state
- TanStack Query идеален для server state
- Zustand — хорошая альтернатива для средних проектов
- Начинай с простого, усложняй по необходимости
- Архитектура — эволюция, а не догма
- Compound Components — гибкий паттерн для UI-библиотек
- HOC устарели, но важно понимать паттерн

---

В следующей главе мы выйдем за рамки чистого клиентского React и посмотрим на то, как он работает вместе с сервером: SSR, SSG, гидратация и современные фреймворки вроде Next.js.
