# Глава 18. Хуки и управление состоянием

Хуки — это механизм, который позволил React отказаться от классов и сделать логику компонентов компонуемой и переиспользуемой.

На собеседованиях хуки — одна из самых частых тем: ошибки в useEffect, неправильные зависимости и лишние ререндеры быстро показывают реальный уровень кандидата.

---

## 18.1. useState и useEffect

### useState

```javascript
const [count, setCount] = useState(0)
```

**Особенности:**

- асинхронное обновление
- вызывает повторный рендер
- обновления могут быть батчены (группироваться)

### Функциональное обновление

```javascript
setCount((prev) => prev + 1)
```

Обязательно, если новое значение зависит от предыдущего. Гарантирует актуальное состояние.

### useEffect

Используется для побочных эффектов:

- запросы к API
- подписки
- таймеры
- работа с DOM

### Синтаксис

```javascript
useEffect(() => {
  // effect
  return () => {
    // cleanup
  }
}, [deps])
```

### Массив зависимостей

**deps отсутствует:**

- Поведение: каждый рендер (антипаттерн)

**deps = `[]`:**

- Поведение: только при маунте

**deps = `[a, b]`:**

- Поведение: при изменении a или b

### Cleanup функция

Выполняется перед следующим эффектом или при размонтировании компонента.

```javascript
useEffect(() => {
  const timer = setInterval(() => {}, 1000)
  return () => clearInterval(timer) // cleanup
}, [])
```

### Частые ошибки

- забыли зависимости → stale closures
- добавили лишние зависимости → лишние эффекты
- эффекты с состоянием без cleanup → утечки памяти
- бесконечные циклы из-за зависимостей

---

## 18.2. useMemo и useCallback

### useMemo

Мемоизирует значение. Пересчитывается только при изменении зависимостей.

```javascript
const total = useMemo(() => {
  return expensiveCalculation(items)
}, [items])
```

**Используйте когда:**

- вычисление дорогое
- значение передаётся в дочерние компоненты
- нужно предотвратить лишние вычисления

### useCallback

Мемоизирует функцию. Создаёт новую функцию только при изменении зависимостей.

```javascript
const onClick = useCallback(() => {
  setCount((c) => c + 1)
}, [])
```

**Используйте когда:**

- функция передаётся в дочерние компоненты
- функция в зависимостях других хуков

⚠️ Важно: Не использовать без причины — это оптимизация, а не базовый инструмент. Преждевременная оптимизация может ухудшить код.

---

## 18.3. useRef и forwardRef

### useRef

```javascript
const inputRef = useRef(null)
```

**Особенности:**

- хранит мутабельное значение
- не вызывает ререндер при изменении
- сохраняется между рендерами

**Использование:**

- доступ к DOM-элементам
- хранение предыдущих значений
- таймеры и интервалы

### forwardRef

Позволяет передавать ref в дочерний компонент.

```jsx
const Input = forwardRef((props, ref) => <input ref={ref} {...props} />)
```

**Используется для:**

- библиотечных компонентов
- интеграции с DOM
- передачи ref через несколько уровней

---

## 18.4. useReducer

Альтернатива useState для сложного состояния.

**Пример:**

```javascript
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 }
    case 'decrement':
      return { count: state.count - 1 }
    default:
      return state
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 })

dispatch({ type: 'increment' })
```

**Когда использовать:**

- много переходов состояния
- сложная логика обновления
- похож на Redux (подготовка к миграции)

**Преимущества:**

- централизованная логика
- предсказуемые обновления
- легче тестировать

---

## 18.5. Context API

Позволяет передавать данные без проп-дриллинга.

**Пример:**

```jsx
const ThemeContext = createContext('light')

function App() {
  return (
    <ThemeContext.Provider value='dark'>
      <Child />
    </ThemeContext.Provider>
  )
}

function Child() {
  const theme = useContext(ThemeContext)
  return <div className={theme}>Content</div>
}
```

### Проблемы Context

- вызывает ререндер всех потребителей при изменении
- не замена Redux для сложного состояния
- может привести к проблемам производительности

**Оптимизация:**

- разделение контекстов (не один большой Context)
- мемоизация значений
- использование селекторов

### Rules of Hooks

1. Вызывать только на верхнем уровне (не в условиях, циклах, вложенных функциях)
2. Только в React-функциях (компоненты или кастомные хуки)

Нарушение = баги и нестабильное поведение.

### Кастомные хуки

Функции, начинающиеся с "use", использующие другие хуки.

```javascript
function useCounter(initial = 0) {
  const [count, setCount] = useState(initial)

  const increment = () => setCount((c) => c + 1)
  const decrement = () => setCount((c) => c - 1)

  return { count, increment, decrement }
}
```

Позволяют переиспользовать логику между компонентами.

---

## Вопросы на собеседовании

### 1. Чем useState отличается от useReducer?

useState для простого состояния, useReducer для сложной логики с множеством переходов.

### 2. Как работает useEffect?

Выполняет побочные эффекты после рендера. Cleanup выполняется перед следующим эффектом или размонтированием.

### 3. Почему важен массив зависимостей?

Определяет, когда эффект должен выполняться. Неправильные зависимости → баги и проблемы производительности.

### 4. useMemo vs useCallback?

useMemo мемоизирует значение, useCallback мемоизирует функцию.

### 5. Когда нужен useRef?

Для доступа к DOM, хранения мутабельных значений без ререндеров, предыдущих значений.

### 6. Что такое forwardRef?

Позволяет передавать ref в дочерний компонент через props.

### 7. Проблемы Context API?

Ререндер всех потребителей, проблемы производительности при частых обновлениях, не замена Redux.

### 8. Что будет, если нарушить правила хуков?

Непредсказуемое поведение, баги, возможные ошибки React.

---

## Key Takeaways

- useState для простого состояния, useReducer для сложного
- useEffect для побочных эффектов, всегда указывайте зависимости
- useMemo/useCallback — оптимизации, не злоупотребляйте
- useRef для мутабельных значений без ререндеров
- Context API решает проп-дриллинг, но имеет ограничения
- Правила хуков обязательны для стабильности
- Кастомные хуки переиспользуют логику
- Cleanup в useEffect предотвращает утечки памяти

---

**Часть VI. React и современная разработка SPA**
