# Глава 24. Безопасность во фронтенде

Безопасность во фронтенде — это не про «сервер всё проверит», а про минимизацию поверхности атаки. На уровне Middle+ ожидается понимание моделей угроз, а не просто список терминов.

---

## 24.1. XSS (Cross-Site Scripting)

XSS — внедрение вредоносного JS-кода в доверенный контекст.

### Виды XSS

**Отражённая (Reflected):**

Код возвращается в ответе сервера. Пользователь видит вредоносный URL.

**Хранимая (Stored):**

Код сохраняется в БД и исполняется у всех пользователей.

**DOM-based:**

Манипуляции DOM без участия сервера. Вредоносный код в клиентском JS.

### Пример

```javascript
element.innerHTML = userInput // ❌
```

### Защита

- экранирование (sanitization)
- Content Security Policy (CSP)
- отказ от innerHTML
- использование фреймворков (React экранирует по умолчанию)
- textContent вместо innerHTML

---

## 24.2. CSRF (Cross-Site Request Forgery)

CSRF — выполнение запроса от имени пользователя без его ведома.

### Как работает

- браузер автоматически отправляет cookies
- злоумышленник подсовывает запрос с другого сайта

### Защита

- CSRF-токены
- SameSite cookies
- проверка Origin / Referer
- двойная отправка cookies

---

## 24.3. CORS

CORS — механизм контроля доступа между origin'ами.

### Preflight-запрос

```
OPTIONS /api
```

Проверка разрешений перед основным запросом.

### Типичная ошибка

Открытый CORS:

```
Access-Control-Allow-Origin: *
```

Должно быть ограничено конкретными доменами.

---

## 24.4. Cookie-флаги

### HttpOnly

JS не имеет доступа. Защита от XSS.

### Secure

Только по HTTPS. Защита от перехвата.

### SameSite

- Strict — только same-site запросы
- Lax — GET-запросы с других сайтов разрешены
- None — требует Secure

---

## 24.5. Токены и аутентификация

### JWT

**Плюсы:**

- stateless
- масштабируемость

**Минусы:**

- нельзя отозвать
- риск утечки
- размер токена

### Access + Refresh tokens

- access — короткоживущий (15 мин)
- refresh — обновление (7 дней)

### Где хранить

- HttpOnly cookies (предпочтительно)
- не в localStorage (уязвимо к XSS)

---

## 24.6. OWASP Top-10

**Ключевые пункты для фронтенда:**

- XSS
- CSRF
- insecure storage
- misconfiguration

### Типичные ошибки

- хранение токенов в localStorage
- отключение CORS без понимания
- доверие данным от клиента

---

## 24.7. Практические сценарии для фронтенда

### Сценарий 1: SPA на React с токенами

**Ситуация:** приложение авторизуется через JWT, токен хранится в `localStorage`, запросы отправляются с `Authorization: Bearer ...`.

**Проблема:** при XSS‑уязвимости атакующий может прочитать `localStorage` и украсть токен.

**Как лучше:**

- хранить access/refresh‑токены в HttpOnly cookie;
- ограничивать cookie флагами `Secure` + `SameSite=Lax/Strict`;
- на фронте вообще не трогать токен напрямую, опираясь на куки и ответы сервера.

Что можно спросить на собесе: **«Где вы храните токены и почему?»** — важно уметь аргументированно ответить.

### Сценарий 2: Форма с `dangerouslySetInnerHTML`

**Ситуация:** CMS даёт HTML‑контент, React‑компонент рендерит его через `dangerouslySetInnerHTML`, иногда туда попадает пользовательский ввод.

**Риски:**

- XSS, если сервер не санитизирует HTML;
- внедрение `<script>` или inline‑обработчиков (`onerror`, `onclick`).

**Как лучше:**

- по возможности работать с безопасным форматом (Markdown → заранее проверенный HTML);
- санитизировать HTML на сервере (DOMPurify или специализированные библиотеки);
- по максимуму избегать `dangerouslySetInnerHTML` для непроверенного ввода.

### Сценарий 3: «Открытый» CORS

**Ситуация:** чтобы «заработал фронт», на сервере поставили `Access-Control-Allow-Origin: *` и разрешили все методы.

**Риски:**

- любой сайт может обращаться к вашему API от имени пользователя;
- при неправильной конфигурации с cookie можно получить CSRF‑уязвимость.

**Как лучше:**

- ограничивать `Access-Control-Allow-Origin` конкретными доменами продукта;
- для cookie‑авторизации аккуратно комбинировать CORS и `SameSite`;
- не использовать `*` в продакшене для чувствительных эндпоинтов.

### Сценарий 4: Загрузка файлов

**Ситуация:** фронт позволяет загружать файлы и показывает превью.

**Риски:**

- попытка загрузки HTML/JS под видом картинки;
- XSS‑атаки при отображении имени файла или описания без экранирования.

**Как лучше:**

- валидировать тип и размер файла на клиенте и на сервере;
- никогда не доверять `file.name` и другим полям, всегда экранировать при выводе;
- использовать безопасные CDN/поддомены для раздачи пользовательского контента.

---

## Вопросы на собеседовании

### 1. Разница между видами XSS?

Reflected — в URL, Stored — в БД, DOM-based — в клиентском JS.

### 2. Как защититься от XSS?

Экранирование, CSP, textContent вместо innerHTML, фреймворки.

### 3. Что такое CSRF?

Выполнение запроса от имени пользователя без его ведома через автоматическую отправку cookies.

### 4. CORS — это защита сервера или браузера?

Браузера. Сервер настраивает политику, браузер её исполняет.

### 5. Чем cookies лучше localStorage для токенов?

HttpOnly cookies недоступны из JS, защита от XSS.

### 6. Что делает SameSite?

Ограничивает отправку cookies только для same-site запросов, защита от CSRF.

### 7. JWT — плюсы и минусы?

Плюсы: stateless, масштабируемость. Минусы: нельзя отозвать, размер, риск утечки.

### 8. Какие пункты OWASP важны для фронта?

XSS, CSRF, insecure storage, misconfiguration.

---

## Key Takeaways

- XSS — самая частая угроза фронтенда
- CSRF защищается токенами и SameSite cookies
- CORS настраивается на сервере
- HttpOnly cookies безопаснее localStorage
- JWT имеет ограничения, нужна стратегия обновления
- OWASP Top-10 — базовый чек-лист безопасности

---

В следующей части мы выйдем за пределы браузера и посмотрим на Node.js глазами фронтенд‑разработчика: зачем он нужен, как устроен его рантайм и как использовать его для инструментов, SSR и простых API.
