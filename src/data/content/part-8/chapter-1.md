# Глава 23. Производительность

Производительность — это не «оптимизация ради оптимизации», а пользовательский опыт и деньги бизнеса. Медленный интерфейс снижает конверсию, увеличивает отток и напрямую влияет на метрики продукта.

На собеседованиях производительность — индикатор инженерной зрелости.

---

## 23.1. Оптимизация загрузки

### Критические метрики (Core Web Vitals)

- LCP (Largest Contentful Paint) — скорость загрузки основного контента (< 2.5s)
- FID / INP — отзывчивость интерфейса (< 100ms)
- CLS — визуальная стабильность (< 0.1)

### Что замедляет загрузку

- большой JS-бандл
- блокирующие ресурсы
- отсутствие кеширования
- неоптимизированные изображения
- блокирующий JavaScript

### Code Splitting

```javascript
const Page = lazy(() => import('./Page'))
```

Позволяет грузить код по требованию.

### Preload / Prefetch

```html
<link rel="preload" href="font.woff2" as="font" />
<link rel="prefetch" href="next-page.js" />
```

- preload — критично сейчас
- prefetch — возможно пригодится потом

---

## 23.2. Оптимизация рендеринга

### Избегание лишних ререндеров

**Причины ререндеров:**

- изменение props
- изменение state
- изменение context

### React.memo

```javascript
export default memo(Component)
```

Предотвращает ререндер при тех же props.

### useCallback / useMemo

Использовать только при необходимости. Антипаттерн — мемоизировать всё подряд.

### Virtualization

Для длинных списков:

- react-window
- react-virtual

Рендерятся только видимые элементы.

---

## 23.3. Lighthouse и WebPageTest

### Lighthouse

- доступен в DevTools
- показывает проблемы
- даёт рекомендации
- проверяет Core Web Vitals

### WebPageTest

- реальные устройства
- реальные сети
- waterfall-загрузка
- используется для глубокой диагностики

---

## 23.4. Lazy-loading и prefetching

### Изображения

```html
<img src="img.jpg" loading="lazy" />
```

### Компоненты

```javascript
lazy(() => import('./Chart'))
```

### Route-based splitting

Каждый роут — отдельный чанк.

---

## 23.5. Работа с изображениями

### Форматы

**JPEG:**

- Когда: фото

**PNG:**

- Когда: прозрачность

**WebP:**

- Когда: универсальный, лучшее сжатие

**AVIF:**

- Когда: лучшее сжатие (новый формат)

### Responsive images

```html
<img
  srcset="img-320.jpg 320w, img-640.jpg 640w"
  sizes="(max-width: 600px) 100vw, 50vw"
/>
```

Браузер сам выбирает правильное изображение.

### Типичные ошибки

- ранняя оптимизация без профилирования
- отсутствие метрик
- оптимизация без понимания узких мест

---

## Вопросы на собеседовании

### 1. Что такое Core Web Vitals?

LCP, FID/INP, CLS — ключевые метрики производительности.

### 2. Что больше всего влияет на LCP?

Размер изображений, блокирующие ресурсы, время ответа сервера.

### 3. Как уменьшить размер JS-бандла?

Code splitting, tree-shaking, удаление неиспользуемого кода, минификация.

### 4. Когда нужен React.memo?

Когда компонент рендерится часто с теми же props, и рендер дорогой.

### 5. Что такое virtualization?

Рендеринг только видимых элементов в длинных списках.

### 6. Lighthouse vs WebPageTest?

Lighthouse — быстрая проверка в DevTools. WebPageTest — глубокий анализ на реальных устройствах.

### 7. Lazy-loading vs prefetch?

Lazy-loading — загрузка по требованию. Prefetch — предзагрузка на будущее.

### 8. Почему ранняя оптимизация вредна?

Оптимизация без профилирования может ухудшить код, не решив реальные проблемы.

---

## Key Takeaways

- Core Web Vitals — ключевые метрики производительности
- Code splitting критичен для больших приложений
- React.memo/useMemo/useCallback — оптимизации, не злоупотребляйте
- Virtualization для длинных списков
- Lighthouse и WebPageTest для диагностики
- Оптимизация изображений критична для LCP
- Профилирование перед оптимизацией

---

**Часть VIII. Производительность и безопасность**
