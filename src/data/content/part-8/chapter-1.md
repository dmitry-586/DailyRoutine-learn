# Глава 24. Производительность

Производительность — это не «оптимизация ради оптимизации», а пользовательский опыт и деньги бизнеса. Медленный интерфейс снижает конверсию, увеличивает отток и напрямую влияет на метрики продукта.

На собеседованиях производительность — индикатор инженерной зрелости.

---

## 24.1. Оптимизация загрузки

### Критические метрики (Core Web Vitals)

- LCP (Largest Contentful Paint) — скорость загрузки основного контента (< 2.5s)
- FID / INP — отзывчивость интерфейса (< 100ms)
- CLS — визуальная стабильность (< 0.1)

### Что замедляет загрузку

- большой JS-бандл
- блокирующие ресурсы
- отсутствие кеширования
- неоптимизированные изображения
- блокирующий JavaScript

### Code Splitting

```javascript
const Page = lazy(() => import('./Page'))
```

Позволяет грузить код по требованию.

### Preload / Prefetch

```html
<link rel="preload" href="font.woff2" as="font" />
<link rel="prefetch" href="next-page.js" />
```

- preload — критично сейчас
- prefetch — возможно пригодится потом

---

## 24.2. Оптимизация рендеринга

### Избегание лишних ререндеров

**Причины ререндеров:**

- изменение props
- изменение state
- изменение context

### React.memo

```javascript
export default memo(Component)
```

Предотвращает ререндер при тех же props.

### useCallback / useMemo

Использовать только при необходимости. Антипаттерн — мемоизировать всё подряд.

### Virtualization

Для длинных списков:

- react-window
- react-virtual

Рендерятся только видимые элементы.

---

## 24.3. Lighthouse и WebPageTest

### Lighthouse

- доступен в DevTools
- показывает проблемы
- даёт рекомендации
- проверяет Core Web Vitals

### WebPageTest

- реальные устройства
- реальные сети
- waterfall-загрузка
- используется для глубокой диагностики

---

## 24.4. Lazy-loading и prefetching

### Изображения

```html
<img src="img.jpg" loading="lazy" />
```

### Компоненты

```javascript
lazy(() => import('./Chart'))
```

### Route-based splitting

Каждый роут — отдельный чанк.

---

## 24.5. Работа с изображениями

### Форматы

**JPEG:**

- Когда: фото

**PNG:**

- Когда: прозрачность

**WebP:**

- Когда: универсальный, лучшее сжатие

**AVIF:**

- Когда: лучшее сжатие (новый формат)

### Responsive images

```html
<img
  srcset="img-320.jpg 320w, img-640.jpg 640w"
  sizes="(max-width: 600px) 100vw, 50vw"
/>
```

Браузер сам выбирает правильное изображение.

### Типичные ошибки

- ранняя оптимизация без профилирования
- отсутствие метрик
- оптимизация без понимания узких мест

---

## 24.6. Практические сценарии

### Сценарий 1: Медленный первый экран на SPA

**Симптомы:**

- долгий LCP на главной;
- ощущение «белого экрана» перед появлением контента;
- Lighthouse ругается на «Render‑blocking resources» и большой JS‑бандл.

**Разбор:**

- критический контент зависит от тяжёлого React‑графика/таблицы;
- всё грузится в одном бандле, без code splitting;
- изображения на первом экране не оптимизированы и не используют современный формат.

**Что можно сделать:**

- вынести тяжёлые виджеты в ленивые компоненты (`React.lazy` / динамические импорты);
- настроить route‑based code splitting;
- оптимизировать изображения (размеры, форматы, `srcset`) и использовать `loading="lazy"` там, где это безопасно;
- проверить, что CSS не блокирует рендер дольше, чем нужно (critical CSS + асинхронная загрузка остального).

### Сценарий 2: Тяжёлый список ломает скролл

**Симптомы:**

- длинные списки (1000+ элементов) тормозят при скролле;
- при фильтрации/поиске интерфейс «фризится»;
- React DevTools показывает множество повторных рендеров.

**Решения:**

- применить виртуализацию (`react-window`, `react-virtual`), чтобы рендерить только видимую часть списка;
- мемоизировать элементы списка, если пропсы стабильно не меняются;
- отделить фильтрацию/поиск от UI‑рендера (например, выносом тяжёлой логики в Web Worker).

### Сценарий 3: «Незаметная» деградация после подключения библиотеки

**Симптомы:**

- после добавления визуальной библиотеки (charts, rich text, UI‑kit) бандл разросся на сотни килобайт;
- дев‑сборка стала запускаться ощутимо медленнее;
- метрики по LCP/INP чуть‑чуть, но стабильно просели.

**Подход:**

- посмотреть отчёт бандлера (bundle analyzer) и понять вклад новой библиотеки;
- по возможности перевести её на ленивую загрузку и использовать только нужные подмодули, а не весь пакет;
- оценить, нельзя ли заменить её более лёгкой альтернативой или нативными средствами.

---

## Вопросы на собеседовании

### 1. Что такое Core Web Vitals?

LCP, FID/INP, CLS — ключевые метрики производительности.

### 2. Что больше всего влияет на LCP?

Размер изображений, блокирующие ресурсы, время ответа сервера.

### 3. Как уменьшить размер JS-бандла?

Code splitting, tree-shaking, удаление неиспользуемого кода, минификация.

### 4. Когда нужен React.memo?

Когда компонент рендерится часто с теми же props, и рендер дорогой.

### 5. Что такое virtualization?

Рендеринг только видимых элементов в длинных списках.

### 6. Lighthouse vs WebPageTest?

Lighthouse — быстрая проверка в DevTools. WebPageTest — глубокий анализ на реальных устройствах.

### 7. Lazy-loading vs prefetch?

Lazy-loading — загрузка по требованию. Prefetch — предзагрузка на будущее.

### 8. Почему ранняя оптимизация вредна?

Оптимизация без профилирования может ухудшить код, не решив реальные проблемы.

---

## Key Takeaways

- Core Web Vitals — ключевые метрики производительности
- Code splitting критичен для больших приложений
- React.memo/useMemo/useCallback — оптимизации, не злоупотребляйте
- Virtualization для длинных списков
- Lighthouse и WebPageTest для диагностики
- Оптимизация изображений критична для LCP
- Профилирование перед оптимизацией

---

Дальше мы посмотрим на безопасность фронтенда: XSS, CSRF, работа с токенами и cookie, а также практики, которые позволяют не только сделать приложение быстрым, но и защитить данные пользователей.
