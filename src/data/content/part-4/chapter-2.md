# Глава 13. Сборщики

Сборщик — это инструмент, который превращает исходный код разработчика в оптимизированные файлы для браузера.

На уровне Middle от разработчика ожидают:

- понимание архитектуры сборки
- умение читать конфигурацию
- осознанный выбор инструментов

---

## 13.1. Webpack: архитектура и принципы

Webpack — модульный бандлер. Он строит граф зависимостей, начиная с entry point.

### Базовая концепция

1. Entry — точка входа
2. Graph — граф модулей
3. Loaders — обработка файлов
4. Plugins — расширение логики
5. Output — результат сборки

### Минимальная конфигурация

```javascript
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: __dirname + '/dist',
  },
}
```

### Loaders

Loaders обрабатывают не-JS файлы.

```javascript
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    },
  ]
}
```

Работают справа налево: сначала css-loader, потом style-loader.

### Plugins

Плагины влияют на процесс сборки целиком.

```javascript
new HtmlWebpackPlugin({
  template: './src/index.html',
})
```

**Разница между loader и plugin:**

- Loader — трансформирует отдельные файлы
- Plugin — работает на уровне всего процесса сборки

---

## 13.2. Vite и современная разработка

Vite — инструмент нового поколения.

### Почему Vite быстрее?

**Dev mode:**

- использует native ES Modules
- без бандлинга
- сервер отдаёт файлы напрямую
- HMR (Hot Module Replacement) на уровне модулей

**Build:**

- использует Rollup для продакшн-сборки
- оптимизированная конфигурация из коробки

### Сравнение Webpack vs Vite

**Dev server:**

- Webpack: медленный (бандлинг)
- Vite: быстрый (ESM)

**Конфигурация:**

- Webpack: сложная
- Vite: минимальная

**Legacy поддержка:**

- Webpack: отлично
- Vite: ограниченно

**Современные проекты:**

- Webpack: избыточен
- Vite: предпочтителен

**HMR:**

- Webpack: медленный
- Vite: мгновенный

**Когда использовать Vite:**

- новые проекты
- современные браузеры
- быстрая разработка

**Когда использовать Webpack:**

- legacy проекты
- сложные требования к сборке
- специфичные плагины

---

## 13.3. Babel: транспиляция

Babel — транспилятор JS. Превращает современный JavaScript в код, работающий в старых браузерах.

**Зачем он нужен?**

Позволяет писать:

```javascript
const sum = (a, b) => a + b
```

И получать код, работающий в старых браузерах.

### Presets

```json
"presets": ["@babel/preset-env"]
```

@babel/preset-env автоматически определяет, какие трансформации нужны на основе целевых браузеров.

### Polyfills

Babel не добавляет API, только синтаксис. Для API используется core-js.

```javascript
import 'core-js/stable'
```

Добавляет недостающие методы:

- Promise
- Array.prototype.includes
- Object.assign

**Зачем нужны polyfills?**

Без них код может упасть в старом браузере из-за отсутствующих API.

---

## 13.4. Tree Shaking

Удаление неиспользуемого кода.

**Работает только с:**

- ES Modules
- static imports

**Почему CommonJS мешает tree-shaking?**

CommonJS — динамический, импорты определяются во время выполнения. Tree-shaking требует статического анализа.

**Пример:**

```javascript
// Используется только sum
import { sum, multiply } from './math'
// multiply будет удалён из бандла
```

---

## 13.5. Code Splitting

Разделение кода на чанки для оптимизации загрузки.

**Динамический импорт:**

```javascript
const Page = lazy(() => import('./Page'))
```

**Route-based splitting:**

Каждый роут — отдельный чанк.

**Component-based splitting:**

Тяжёлые компоненты загружаются по требованию.

**Преимущества:**

- меньше начальный бандл
- быстрее загрузка
- лучший Core Web Vitals

---

## Вопросы на собеседовании

### 1. Что делает Webpack?

Модульный бандлер, строит граф зависимостей и объединяет модули в бандлы.

### 2. Разница между loader и plugin?

Loader трансформирует отдельные файлы, plugin работает на уровне всего процесса сборки.

### 3. Как работает Vite?

В dev использует native ES Modules без бандлинга, в build — Rollup.

### 4. Почему Vite быстрее Webpack в dev?

Не делает бандлинг, отдаёт файлы напрямую через ES Modules.

### 5. Зачем нужен Babel?

Транспиляция современного JS в код, работающий в старых браузерах.

### 6. Чем транспиляция отличается от полифиллинга?

Транспиляция — синтаксис (стрелки → функции). Полифиллинг — API (Promise, Array.includes).

### 7. Что такое tree-shaking?

Удаление неиспользуемого кода из бандла.

### 8. Почему CommonJS мешает tree-shaking?

CommonJS динамический, tree-shaking требует статического анализа (ES Modules).

### 9. Что такое code splitting?

Разделение кода на чанки для оптимизации загрузки.

---

## Key Takeaways

- Webpack — мощный, но сложный бандлер
- Vite — современная альтернатива с быстрым dev-сервером
- Babel транспилирует синтаксис, polyfills добавляют API
- Tree-shaking работает только с ES Modules
- Code splitting улучшает производительность загрузки
- Loaders обрабатывают файлы, plugins расширяют процесс сборки
- Выбор инструмента зависит от требований проекта

---

Дальше логичный шаг — перейти к тестам: увидим, как unit, integration и E2E‑тесты встраиваются в ту же инфраструктуру и помогают держать проект в рабочем состоянии при постоянных изменениях.
