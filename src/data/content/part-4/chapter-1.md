# Глава 12. NPM, package.json и зависимости проекта

Инфраструктура — это то, что отличает «код на ноутбуке» от продакшн-приложения. На уровне Middle от разработчика ожидают понимание того, как живёт проект, а не только как пишутся компоненты.

---

## 12.1. npm, yarn, pnpm

Все три инструмента решают одну задачу: управление зависимостями и скриптами проекта.

### npm (Node Package Manager)

- стандарт де-факто
- идёт вместе с Node.js
- самый распространённый

```bash
npm install react
npm run build
```

### yarn

Появился как альтернатива npm:

- быстрее (исторически)
- deterministic installs
- удобный CLI

```bash
yarn add react
yarn build
```

### pnpm

Современный инструмент с фокусом на производительность и дисковое пространство.

**Как работает pnpm?**

- использует content-addressable storage
- зависимости хранятся один раз
- проекты используют ссылки (symlinks)

**Плюсы:**

- быстрее
- меньше места на диске
- меньше «phantom dependencies»

### Когда что выбирать?

**Стандартный проект** → npm

**Большие монорепозитории** → pnpm

**Legacy проекты** → yarn

---

## 12.2. package.json: сердце проекта

package.json — это контракт проекта.

### Основные поля

```json
{
  "name": "app",
  "version": "1.0.0",
  "scripts": {},
  "dependencies": {},
  "devDependencies": {}
}
```

### dependencies vs devDependencies

**dependencies:**

- нужны в runtime

**devDependencies:**

- нужны только для разработки

**Пример:**

- react → dependencies
- webpack, jest → devDependencies

### peerDependencies

Используются библиотеками:

```json
"peerDependencies": {
  "react": ">=17"
}
```

Означает: «приложение должно предоставить эту зависимость». Это позволяет избежать дублирования зависимостей.

---

## 12.3. SemVer (Semantic Versioning)

**Формат:** MAJOR.MINOR.PATCH

**Пример:** 2.4.1

- MAJOR — breaking changes
- MINOR — backward compatible features
- PATCH — bugfix

### Символы версий

```json
"react": "^18.2.0"
```

- ^ — разрешает обновление MINOR и PATCH
- ~ — только PATCH
- без символа — строго указанная версия

**Почему это важно?**

Неправильная версия = сломанная сборка. SemVer помогает управлять совместимостью.

---

## 12.4. Lock-файлы

- package-lock.json (npm)
- yarn.lock (yarn)
- pnpm-lock.yaml (pnpm)

**Зачем они нужны?**

- фиксируют дерево зависимостей
- гарантируют одинаковую сборку на всех машинах
- обязательны в репозитории

⚠️ Удаление lock-файла — частая причина багов. Всегда коммитьте lock-файлы.

---

## 12.5. Скрипты и lifecycle hooks

### Скрипты

```json
"scripts": {
  "dev": "vite",
  "build": "vite build",
  "test": "jest"
}
```

**Запуск:**

```bash
npm run build
```

### Lifecycle hooks

npm автоматически запускает:

- preinstall — перед установкой
- postinstall — после установки
- prebuild — перед сборкой
- postbuild — после сборки

**Используется для:**

- генерации файлов
- подготовки окружения
- запуска тестов

### Частые проблемы с зависимостями

- конфликт версий
- дублирование библиотек
- phantom dependencies (зависимости, доступные без явного объявления)
- разные версии Node

---

## Вопросы на собеседовании

### 1. Чем npm отличается от yarn и pnpm?

npm — стандарт, yarn — быстрее исторически, pnpm — использует symlinks, экономит место.

### 2. Что такое package.json?

Контракт проекта: зависимости, скрипты, метаданные.

### 3. Разница между dependencies и devDependencies?

dependencies нужны в runtime, devDependencies — только для разработки.

### 4. Зачем нужны peerDependencies?

Библиотеки указывают, какие зависимости должно предоставить приложение. Избегает дублирования.

### 5. Что такое SemVer?

Semantic Versioning — система версионирования: MAJOR.MINOR.PATCH.

### 6. Что означает ^ в версии пакета?

Разрешает обновление MINOR и PATCH версий, но не MAJOR.

### 7. Зачем нужен lock-файл?

Фиксирует точные версии зависимостей, гарантирует одинаковую сборку.

### 8. Почему нельзя коммитить без lock-файла?

Разные разработчики могут получить разные версии зависимостей, что приведёт к багам.

---

## Key Takeaways

- npm/yarn/pnpm решают одну задачу, но по-разному
- package.json — контракт проекта
- dependencies vs devDependencies — важное разделение
- SemVer управляет совместимостью версий
- Lock-файлы обязательны для стабильности сборки
- Lifecycle hooks автоматизируют процессы
- peerDependencies предотвращают дублирование зависимостей

---

**Часть IV. Инфраструктура: сборка, тестирование, инструменты**
