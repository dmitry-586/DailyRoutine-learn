# Глава 8. Основы языка

JavaScript — это не «язык для кнопок», а полноценный многопарадигменный язык со своей моделью выполнения, типизацией и правилами, которые напрямую влияют на надёжность фронтенд-приложений.

Несмотря на всю кажущуюся простоту, JavaScript — один из самых неправильно понятых языков. Именно здесь происходит большинство ошибок, из-за которых код ведёт себя «не так».

На собеседованиях по JS чаще всего проверяют понимание механики, а не синтаксиса. Эта глава — фундамент, без которого невозможно уверенно двигаться дальше.

Эта глава раскладывает фундаментальные концепции в строгой, ясной и прикладной форме:

1. Типы данных
2. Приведение типов
3. Область видимости
4. Контекст выполнения
5. Lexical Environment
6. Hoisting
7. Стек вызовов и память

После этой главы все последующие темы — замыкания, прототипы, асинхронность — станут намного легче.

---

## 8.1. Типы данных и работа с ними

В JavaScript 8 типов данных:

**Примитивы (хранятся по значению, а не по ссылке):**

1. number
2. string
3. boolean
4. null
5. undefined
6. symbol
7. bigint

**Ссылочный тип:** 8. object (включая array, function, Map/Set, Date и т.д.)

**Почему это важно**

JS — динамически типизированный язык, но типы влияют на:

- поведение операторов
- сравнение
- передачу аргументов
- работу с памятью

### Примитивы vs объекты

**Примитивы копируются по значению:**

```javascript
let a = 10
let b = a
b = 20
console.log(a) // 10
```

**Объекты хранятся по ссылке:**

```javascript
let obj1 = { x: 1 }
let obj2 = obj1
obj2.x = 2
console.log(obj1.x) // 2
```

obj2 и obj1 — это одна и та же область в памяти.

Примитивы иммутабельны. Если изменить строку — создаётся новая.

**Пример вопроса на собеседовании:**

Почему нельзя изменить символ в строке напрямую?

**Ответ:** Строки — примитивы, они неизменяемы. Любое «изменение» создаёт новое значение.

---

## 8.2. Приведение типов (Type Coercion)

JavaScript активно приводит типы неявно. JS пытается быть «умным» и конвертирует типы сам, что приводит к странным результатам.

### Явное приведение

```javascript
Number('42') // 42
String(42) // "42"
Boolean(1) // true
```

### Неявное приведение

```javascript
"5" + 2 // "52"
"5" - 2 // 3
[] + [] // ""
{} + [] // "[object Object]"
```

**Почему так происходит?**

- - — оператор конкатенации и сложения (предпочитает конкатенацию, если есть строка)
- остальные арифметические операторы приводят к number

### Truthy / Falsy значения

В JS всего 8 falsy значений:

- false
- 0
- -0
- 0n (BigInt)
- ""
- null
- undefined
- NaN

Всё остальное — truthy.

### Сравнение == и ===

**=== (строгое сравнение)**

Сравнивает тип + значение.

**== (нестрогое сравнение)**

Перед сравнением приводит типы, часто нелогично:

```javascript
0 == false // true
"" == 0 // true
null == undefined // true
[] == 0 // true
```

**На собеседовании правильный ответ:**

В корпоративном коде всегда используй ===, кроме конкретных случаев сравнения с null.

---

## 8.3. Области видимости, hoisting и TDZ

Область видимости — это зона, где доступна переменная.

**Три основных типа:**

1. Global Scope
2. Function Scope
3. Block Scope (ES6)

### var — function scope

```javascript
if (true) {
  var x = 10
}
console.log(x) // 10
```

var игнорирует блоки — переменная всплывает (hoisting).

### let & const — block scope

```javascript
if (true) {
  let y = 20
}
console.log(y) // ReferenceError
```

let и const ограничены блоком { ... }.

### Temporal Dead Zone (TDZ)

Даже если переменная объявлена ниже, она недоступна пока не выполнено объявление:

```javascript
console.log(a) // ReferenceError
let a = 10
```

TDZ — частый вопрос на собеседованиях. Если объяснить — плюс в вашу пользу.

### Hoisting — поднятие переменных и функций

**var hoisting:**

```javascript
console.log(a) // undefined
var a = 5
```

**let/const hoisting:**

Они тоже поднимаются, но остаются в TDZ:

```javascript
console.log(b) // ReferenceError
let b = 10
```

**Hoisting функций:**

Функции поднимаются полностью:

```javascript
say() // работает

function say() {
  console.log('Hello')
}
```

Но function expression не поднимается:

```javascript
say() // TypeError
const say = function () {}
```

---

## 8.4. var / let / const

**var**

- Scope: function
- Hoisting: да
- Повторное объявление: да
- Изменение значения: да

**let**

- Scope: block
- Hoisting: да (TDZ)
- Повторное объявление: нет
- Изменение значения: да

**const**

- Scope: block
- Hoisting: да (TDZ)
- Повторное объявление: нет
- Изменение значения: нет

**Важно:**

const запрещает переназначение, но не изменение объекта:

```javascript
const obj = {}
obj.x = 1 // OK
```

**Почему var считается устаревшим?**

- отсутствие block scope
- hoisting может приводить к ошибкам
- не поддерживает TDZ

---

## 8.5. Функции

### Function Declaration

```javascript
function sum(a, b) {
  return a + b
}
```

Hoisted полностью. Можно вызвать до объявления.

### Function Expression

```javascript
const sum = function (a, b) {
  return a + b
}
```

Поднимается только переменная, но не значение.

### Arrow Function

```javascript
const sum = (a, b) => a + b
```

**Отличия стрелок:**

- нет собственного this
- нет arguments
- нельзя использовать как конструктор

### Named function expression

```javascript
const factorial = function fact(n) {
  if (n === 0) return 1
  return n * fact(n - 1)
}
```

Полезно для рекурсии, но почти не используется новичками.

---

## 8.6. Контекст выполнения (Execution Context)

Когда JS запускает код, он создаёт execution context, который состоит из:

- Lexical Environment
- Variable Environment
- This binding

**На собеседовании стоит объяснять просто:**

Контекст выполнения — это внутренняя структура, которую движок создаёт для исполнения кода. Он определяет, какие переменные доступны, как работают замыкания и чему равен this.

### Lexical Environment: где хранятся переменные

Фундамент JS.

Lexical Environment состоит из:

- Environment Record (хранилище переменных)
- ссылка на внешний Lexical Environment

Это и есть причина существования замыканий.

**Почему JS называется «лексически скоупированным»?**

Потому что область видимости определяется не во время выполнения, а во время написания (lexing).

```javascript
function outer() {
  const x = 10

  function inner() {
    console.log(x)
  }

  inner()
}
```

inner всегда увидит x, потому что был создан внутри outer.

---

## 8.7. Стек вызовов и управление памятью

JS — однопоточный язык. Это значит, что есть один call stack.

**Пример стека:**

```javascript
function a() {
  b()
}

function b() {
  c()
}

function c() {
  console.log('Hi')
}

a()
```

**Порядок стека:**

- global
- a
- b
- c

После выполнения c выталкивается, и так далее.

### Heap — область для хранения объектов

Примитивы → stack

Объекты → heap

Это объясняет, почему объекты передаются по ссылке.

### Garbage Collector (GC)

JS использует алгоритм mark-and-sweep:

1. Ищет все объекты, до которых можно «дойти» из root.
2. Остальные удаляет автоматически.

Это важно понимать при работе с замыканиями: замыкание может удерживать память дольше, чем вы ожидаете.

---

## Вопросы на собеседовании

### 1. Какие типы данных есть в JS?

7 примитивов (number, string, boolean, null, undefined, symbol, bigint) + object.

### 2. В чём разница между примитивами и объектами?

Примитивы копируются по значению, объекты — по ссылке. Примитивы иммутабельны.

### 3. Что такое неявное приведение типов?

Автоматическое преобразование типов JavaScript при операциях, часто нелогичное (например, "5" + 2 = "52").

### 4. Что такое hoisting?

Механизм, при котором объявления переменных и функций поднимаются вверх области видимости.

### 5. Что такое TDZ?

Temporal Dead Zone — период между «поднятием» переменной и её фактической инициализацией. let/const находятся в TDZ до объявления.

### 6. Чем var отличается от let и const?

var — function scope, hoisting без TDZ, можно переобъявлять. let/const — block scope, TDZ, нельзя переобъявлять.

### 7. Когда использовать стрелочные функции?

Для коллбэков, коротких функций, функционального программирования. Не использовать как методы объектов.

### 8. В чём разница между call, apply и bind?

- call — вызывает функцию сразу, аргументы через запятую
- apply — вызывает функцию сразу, аргументы массивом
- bind — создаёт новую функцию с привязанным контекстом

### 9. Объясните разницу между == и ===

== приводит типы перед сравнением, === сравнивает тип и значение без приведения.

### 10. Что такое область видимости?

Зона, где доступна переменная. Бывает global, function, block.

---

## Key Takeaways

- JavaScript имеет 7 примитивов + объекты по ссылке
- Неявное приведение типов — причина многих багов
- === предпочтительнее почти всегда
- let/const имеют блочную область видимости и TDZ
- Lexical Environment — основа скоупа и замыканий
- Hoisting поднимает объявления, но не значения
- JS — однопоточный, со стеком вызовов и кучей памяти
- var устарел из-за отсутствия block scope и проблем с hoisting
- Function Declaration поднимается полностью, Expression — нет

---

## 8.8. Самопроверка

Если ты можешь без IDE и Google:

- перечислить все примитивные типы JS и объяснить разницу «по значению / по ссылке» на простых примерах;
- предсказать результат для пары нетривиальных выражений с приведением типов (`"5" - 2`, `[] == 0`, `null == undefined`) и объяснить, почему так происходит;
- на словах объяснить, как работает hoisting для `var`, `let/const` и функций, и чем TDZ отличается от «не определено»;
- нарисовать упрощённую схему стека вызовов для цепочки функций и показать, где в ней лежат примитивы, а где объекты;
- рассказать, почему `function sum() {}` можно вызвать до объявления, а `const sum = () => {}` — нет,

то фундамент по языку у тебя уже на уровне, достаточном для уверенного разговора на Middle‑собеседовании.

---

Дальше мы углубимся в те механики, которые чаще всего «роняют» кандидатов на собеседованиях: this, разные виды функций, замыкания и то, как именно движок JS принимает решения при выполнении вашего кода.
