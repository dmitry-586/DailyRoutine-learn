# Глава 9. Функции, this, замыкания и прототипы

В предыдущей главе мы разобрали фундамент: типы, области видимости, Execution Context. Теперь — **ядро JavaScript‑механики**, без которой невозможно уверенно чувствовать себя на mid‑/senior‑собеседованиях:

- как вычисляется `this` в разных контекстах;
- чем отличаются обычные и стрелочные функции;
- что такое замыкания и зачем они нужны в реальном коде;
- как устроены прототипы и классы под капотом;
- как работают модули и современные синтаксические конструкции.

Эта глава снимает большую часть «магии» вокруг языка.

---

## 9.1. `this`: простая система из нескольких правил

Главное, что нужно запомнить:

> **`this` в JavaScript определяется в момент вызова функции, а не в момент её объявления.**

И есть несколько базовых сценариев, по которым вычисляется `this`.

### 1. Глобальный контекст

В браузере:

```javascript
console.log(this) // window
```

В строгом режиме (`'use strict'`):

```javascript
'use strict'
console.log(this) // undefined
```

### 2. Вызов как метод объекта: `obj.method()`

```javascript
const user = {
  name: 'Alex',
  say() {
    console.log(this.name)
  },
}

user.say() // 'Alex'
```

**Правило:** `this` — объект **слева от точки** в момент вызова.

### 3. Обычный вызов функции: `fn()`

```javascript
function say() {
  console.log(this)
}

say() // в нестрогом режиме: window, в strict: undefined
```

Если функция вызывается **без объекта слева**, в строгом режиме `this` будет `undefined`.

### 4. Явная привязка: `call`, `apply`, `bind`

```javascript
function show() {
  console.log(this.name)
}

const obj = { name: 'Bob' }

show.call(obj) // 'Bob'
show.apply(obj) // 'Bob'

const bound = show.bind(obj)
bound() // 'Bob'
```

- `call(context, ...args)` — вызывает функцию сразу, аргументы через запятую;
- `apply(context, argsArray)` — вызывает функцию сразу, аргументы массивом;
- `bind(context)` — **создаёт новую функцию** с зафиксированным `this`.

### 5. Вызов через `new`: конструктор

```javascript
function User(name) {
  this.name = name
}

const u = new User('Alice')
console.log(u.name) // 'Alice'
```

При вызове с `new` движок:

1. создаёт новый объект;
2. связывает его прототип с `User.prototype`;
3. вызывает функцию с `this = новый объект`;
4. возвращает `this` (если явно не вернуть другой объект).

**Резюме по `this`:**

При ответе на собеседовании достаточно уверенно проговорить **эти 5 сценариев**.

---

## 9.2. Стрелочные функции и `this`

Стрелочные функции были добавлены в ES6 и решают две основные задачи:

1. короткий синтаксис для коллбеков;
2. удобная работа с `this` внутри методов и классов.

### Ключевые особенности стрелок

Стрелочная функция **не имеет собственного**:

- `this`;
- `arguments`;
- `super`;
- `new.target`;
- прототипа (нельзя вызывать через `new`).

```javascript
const obj = {
  value: 42,
  printLater() {
    setTimeout(() => {
      console.log(this.value)
    }, 100)
  },
}

obj.printLater() // 42
```

Здесь стрелка **наследует `this` из внешней функции `printLater`**, которая была вызвана как метод объекта.

### Где стрелки плохи

```javascript
const user = {
  name: 'Alice',
  say: () => {
    console.log(this.name)
  },
}

user.say() // undefined
```

Причина:

- `say` — стрелка, она не создаёт свой `this`;
- `this` берётся из внешнего лексического окружения (глобальный контекст);
- там `name` нет.

**Практическое правило:**

- стрелки — **для коллбеков, маленьких функций, методов, завязаных на внешний `this`** (как в примере с `setTimeout`);
- обычные функции — **для методов объектов, конструкторов, когда `this` должен зависеть от способа вызова**.

---

## 9.3. Потеря контекста: частая причина багов

Классическая ловушка:

```javascript
const user = {
  name: 'Alice',
  say() {
    console.log(this.name)
  },
}

setTimeout(user.say, 1000) // что выведет?
```

Результат: `undefined` (или ошибка в строгом режиме).

**Почему:**

- в `setTimeout` передаётся **ссылка на функцию**, а не «вызов как метод»;
- когда движок позже вызывает этот коллбек, он делает это как `fn()`, без объекта слева → `this` теряется.

**Правильные варианты:**

```javascript
setTimeout(() => user.say(), 1000)
// или
setTimeout(user.say.bind(user), 1000)
```

То же самое происходит при работе с методами классов и реакт‑компонентами.

---

## 9.4. Замыкания (Closures) без магии

С формальной точки зрения:

> **Замыкание — это функция вместе с её лексическим окружением.**

Проще:

> Функция «помнит» переменные, которые были рядом во время её создания, даже если внешняя функция уже закончила выполнение.

### Базовый пример

```javascript
function makeCounter() {
  let count = 0

  return function () {
    count++
    console.log(count)
  }
}

const counter = makeCounter()
counter() // 1
counter() // 2
```

`count` продолжает жить в памяти, пока существует хотя бы одно замыкание (внутренняя функция), которое на него ссылается.

### Важно: замыкание — это **ссылка**, а не копия

Новички часто думают, что внутренняя функция запомнила «значение на момент создания». На самом деле она хранит **ссылку на переменную**.

Это объясняет и классическую задачу с циклом:

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10)
}
// 3 3 3
```

`var` создаёт **одну переменную `i`** на весь цикл, и все стрелочные функции смотрят в одно и то же место в памяти.

Правильные варианты:

```javascript
// 1. let даёт новую переменную i на каждую итерацию
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 10)
}

// 2. IIFE (исторический паттерн)
for (var i = 0; i < 3; i++) {
  ;((j) => {
    setTimeout(() => console.log(j), 10)
  })(i)
}
```

### Практическое использование замыканий

- инкапсуляция состояния (счётчики, кэши);
- фабрики функций с преднастроенными параметрами;
- мемоизация;
- приватные данные до появления `#private` полей в классах.

```javascript
function createUser(name) {
  let secret = 'hidden'

  return {
    getName() {
      return name
    },
    getSecret() {
      return secret
    },
  }
}

const u = createUser('Bob')
u.getSecret() // 'hidden', прямого доступа к secret нет
```

---

## 9.5. Функции высшего порядка, каррирование и частичное применение

**Функция высшего порядка (Higher-Order Function, HOF)** — это функция, которая:

- принимает другую функцию как аргумент **или**
- возвращает функцию как результат.

Встроенные примеры: `map`, `filter`, `reduce`, `forEach`, `sort`.

```javascript
function withLogging<T extends unknown[], R>(fn: (...args: T) => R) {
  return (...args: T): R => {
    console.log('Calling with', args)
    return fn(...args)
  }
}

const sum = (a: number, b: number) => a + b
const loggedSum = withLogging(sum)

loggedSum(4, 5) // лог + 9
```

### Каррирование (currying)

Каррирование — превращение:

```text
f(a, b, c)
```

в:

```text
f(a)(b)(c)
```

Это удобно, когда часть аргументов известна заранее.

### Частичное применение (partial application)

Частичное применение — когда мы фиксируем **часть аргументов**, а остальные передаём позже.

```javascript
function partial(fn, ...fixed) {
  return (...rest) => fn(...fixed, ...rest)
}

const multiply = (a, b, c) => a * b * c
const double = partial(multiply, 2)

double(3, 4) // 24
```

На практике подобные приёмы часто видны в:

- middleware;
- логгерах;
- валидации;
- функциональных утилитах (`lodash/fp`, `ramda`).

---

## 9.6. Прототипная модель: как работает `new` и `prototype`

JavaScript — **прототипно‑ориентированный** язык. Классы в ES6 — это **синтаксический сахар**, а не новая модель.

### Что такое прототип

У каждого объекта есть скрытая ссылка `[[Prototype]]` (в браузерах — `__proto__`), которая указывает на другой объект.

При обращении к `user.name` движок делает:

1. ищет `name` в самом объекте `user`;
2. если нет — идёт по цепочке в прототип: `Object.getPrototypeOf(user)`;
3. так доходит до `Object.prototype`;
4. если не нашёл — возвращает `undefined`.

Это и есть **цепочка прототипов (prototype chain)**.

### Функции‑конструкторы и свойство `prototype`

```javascript
function User(name) {
  this.name = name
}

User.prototype.say = function () {
  console.log(this.name)
}

const u = new User('Alex')
u.say() // 'Alex'
```

Здесь происходит следующее:

- у функции `User` есть объект `User.prototype`;
- при вызове `new User()` движок создаёт новый объект и делает:

```javascript
instance.__proto__ === User.prototype // true
```

То есть все методы, записанные в `User.prototype`, становятся доступны всем экземплярам.

### Алгоритм `new` в 4 шага

Условно:

1. создаётся пустой объект `{}`;
2. его прототип связывается с `Constructor.prototype`;
3. вызывается конструктор с `this = новый объект`;
4. если конструктор вернул объект — он и будет результатом; иначе вернётся `this`.

Это любят спрашивать на собеседованиях, чтобы проверить понимание прототипной модели.

---

## 9.7. ES6‑классы: синтаксический сахар над прототипами

Современный синтаксис:

```javascript
class Animal {
  constructor(name) {
    this.name = name
  }

  eat() {
    console.log(this.name, 'eats')
  }
}

class Dog extends Animal {
  bark() {
    console.log(this.name, 'barks')
  }
}

const d = new Dog('Rex')
d.eat() // 'Rex eats'
d.bark() // 'Rex barks'
```

Под капотом это всё те же **функции‑конструкторы и прототипы**.

### Важные особенности классов

- классы **не поднимаются** как Function Declaration;
- внутри классов по умолчанию strict mode;
- методы автоматически попадают в `prototype`;
- класс нельзя вызвать без `new`.

### `super` и наследование

```javascript
class A {
  say() {
    console.log('A')
  }
}

class B extends A {
  say() {
    super.say()
    console.log('B')
  }
}

new B().say() // A \n B
```

- `super()` в конструкторе — вызов конструктора родителя (обязательно до `this`);
- `super.method()` — вызов метода родителя.

### Приватные поля (#)

Современный стандарт приватности:

```javascript
class User {
  #password = 'secret'

  getPassword() {
    return this.#password
  }
}
```

Доступ к `#password` возможен только внутри класса.

---

## 9.8. Модули: ES Modules и CommonJS

Сегодня ты почти наверняка встретишь **оба подхода**:

### ES Modules (ESM)

```javascript
// sum.js
export const sum = (a, b) => a + b

// usage
import { sum } from './sum.js'
```

Особенности:

- статический импорт (известен на этапе сборки);
- позволяет tree‑shaking;
- стандарт для браузеров и современного Node.js.

### CommonJS (CJS)

```javascript
// sum.cjs
module.exports = (a, b) => a + b

// usage
const sum = require('./sum.cjs')
```

Особенности:

- динамический импорт (можно вызывать `require` в любом месте кода);
- исторический стандарт для Node.js;
- в новых фронтенд‑проектах ESM — предпочтительный вариант.

---

## 9.9. Современный синтаксис: destructuring, spread, rest

Эти конструкции облегчают работу с объектами, массивами и аргументами функций.

### Деструктуризация

```javascript
const user = { name: 'Alex', age: 25 }
const { name, age } = user

const arr = [1, 2, 3]
const [first, second] = arr
```

С дефолтами и переименованием:

```javascript
const { role = 'user', name: username } = data
```

### Spread и rest

```javascript
const arr2 = [...arr1, 4, 5]

function sum(...nums) {
  return nums.reduce((a, b) => a + b, 0)
}

sum(1, 2, 3) // 6
```

Также важны:

- **optional chaining** `?.`;
- **nullish coalescing** `??`;
- логические присваивания `||=`, `&&=`, `??=`.

```javascript
user?.profile?.email ?? 'no email'
```

---

## 9.10. Мини‑самопроверка по главе

Проверь, что ты можешь:

- объяснить 5 основных способов, которыми определяется `this`, и привести пример для каждого;
- показать на примере, почему стрелочную функцию нельзя использовать как метод объекта, и где она, наоборот, помогает;
- объяснить, что такое замыкание, почему оно хранит **ссылку**, а не копию значения, и решить задачу с циклом и `setTimeout`;
- рассказать, как работает `new`: какие шаги выполняет движок и как связаны `instance.__proto__` и `Constructor.prototype`;
- объяснить, почему классы в JS — это синтаксический сахар над прототипами, а не «классический ООП»;
- различать ESM и CommonJS и понимать, когда какой формат встречается в реальных проектах.

Если это получается связно и без заучивания, ты прошёл через самую «скользкую» часть механики JavaScript — дальше будет проще связывать это с DOM и асинхронностью.
